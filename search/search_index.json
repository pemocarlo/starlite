{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Starlite is a light, opinionated and flexible ASGI API framework built on top of pydantic and Starlette . The Starlite framework supports plugins , ships with dependency injection , authentication , OpenAPI specifications-generation \u2013 among other common API-framework components such as middleware and guards . Installation pip install starlite Extras To install the extras required for the built-in Testing helpers: pip install starlite [ testing ] To install the extras required for using the Brotli Compression Middleware : pip install starlite [ brotli ] To install the extras required for using the Session Middleware : pip install starlite [ cryptography ] And to install all of the above: pip install starlite [ full ] Minimal Example Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 Alternatively, you can use a dataclass \u2013 either from dataclasses or from pydantic, or a TypedDict : my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> None : ... When instantiating your app, import your controller into your application's entry-point and pass it to Starlite: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run your application , use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload About the Starlite Project This project builds on top the Starlette ASGI toolkit and pydantic modelling to create a higher-order opinionated framework. The idea to use these two libraries as a basis is of course not new - it was first done in FastAPI, which in this regard (and some others) was a source of inspiration for this framework. Nonetheless, Starlite is not FastAPI - it has a different design, different project goals and a completely different codebase. The goal of this project is to become a community-driven project. That is, not to have a single \"owner\" but rather a core team of maintainers that leads the project, as well as community contributors. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. As such, the design of the API breaks from the Starlette design and instead offers an opinionated alternative. Finally, Python OOP is extremely powerful and versatile. While still allowing for function-based endpoints , Starlite seeks to build on this by placing class-based controllers at its core. Example Applications starlite-pg-redis-docker : In addition to Starlite, this demonstrates a pattern of application modularity, SQLAlchemy 2.0 ORM, Redis cache connectivity, and more. Like all Starlite projects, this application is open to contributions, big and small. starlite-hello-world : A bare-minimum application setup. Great for testing and POC work.","title":"Home"},{"location":"#_1","text":"Starlite is a light, opinionated and flexible ASGI API framework built on top of pydantic and Starlette . The Starlite framework supports plugins , ships with dependency injection , authentication , OpenAPI specifications-generation \u2013 among other common API-framework components such as middleware and guards .","title":""},{"location":"#installation","text":"pip install starlite","title":"Installation"},{"location":"#extras","text":"To install the extras required for the built-in Testing helpers: pip install starlite [ testing ] To install the extras required for using the Brotli Compression Middleware : pip install starlite [ brotli ] To install the extras required for using the Session Middleware : pip install starlite [ cryptography ] And to install all of the above: pip install starlite [ full ]","title":"Extras"},{"location":"#minimal-example","text":"Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 Alternatively, you can use a dataclass \u2013 either from dataclasses or from pydantic, or a TypedDict : my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> None : ... When instantiating your app, import your controller into your application's entry-point and pass it to Starlite: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run your application , use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload","title":"Minimal Example"},{"location":"#about-the-starlite-project","text":"This project builds on top the Starlette ASGI toolkit and pydantic modelling to create a higher-order opinionated framework. The idea to use these two libraries as a basis is of course not new - it was first done in FastAPI, which in this regard (and some others) was a source of inspiration for this framework. Nonetheless, Starlite is not FastAPI - it has a different design, different project goals and a completely different codebase. The goal of this project is to become a community-driven project. That is, not to have a single \"owner\" but rather a core team of maintainers that leads the project, as well as community contributors. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. As such, the design of the API breaks from the Starlette design and instead offers an opinionated alternative. Finally, Python OOP is extremely powerful and versatile. While still allowing for function-based endpoints , Starlite seeks to build on this by placing class-based controllers at its core.","title":"About the Starlite Project"},{"location":"#example-applications","text":"starlite-pg-redis-docker : In addition to Starlite, this demonstrates a pattern of application modularity, SQLAlchemy 2.0 ORM, Redis cache connectivity, and more. Like all Starlite projects, this application is open to contributions, big and small. starlite-hello-world : A bare-minimum application setup. Great for testing and POC work.","title":"Example Applications"},{"location":"contributing/","text":"Contribution Guide Any and all contributions and involvement with the project is welcome. The easiest way to begin contributing is to check out the open issues - and reach out on our discord server or Matrix space.","title":"Contribution Guide"},{"location":"contributing/#contribution-guide","text":"Any and all contributions and involvement with the project is welcome. The easiest way to begin contributing is to check out the open issues - and reach out on our discord server or Matrix space.","title":"Contribution Guide"},{"location":"governance/","text":"Project Governance From its inception, Starlite was envisaged as a community driven project. We encourage users to become involved with the project - feel free to open issues, chime in on discussions, review pull requests and of course - contribute code. The project is led by a group of maintainers. You can see the list of maintainers in the pyproject.toml file. Additionally, substantial contributors are invited to be members of the starlite-api organization. Our aim is to increase the number of maintainers and have at least 5 active maintainers - this will ensure the long term stability and growth of Starlite in the long run. Contributors who show commitment, contribute great code and show a willingness to become maintainers will be invited to do so. So really feel free to contribute and propose yourself as a maintainer once you contribute substantially.","title":"Project Governance"},{"location":"governance/#project-governance","text":"From its inception, Starlite was envisaged as a community driven project. We encourage users to become involved with the project - feel free to open issues, chime in on discussions, review pull requests and of course - contribute code. The project is led by a group of maintainers. You can see the list of maintainers in the pyproject.toml file. Additionally, substantial contributors are invited to be members of the starlite-api organization. Our aim is to increase the number of maintainers and have at least 5 active maintainers - this will ensure the long term stability and growth of Starlite in the long run. Contributors who show commitment, contribute great code and show a willingness to become maintainers will be invited to do so. So really feel free to contribute and propose yourself as a maintainer once you contribute substantially.","title":"Project Governance"},{"location":"license/","text":"License The MIT License (MIT) Copyright (c) 2021, 2022 Starlite-API Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"The MIT License (MIT) Copyright (c) 2021, 2022 Starlite-API Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"migration/","text":"Migration to Starlite Migrating from either Starlette or FastAPI to Starlite is rather uncomplicated, because the frameworks are for the most part inter-compatible . So what does need to be changed? LifeCycle If you use the Starlette/FastAPI lifecycle kwarg with an AsyncContextManager to bootstrap your application, you will need to convert it to use the on_startup and on_shutdown hooks . Otherwise, using lifecycle management is identical. Routing Decorators Starlite does not include any decorator as part of the Router or Starlite instances. All routes have to be declared using route handlers \u2013 in standalone functions or Controller methods. You then have to register them with the app, either by first registering them on a router and then registering the router on the app , or by registering them directly on the app . See the registering routes part of the documentation for details. Routing Classes Starlite does not extend the Starlette routing classes and instead implements its own versions of these. You will need to use the Starlite Router classes instead of their equivalents from the other frameworks. There are some differences from the Starlite class to those from the other frameworks: The Starlite version is not an ASGI app , the only ASGI app is the Starlite app and any middlewares you pass to it. The Starlite version does not include decorators , instead you have to use route handlers . The Starlite version does not support lifecycle hooks, instead you have to handle all of your lifecycle management in the app layer. If you use the Starlette Route instances directly, you will need to replace these with route handlers . Important The Starlette Mount class is replaced by the Starlite Router . The Host class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different microservices rather than use this kind of routing Dependency Injection The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depends class. In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the Provide class. Authentication FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending the Starlite AbstractAuthenticationMiddleware class . Third Party Packages Third party packages created for Starlette and FastAPI should be generally compatible with Starlite. The only exceptions are for packages that use the FastAPI dependency injection system as a basis - these will not work as such.","title":"Migration to Starlite"},{"location":"migration/#migration-to-starlite","text":"Migrating from either Starlette or FastAPI to Starlite is rather uncomplicated, because the frameworks are for the most part inter-compatible . So what does need to be changed?","title":"Migration to Starlite"},{"location":"migration/#lifecycle","text":"If you use the Starlette/FastAPI lifecycle kwarg with an AsyncContextManager to bootstrap your application, you will need to convert it to use the on_startup and on_shutdown hooks . Otherwise, using lifecycle management is identical.","title":"LifeCycle"},{"location":"migration/#routing-decorators","text":"Starlite does not include any decorator as part of the Router or Starlite instances. All routes have to be declared using route handlers \u2013 in standalone functions or Controller methods. You then have to register them with the app, either by first registering them on a router and then registering the router on the app , or by registering them directly on the app . See the registering routes part of the documentation for details.","title":"Routing Decorators"},{"location":"migration/#routing-classes","text":"Starlite does not extend the Starlette routing classes and instead implements its own versions of these. You will need to use the Starlite Router classes instead of their equivalents from the other frameworks. There are some differences from the Starlite class to those from the other frameworks: The Starlite version is not an ASGI app , the only ASGI app is the Starlite app and any middlewares you pass to it. The Starlite version does not include decorators , instead you have to use route handlers . The Starlite version does not support lifecycle hooks, instead you have to handle all of your lifecycle management in the app layer. If you use the Starlette Route instances directly, you will need to replace these with route handlers . Important The Starlette Mount class is replaced by the Starlite Router . The Host class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different microservices rather than use this kind of routing","title":"Routing Classes"},{"location":"migration/#dependency-injection","text":"The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depends class. In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the Provide class.","title":"Dependency Injection"},{"location":"migration/#authentication","text":"FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending the Starlite AbstractAuthenticationMiddleware class .","title":"Authentication"},{"location":"migration/#third-party-packages","text":"Third party packages created for Starlette and FastAPI should be generally compatible with Starlite. The only exceptions are for packages that use the FastAPI dependency injection system as a basis - these will not work as such.","title":"Third Party Packages"},{"location":"reference/0-api-reference-intro/","text":"API Reference The API references offer detailed documentation of the public API of Starlite , and semantic versioning guarantees apply to the interfaces defined within. Any undocumented interfaces are subject to change. However, users should feel free to open GitHub discussions / issues, or reach out via our Discord server to discuss the stability of any undocumented interface.","title":"API Reference"},{"location":"reference/0-api-reference-intro/#api-reference","text":"The API references offer detailed documentation of the public API of Starlite , and semantic versioning guarantees apply to the interfaces defined within. Any undocumented interfaces are subject to change. However, users should feel free to open GitHub discussions / issues, or reach out via our Discord server to discuss the stability of any undocumented interface.","title":"API Reference"},{"location":"reference/1-app/","text":"The Starlite Application starlite.app.Starlite Bases: Router __init__ __init__ ( route_handlers , * , after_exception = None , after_request = None , after_response = None , after_shutdown = None , after_startup = None , allowed_hosts = None , before_request = None , before_send = None , before_shutdown = None , before_startup = None , cache_config = DEFAULT_CACHE_CONFIG , cache_control = None , compression_config = None , cors_config = None , csrf_config = None , debug = False , dependencies = None , exception_handlers = None , guards = None , logging_config = None , middleware = None , on_app_init = None , on_shutdown = None , on_startup = None , openapi_config = DEFAULT_OPENAPI_CONFIG , parameters = None , plugins = None , request_class = None , response_class = None , response_cookies = None , response_headers = None , security = None , static_files_config = None , tags = None , template_config = None , websocket_class = None ) The Starlite application. Starlite is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. It inherits from the Router class. Parameters: Name Type Description Default after_exception Optional [ SingleOrList[AfterExceptionHookHandler] ] An application level exception hook handler or list thereof.This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be either an instance of Response or starlette.Response . None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None after_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. None after_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. None allowed_hosts Optional [ List [ str ]] A list of allowed hosts - enables the builtin allowed hosts middleware. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. None before_send Optional [ SingleOrList[BeforeMessageSendHookHandler] ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. None before_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. None before_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. None cache_config CacheConfig Configures caching behavior of the application. DEFAULT_CACHE_CONFIG cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers. None compression_config Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. None cors_config Optional [ CORSConfig ] If set this enables the builtin CORS middleware. None csrf_config Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. None debug bool If True , app errors rendered as HTML with a stack trace. False dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None logging_config Optional [ BaseLoggingConfig ] A subclass of BaseLoggingConfig . None middleware Optional [ List [ Middleware ]] A list of Middleware . None on_app_init Optional [ List [ OnAppInitHandler ]] A sequence of OnAppInitHandler instances. Handlers receive an instance of AppConfig that will have been initially populated with the parameters passed to Starlite , and must return an instance of same. If more than one handler is registered they are called in the order they are provided. None on_shutdown Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application shutdown. None on_startup Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application startup. None openapi_config Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG DEFAULT_OPENAPI_CONFIG parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None plugins Optional [ List [ PluginProtocol ]] List of plugins. None request_class Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details. None static_files_config Optional [ Union [ StaticFilesConfig , List [ StaticFilesConfig ]]] An instance or list of StaticFilesConfig None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the application. None template_config Optional [ TemplateConfig ] An instance of TemplateConfig None websocket_class Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections. None __call__ async __call__ ( scope , receive , send ) The application entry point. Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used Parameters: Name Type Description Default scope Union [ Scope , LifeSpanScope ] The ASGI connection scope. required receive Union [ Receive , LifeSpanReceive ] The ASGI receive function. required send Union [ Send , LifeSpanSend ] The ASGI send function. required Returns: Type Description None None get_handler_index_by_name get_handler_index_by_name ( name ) Receives a route handler name and returns an optional dictionary containing the route handler instance and list of paths sorted lexically. Examples: from starlite import Starlite , get @get ( \"/\" , name = \"my-handler\" ) def handler () -> None : pass app = Starlite ( route_handlers = [ handler ]) handler_index = app . get_handler_index_by_name ( \"my-handler\" ) # { \"paths\": [\"/\"], \"handler\" ... } Parameters: Name Type Description Default name str A route handler unique name. required Returns: Type Description Optional [ HandlerIndex ] A HandlerIndex instance or None. register register ( value ) Registers a route handler on the app. This method can be used to dynamically add endpoints to an application. Parameters: Name Type Description Default value ControllerRouterHandler an instance of Router , a subclasses of required Controller or any function decorated by the route handler decorators. Returns: Type Description None None route_handler_method_view property route_handler_method_view () Returns: Type Description Dict [ str , List [ str ]] A dictionary mapping route handlers to paths. route_reverse route_reverse ( name , ** path_parameters ) Receives a route handler name, path parameter values and returns url path to the handler with filled path parameters. Examples: from starlite import Starlite , get @get ( \"/group/{group_id:int}/user/{user_id:int}\" , name = \"get_membership_details\" ) def get_membership_details ( group_id : int , user_id : int ) -> None : pass app = Starlite ( route_handlers = [ get_membership_details ]) path = app . route_reverse ( \"get_membership_details\" , user_id = 100 , group_id = 10 ) # /group/10/user/100 Parameters: Name Type Description Default name str A route handler unique name. required **path_parameters Any Actual values for path parameters in the route. {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type. Returns: Type Description str A fully formatted url path. url_for_static_asset url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved url path to the asset. Examples: from starlite import Starlite , StaticFilesConfig app = Starlite ( static_files_config = StaticFilesConfig ( directories = [ \"css\" ], path = \"/static/css\" ) ) path = app . url_for_static_asset ( \"css\" , \"main.css\" ) # /static/css/main.css Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A url path to the asset. starlite.app.HandlerIndex Bases: TypedDict This class is used to map route handler names to a mapping of paths + route handler. It's returned from the 'get_handler_index_by_name' utility method. paths class-attribute paths : List [ str ] Full route paths to the route handler. handler class-attribute handler : RouteHandlerType Route handler instance. identifier class-attribute identifier : str Unique identifier of the handler. Either equal to the 'name' attribute or the str value of the handler. starlite.app.DEFAULT_OPENAPI_CONFIG module-attribute starlite . app . DEFAULT_OPENAPI_CONFIG = OpenAPIConfig ( title = 'Starlite API' , version = '1.0.0' ) The default OpenAPI config used if not configuration is explicitly passed to the Starlite instance constructor. starlite.app.DEFAULT_CACHE_CONFIG module-attribute starlite . app . DEFAULT_CACHE_CONFIG = CacheConfig () The default cache config used if not configuration is explicitly passed to the Starlite instance constructor.","title":"The Starlite Application"},{"location":"reference/1-app/#the-starlite-application","text":"","title":"The Starlite Application"},{"location":"reference/1-app/#starlite.app.Starlite","text":"Bases: Router","title":"Starlite"},{"location":"reference/1-app/#starlite.app.Starlite.__init__","text":"__init__ ( route_handlers , * , after_exception = None , after_request = None , after_response = None , after_shutdown = None , after_startup = None , allowed_hosts = None , before_request = None , before_send = None , before_shutdown = None , before_startup = None , cache_config = DEFAULT_CACHE_CONFIG , cache_control = None , compression_config = None , cors_config = None , csrf_config = None , debug = False , dependencies = None , exception_handlers = None , guards = None , logging_config = None , middleware = None , on_app_init = None , on_shutdown = None , on_startup = None , openapi_config = DEFAULT_OPENAPI_CONFIG , parameters = None , plugins = None , request_class = None , response_class = None , response_cookies = None , response_headers = None , security = None , static_files_config = None , tags = None , template_config = None , websocket_class = None ) The Starlite application. Starlite is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. It inherits from the Router class. Parameters: Name Type Description Default after_exception Optional [ SingleOrList[AfterExceptionHookHandler] ] An application level exception hook handler or list thereof.This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be either an instance of Response or starlette.Response . None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None after_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. None after_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. None allowed_hosts Optional [ List [ str ]] A list of allowed hosts - enables the builtin allowed hosts middleware. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. None before_send Optional [ SingleOrList[BeforeMessageSendHookHandler] ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. None before_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. None before_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. None cache_config CacheConfig Configures caching behavior of the application. DEFAULT_CACHE_CONFIG cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers. None compression_config Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. None cors_config Optional [ CORSConfig ] If set this enables the builtin CORS middleware. None csrf_config Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. None debug bool If True , app errors rendered as HTML with a stack trace. False dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None logging_config Optional [ BaseLoggingConfig ] A subclass of BaseLoggingConfig . None middleware Optional [ List [ Middleware ]] A list of Middleware . None on_app_init Optional [ List [ OnAppInitHandler ]] A sequence of OnAppInitHandler instances. Handlers receive an instance of AppConfig that will have been initially populated with the parameters passed to Starlite , and must return an instance of same. If more than one handler is registered they are called in the order they are provided. None on_shutdown Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application shutdown. None on_startup Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application startup. None openapi_config Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG DEFAULT_OPENAPI_CONFIG parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None plugins Optional [ List [ PluginProtocol ]] List of plugins. None request_class Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details. None static_files_config Optional [ Union [ StaticFilesConfig , List [ StaticFilesConfig ]]] An instance or list of StaticFilesConfig None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the application. None template_config Optional [ TemplateConfig ] An instance of TemplateConfig None websocket_class Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections. None","title":"__init__()"},{"location":"reference/1-app/#starlite.app.Starlite.__call__","text":"__call__ ( scope , receive , send ) The application entry point. Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used Parameters: Name Type Description Default scope Union [ Scope , LifeSpanScope ] The ASGI connection scope. required receive Union [ Receive , LifeSpanReceive ] The ASGI receive function. required send Union [ Send , LifeSpanSend ] The ASGI send function. required Returns: Type Description None None","title":"__call__()"},{"location":"reference/1-app/#starlite.app.Starlite.get_handler_index_by_name","text":"get_handler_index_by_name ( name ) Receives a route handler name and returns an optional dictionary containing the route handler instance and list of paths sorted lexically. Examples: from starlite import Starlite , get @get ( \"/\" , name = \"my-handler\" ) def handler () -> None : pass app = Starlite ( route_handlers = [ handler ]) handler_index = app . get_handler_index_by_name ( \"my-handler\" ) # { \"paths\": [\"/\"], \"handler\" ... } Parameters: Name Type Description Default name str A route handler unique name. required Returns: Type Description Optional [ HandlerIndex ] A HandlerIndex instance or None.","title":"get_handler_index_by_name()"},{"location":"reference/1-app/#starlite.app.Starlite.register","text":"register ( value ) Registers a route handler on the app. This method can be used to dynamically add endpoints to an application. Parameters: Name Type Description Default value ControllerRouterHandler an instance of Router , a subclasses of required Controller or any function decorated by the route handler decorators. Returns: Type Description None None","title":"register()"},{"location":"reference/1-app/#starlite.app.Starlite.route_handler_method_view","text":"route_handler_method_view () Returns: Type Description Dict [ str , List [ str ]] A dictionary mapping route handlers to paths.","title":"route_handler_method_view()"},{"location":"reference/1-app/#starlite.app.Starlite.route_reverse","text":"route_reverse ( name , ** path_parameters ) Receives a route handler name, path parameter values and returns url path to the handler with filled path parameters. Examples: from starlite import Starlite , get @get ( \"/group/{group_id:int}/user/{user_id:int}\" , name = \"get_membership_details\" ) def get_membership_details ( group_id : int , user_id : int ) -> None : pass app = Starlite ( route_handlers = [ get_membership_details ]) path = app . route_reverse ( \"get_membership_details\" , user_id = 100 , group_id = 10 ) # /group/10/user/100 Parameters: Name Type Description Default name str A route handler unique name. required **path_parameters Any Actual values for path parameters in the route. {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type. Returns: Type Description str A fully formatted url path.","title":"route_reverse()"},{"location":"reference/1-app/#starlite.app.Starlite.url_for_static_asset","text":"url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved url path to the asset. Examples: from starlite import Starlite , StaticFilesConfig app = Starlite ( static_files_config = StaticFilesConfig ( directories = [ \"css\" ], path = \"/static/css\" ) ) path = app . url_for_static_asset ( \"css\" , \"main.css\" ) # /static/css/main.css Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A url path to the asset.","title":"url_for_static_asset()"},{"location":"reference/1-app/#starlite.app.HandlerIndex","text":"Bases: TypedDict This class is used to map route handler names to a mapping of paths + route handler. It's returned from the 'get_handler_index_by_name' utility method.","title":"HandlerIndex"},{"location":"reference/1-app/#starlite.app.HandlerIndex.paths","text":"paths : List [ str ] Full route paths to the route handler.","title":"paths"},{"location":"reference/1-app/#starlite.app.HandlerIndex.handler","text":"handler : RouteHandlerType Route handler instance.","title":"handler"},{"location":"reference/1-app/#starlite.app.HandlerIndex.identifier","text":"identifier : str Unique identifier of the handler. Either equal to the 'name' attribute or the str value of the handler.","title":"identifier"},{"location":"reference/1-app/#starlite.app.DEFAULT_OPENAPI_CONFIG","text":"starlite . app . DEFAULT_OPENAPI_CONFIG = OpenAPIConfig ( title = 'Starlite API' , version = '1.0.0' ) The default OpenAPI config used if not configuration is explicitly passed to the Starlite instance constructor.","title":"DEFAULT_OPENAPI_CONFIG"},{"location":"reference/1-app/#starlite.app.DEFAULT_CACHE_CONFIG","text":"starlite . app . DEFAULT_CACHE_CONFIG = CacheConfig () The default cache config used if not configuration is explicitly passed to the Starlite instance constructor.","title":"DEFAULT_CACHE_CONFIG"},{"location":"reference/2-router/","text":"Router starlite.router.Router __init__ __init__ ( path , * , after_request = None , after_response = None , before_request = None , cache_control = None , dependencies = None , exception_handlers = None , guards = None , middleware = None , parameters = None , response_class = None , response_cookies = None , response_headers = None , route_handlers , security = None , tags = None ) The Starlite Router class. A Router instance is used to group controller, routers and route handler functions under a shared path fragment. Parameters: Name Type Description Default after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this router. Can be overridden by route handlers. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None path str A path fragment that is prefixed to all route handlers, controllers and other routers associated with the router instance. required response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default for all route handlers, controllers and other routers associated with the router instance. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers under the router. None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the router. None register register ( value ) Register a Controller, Route instance or RouteHandler on the router. Parameters: Name Type Description Default value ControllerRouterHandler a subclass or instance of Controller, an instance of Router or a function/method that has been decorated by any of the routing decorators, e.g. get , post . required Returns: Type Description List [ BaseRoute ] Collection of handlers added to the router.","title":"Router"},{"location":"reference/2-router/#router","text":"","title":"Router"},{"location":"reference/2-router/#starlite.router.Router","text":"","title":"Router"},{"location":"reference/2-router/#starlite.router.Router.__init__","text":"__init__ ( path , * , after_request = None , after_response = None , before_request = None , cache_control = None , dependencies = None , exception_handlers = None , guards = None , middleware = None , parameters = None , response_class = None , response_cookies = None , response_headers = None , route_handlers , security = None , tags = None ) The Starlite Router class. A Router instance is used to group controller, routers and route handler functions under a shared path fragment. Parameters: Name Type Description Default after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this router. Can be overridden by route handlers. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None path str A path fragment that is prefixed to all route handlers, controllers and other routers associated with the router instance. required response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default for all route handlers, controllers and other routers associated with the router instance. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers under the router. None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the router. None","title":"__init__()"},{"location":"reference/2-router/#starlite.router.Router.register","text":"register ( value ) Register a Controller, Route instance or RouteHandler on the router. Parameters: Name Type Description Default value ControllerRouterHandler a subclass or instance of Controller, an instance of Router or a function/method that has been decorated by any of the routing decorators, e.g. get , post . required Returns: Type Description List [ BaseRoute ] Collection of handlers added to the router.","title":"register()"},{"location":"reference/3-controller/","text":"Controller starlite.controller.Controller The Starlite Controller class. Subclass this class to create 'view' like components and utilize OOP. after_request class-attribute after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_response class-attribute after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request instance and should not return any values. before_request class-attribute before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. It receives the Request instance and any non- None return value is used for the response, bypassing the route handler. cache_control class-attribute cache_control : Optional [ CacheControlHeader ] A CacheControlHeader header to add to route handlers of this controller. Can be overridden by route handlers. dependencies class-attribute dependencies : Optional [ Dependencies ] dependencies: A string keyed dictionary of dependency Provider instances. exception_handlers class-attribute exception_handlers : Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. guards class-attribute guards : Optional [ List [ Guard ]] A list of Guard callables. middleware class-attribute middleware : Optional [ List [ Middleware ]] A list of Middleware . owner instance-attribute owner = owner parameters class-attribute parameters : Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. path instance-attribute path = normalize_path ( self . path or '/' ) response_class class-attribute response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default response for all route handlers under the controller. response_cookies class-attribute response_cookies : Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. response_headers class-attribute response_headers : Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. security class-attribute security : Optional [ List [ SecurityRequirement ]] A list of dictionaries that to the schema of all route handlers under the controller. tags class-attribute tags : Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the controller.","title":"Controller"},{"location":"reference/3-controller/#controller","text":"","title":"Controller"},{"location":"reference/3-controller/#starlite.controller.Controller","text":"The Starlite Controller class. Subclass this class to create 'view' like components and utilize OOP.","title":"Controller"},{"location":"reference/3-controller/#starlite.controller.Controller.after_request","text":"after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.","title":"after_request"},{"location":"reference/3-controller/#starlite.controller.Controller.after_response","text":"after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request instance and should not return any values.","title":"after_response"},{"location":"reference/3-controller/#starlite.controller.Controller.before_request","text":"before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. It receives the Request instance and any non- None return value is used for the response, bypassing the route handler.","title":"before_request"},{"location":"reference/3-controller/#starlite.controller.Controller.cache_control","text":"cache_control : Optional [ CacheControlHeader ] A CacheControlHeader header to add to route handlers of this controller. Can be overridden by route handlers.","title":"cache_control"},{"location":"reference/3-controller/#starlite.controller.Controller.dependencies","text":"dependencies : Optional [ Dependencies ] dependencies: A string keyed dictionary of dependency Provider instances.","title":"dependencies"},{"location":"reference/3-controller/#starlite.controller.Controller.exception_handlers","text":"exception_handlers : Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types.","title":"exception_handlers"},{"location":"reference/3-controller/#starlite.controller.Controller.guards","text":"guards : Optional [ List [ Guard ]] A list of Guard callables.","title":"guards"},{"location":"reference/3-controller/#starlite.controller.Controller.middleware","text":"middleware : Optional [ List [ Middleware ]] A list of Middleware .","title":"middleware"},{"location":"reference/3-controller/#starlite.controller.Controller.owner","text":"owner = owner","title":"owner"},{"location":"reference/3-controller/#starlite.controller.Controller.parameters","text":"parameters : Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths.","title":"parameters"},{"location":"reference/3-controller/#starlite.controller.Controller.path","text":"path = normalize_path ( self . path or '/' )","title":"path"},{"location":"reference/3-controller/#starlite.controller.Controller.response_class","text":"response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default response for all route handlers under the controller.","title":"response_class"},{"location":"reference/3-controller/#starlite.controller.Controller.response_cookies","text":"response_cookies : Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances.","title":"response_cookies"},{"location":"reference/3-controller/#starlite.controller.Controller.response_headers","text":"response_headers : Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances.","title":"response_headers"},{"location":"reference/3-controller/#starlite.controller.Controller.security","text":"security : Optional [ List [ SecurityRequirement ]] A list of dictionaries that to the schema of all route handlers under the controller.","title":"security"},{"location":"reference/3-controller/#starlite.controller.Controller.tags","text":"tags : Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the controller.","title":"tags"},{"location":"reference/4-response/","text":"Responses starlite.response.Response Bases: StarletteResponse , Generic [ T ] __init__ __init__ ( content , * , status_code , media_type , background = None , headers = None , cookies = None ) The response class is used to return an HTTP response. Parameters: Name Type Description Default content T A value for the response body that will be rendered into bytes string. required status_code int A value for the response HTTP status code. required media_type Union [ MediaType , OpenAPIMediaType , str ] A value for the response 'Content-Type' header. required background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None serializer staticmethod serializer ( value ) Serializer hook for orjson to handle pydantic models. Parameters: Name Type Description Default value Any A value to serialize required Returns: Type Description Any A serialized value Raises: Type Description TypeError if value is not supported render render ( content ) Handles the rendering of content T into a bytes string. Parameters: Name Type Description Default content Any An arbitrary value of type T required Returns: Type Description bytes An encoded bytes string starlite.response.TemplateResponse Bases: Response __init__ __init__ ( template_name , template_engine , status_code , context , background = None , headers = None , cookies = None , ) Handles the rendering of a given template into a bytes string. Parameters: Name Type Description Default template_name str Path-like name for the template to be rendered, e.g. \"index.html\". required template_engine TemplateEngineProtocol The template engine class to use to render the response. required status_code int A value for the response HTTP status code. required context Dict [ str , Any ] A dictionary of key/value pairs to be passed to the temple engine's render method. required background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None","title":"Responses"},{"location":"reference/4-response/#responses","text":"","title":"Responses"},{"location":"reference/4-response/#starlite.response.Response","text":"Bases: StarletteResponse , Generic [ T ]","title":"Response"},{"location":"reference/4-response/#starlite.response.Response.__init__","text":"__init__ ( content , * , status_code , media_type , background = None , headers = None , cookies = None ) The response class is used to return an HTTP response. Parameters: Name Type Description Default content T A value for the response body that will be rendered into bytes string. required status_code int A value for the response HTTP status code. required media_type Union [ MediaType , OpenAPIMediaType , str ] A value for the response 'Content-Type' header. required background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None","title":"__init__()"},{"location":"reference/4-response/#starlite.response.Response.serializer","text":"serializer ( value ) Serializer hook for orjson to handle pydantic models. Parameters: Name Type Description Default value Any A value to serialize required Returns: Type Description Any A serialized value Raises: Type Description TypeError if value is not supported","title":"serializer()"},{"location":"reference/4-response/#starlite.response.Response.render","text":"render ( content ) Handles the rendering of content T into a bytes string. Parameters: Name Type Description Default content Any An arbitrary value of type T required Returns: Type Description bytes An encoded bytes string","title":"render()"},{"location":"reference/4-response/#starlite.response.TemplateResponse","text":"Bases: Response","title":"TemplateResponse"},{"location":"reference/4-response/#starlite.response.TemplateResponse.__init__","text":"__init__ ( template_name , template_engine , status_code , context , background = None , headers = None , cookies = None , ) Handles the rendering of a given template into a bytes string. Parameters: Name Type Description Default template_name str Path-like name for the template to be rendered, e.g. \"index.html\". required template_engine TemplateEngineProtocol The template engine class to use to render the response. required status_code int A value for the response HTTP status code. required context Dict [ str , Any ] A dictionary of key/value pairs to be passed to the temple engine's render method. required background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None","title":"__init__()"},{"location":"reference/5-dto/","text":"DTO starlite.dto.DTO Bases: GenericModel , Generic [ T ] from_model_instance classmethod from_model_instance ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass. from_model_instance_async classmethod async from_model_instance_async ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass asynchronously. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass. to_model_instance to_model_instance () Convert the DTO instance into an instance of the original class from which the DTO was created. Returns: Type Description T Instance of source model type. starlite.dto.DTOFactory __init__ __init__ ( plugins = None ) Create DTO types. Pydantic models, TypedDict and dataclasses are natively supported. Other types supported via plugins. Parameters: Name Type Description Default plugins list [ PluginProtocol ] | None Plugins used to support DTO construction from arbitrary types. None __call__ __call__ ( name , source , exclude = None , field_mapping = None , field_definitions = None ) Given a supported model class - either pydantic, TypedDict , dataclass or a class supported via plugins, create a DTO pydantic model class. An instance of the factory must first be created, passing any plugins to it. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes specifies in the 'exclude' list and remap field names and/or field types. For example, given a pydantic model class MyClass ( BaseModel ): first : int second : int MyClassDTO = DTOFactory ()( MyClass , exclude = [ \"first\" ], field_mapping = { \"second\" : ( \"third\" , float )} ) MyClassDTO is now equal to this: class MyClassDTO ( BaseModel ): third : float It can be used as a regular pydantic model: @post ( path = \"/my-path\" ) def create_obj ( data : MyClassDTO ) -> MyClass : ... This will affect parsing, validation and how OpenAPI schema is generated exactly like when using a pydantic model. Note: Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently not possible to extend editor auto-complete for the DTO properties - it will be typed as a Pydantic BaseModel, but no attributes will be inferred in the editor. Parameters: Name Type Description Default name str This becomes the name of the generated pydantic model. required source type [ T ] A type that is either a subclass of BaseModel , TypedDict , a dataclass or any other type with a plugin registered. required exclude list [ str ] | None Names of attributes on source . Named Attributes will not have a field generated on the resultant pydantic model. None field_mapping dict [ str , str | tuple [ str , Any ]] | None Keys are names of attributes on source . Values are either a str to rename an attribute, or tuple (str, Any) to remap both name and type of the attribute. None field_definitions dict [ str , tuple [ Any , Any ]] | None Add fields to the model that don't exist on source . These are passed as kwargs to pydantic.create_model() . None Returns: Type Description Type [ DTO [ T ]] Type[DTO[T]] Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If source is not a pydantic model, TypedDict or dataclass, and there is no plugin registered for its type.","title":"DTO"},{"location":"reference/5-dto/#dto","text":"","title":"DTO"},{"location":"reference/5-dto/#starlite.dto.DTO","text":"Bases: GenericModel , Generic [ T ]","title":"DTO"},{"location":"reference/5-dto/#starlite.dto.DTO.from_model_instance","text":"from_model_instance ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass.","title":"from_model_instance()"},{"location":"reference/5-dto/#starlite.dto.DTO.from_model_instance_async","text":"from_model_instance_async ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass asynchronously. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass.","title":"from_model_instance_async()"},{"location":"reference/5-dto/#starlite.dto.DTO.to_model_instance","text":"to_model_instance () Convert the DTO instance into an instance of the original class from which the DTO was created. Returns: Type Description T Instance of source model type.","title":"to_model_instance()"},{"location":"reference/5-dto/#starlite.dto.DTOFactory","text":"","title":"DTOFactory"},{"location":"reference/5-dto/#starlite.dto.DTOFactory.__init__","text":"__init__ ( plugins = None ) Create DTO types. Pydantic models, TypedDict and dataclasses are natively supported. Other types supported via plugins. Parameters: Name Type Description Default plugins list [ PluginProtocol ] | None Plugins used to support DTO construction from arbitrary types. None","title":"__init__()"},{"location":"reference/5-dto/#starlite.dto.DTOFactory.__call__","text":"__call__ ( name , source , exclude = None , field_mapping = None , field_definitions = None ) Given a supported model class - either pydantic, TypedDict , dataclass or a class supported via plugins, create a DTO pydantic model class. An instance of the factory must first be created, passing any plugins to it. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes specifies in the 'exclude' list and remap field names and/or field types. For example, given a pydantic model class MyClass ( BaseModel ): first : int second : int MyClassDTO = DTOFactory ()( MyClass , exclude = [ \"first\" ], field_mapping = { \"second\" : ( \"third\" , float )} ) MyClassDTO is now equal to this: class MyClassDTO ( BaseModel ): third : float It can be used as a regular pydantic model: @post ( path = \"/my-path\" ) def create_obj ( data : MyClassDTO ) -> MyClass : ... This will affect parsing, validation and how OpenAPI schema is generated exactly like when using a pydantic model. Note: Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently not possible to extend editor auto-complete for the DTO properties - it will be typed as a Pydantic BaseModel, but no attributes will be inferred in the editor. Parameters: Name Type Description Default name str This becomes the name of the generated pydantic model. required source type [ T ] A type that is either a subclass of BaseModel , TypedDict , a dataclass or any other type with a plugin registered. required exclude list [ str ] | None Names of attributes on source . Named Attributes will not have a field generated on the resultant pydantic model. None field_mapping dict [ str , str | tuple [ str , Any ]] | None Keys are names of attributes on source . Values are either a str to rename an attribute, or tuple (str, Any) to remap both name and type of the attribute. None field_definitions dict [ str , tuple [ Any , Any ]] | None Add fields to the model that don't exist on source . These are passed as kwargs to pydantic.create_model() . None Returns: Type Description Type [ DTO [ T ]] Type[DTO[T]] Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If source is not a pydantic model, TypedDict or dataclass, and there is no plugin registered for its type.","title":"__call__()"},{"location":"reference/6-enums/","text":"Enums starlite.enums.HttpMethod Bases: str , Enum An Enum for HTTP methods. DELETE class-attribute DELETE = 'DELETE' GET class-attribute GET = 'GET' PATCH class-attribute PATCH = 'PATCH' POST class-attribute POST = 'POST' PUT class-attribute PUT = 'PUT' starlite.enums.MediaType Bases: str , Enum An Enum for 'Content-Type' header values. HTML class-attribute HTML = 'text/html' JSON class-attribute JSON = 'application/json' TEXT class-attribute TEXT = 'text/plain' starlite.enums.OpenAPIMediaType Bases: str , Enum An Enum for OpenAPI specific response 'Content-Type' header values. OPENAPI_JSON class-attribute OPENAPI_JSON = 'application/vnd.oai.openapi+json' OPENAPI_YAML class-attribute OPENAPI_YAML = 'application/vnd.oai.openapi' starlite.enums.RequestEncodingType Bases: str , Enum An Enum for request 'Content-Type' header values designating encoding formats. JSON class-attribute JSON = 'application/json' MULTI_PART class-attribute MULTI_PART = 'multipart/form-data' URL_ENCODED class-attribute URL_ENCODED = 'application/x-www-form-urlencoded' starlite.enums.ScopeType Bases: str , Enum An Enum for the 'http' key stored under Scope. Notes 'asgi' is used by Starlite internally and is not part of the specification. HTTP class-attribute HTTP = 'http' WEBSOCKET class-attribute WEBSOCKET = 'websocket' ASGI class-attribute ASGI = 'asgi' starlite.enums.ParamType Bases: str , Enum An Enum for the types of parameters a request can receive. PATH class-attribute PATH = 'path' QUERY class-attribute QUERY = 'query' COOKIE class-attribute COOKIE = 'cookie' HEADER class-attribute HEADER = 'header'","title":"Enums"},{"location":"reference/6-enums/#enums","text":"","title":"Enums"},{"location":"reference/6-enums/#starlite.enums.HttpMethod","text":"Bases: str , Enum An Enum for HTTP methods.","title":"HttpMethod"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.DELETE","text":"DELETE = 'DELETE'","title":"DELETE"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.GET","text":"GET = 'GET'","title":"GET"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.PATCH","text":"PATCH = 'PATCH'","title":"PATCH"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.POST","text":"POST = 'POST'","title":"POST"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.PUT","text":"PUT = 'PUT'","title":"PUT"},{"location":"reference/6-enums/#starlite.enums.MediaType","text":"Bases: str , Enum An Enum for 'Content-Type' header values.","title":"MediaType"},{"location":"reference/6-enums/#starlite.enums.MediaType.HTML","text":"HTML = 'text/html'","title":"HTML"},{"location":"reference/6-enums/#starlite.enums.MediaType.JSON","text":"JSON = 'application/json'","title":"JSON"},{"location":"reference/6-enums/#starlite.enums.MediaType.TEXT","text":"TEXT = 'text/plain'","title":"TEXT"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType","text":"Bases: str , Enum An Enum for OpenAPI specific response 'Content-Type' header values.","title":"OpenAPIMediaType"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType.OPENAPI_JSON","text":"OPENAPI_JSON = 'application/vnd.oai.openapi+json'","title":"OPENAPI_JSON"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType.OPENAPI_YAML","text":"OPENAPI_YAML = 'application/vnd.oai.openapi'","title":"OPENAPI_YAML"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType","text":"Bases: str , Enum An Enum for request 'Content-Type' header values designating encoding formats.","title":"RequestEncodingType"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.JSON","text":"JSON = 'application/json'","title":"JSON"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.MULTI_PART","text":"MULTI_PART = 'multipart/form-data'","title":"MULTI_PART"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.URL_ENCODED","text":"URL_ENCODED = 'application/x-www-form-urlencoded'","title":"URL_ENCODED"},{"location":"reference/6-enums/#starlite.enums.ScopeType","text":"Bases: str , Enum An Enum for the 'http' key stored under Scope. Notes 'asgi' is used by Starlite internally and is not part of the specification.","title":"ScopeType"},{"location":"reference/6-enums/#starlite.enums.ScopeType.HTTP","text":"HTTP = 'http'","title":"HTTP"},{"location":"reference/6-enums/#starlite.enums.ScopeType.WEBSOCKET","text":"WEBSOCKET = 'websocket'","title":"WEBSOCKET"},{"location":"reference/6-enums/#starlite.enums.ScopeType.ASGI","text":"ASGI = 'asgi'","title":"ASGI"},{"location":"reference/6-enums/#starlite.enums.ParamType","text":"Bases: str , Enum An Enum for the types of parameters a request can receive.","title":"ParamType"},{"location":"reference/6-enums/#starlite.enums.ParamType.PATH","text":"PATH = 'path'","title":"PATH"},{"location":"reference/6-enums/#starlite.enums.ParamType.QUERY","text":"QUERY = 'query'","title":"QUERY"},{"location":"reference/6-enums/#starlite.enums.ParamType.COOKIE","text":"COOKIE = 'cookie'","title":"COOKIE"},{"location":"reference/6-enums/#starlite.enums.ParamType.HEADER","text":"HEADER = 'header'","title":"HEADER"},{"location":"reference/cache/0-base-cache/","text":"Cache Backend Protocol starlite.cache.CacheBackendProtocol Bases: Protocol get async get ( key ) Retrieves a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any delete async delete ( key ) Deletes a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any starlite.cache.Cache __init__ __init__ ( backend , default_expiration , cache_key_builder ) This class wraps a provided CacheBackend and ensures it is called in an async thread-safe fashion. This enables the use of normal sync libraries (such as the standard Redis python client) for caching responses. Parameters: Name Type Description Default backend CacheBackendProtocol A class instance fulfilling the Starlite CacheBackendProtocol . required default_expiration int Default value (in seconds) for cache expiration. required cache_key_builder CacheKeyBuilder A function that receives a request object and returns a unique cache key. required get async get ( key ) Proxies 'self.backend.get'. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration = None ) Proxies 'self.backend.set'. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration Optional [ int ] expiration of cached value in seconds. None Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any delete async delete ( key ) Proxies 'self.backend.delete'. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any build_cache_key build_cache_key ( request , cache_key_builder ) Constructs a unique cache key from the request instance. Parameters: Name Type Description Default request Request A Request instance. required cache_key_builder Optional [ CacheKeyBuilder ] An optional CacheKeyBuilder function. required Returns: Type Description str A unique cache key string.","title":"Cache Backend Protocol"},{"location":"reference/cache/0-base-cache/#cache-backend-protocol","text":"","title":"Cache Backend Protocol"},{"location":"reference/cache/0-base-cache/#starlite.cache.CacheBackendProtocol","text":"Bases: Protocol","title":"CacheBackendProtocol"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.get","text":"get ( key ) Retrieves a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.set","text":"set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any","title":"set()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.delete","text":"delete ( key ) Deletes a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any","title":"delete()"},{"location":"reference/cache/0-base-cache/#starlite.cache.Cache","text":"","title":"Cache"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.__init__","text":"__init__ ( backend , default_expiration , cache_key_builder ) This class wraps a provided CacheBackend and ensures it is called in an async thread-safe fashion. This enables the use of normal sync libraries (such as the standard Redis python client) for caching responses. Parameters: Name Type Description Default backend CacheBackendProtocol A class instance fulfilling the Starlite CacheBackendProtocol . required default_expiration int Default value (in seconds) for cache expiration. required cache_key_builder CacheKeyBuilder A function that receives a request object and returns a unique cache key. required","title":"__init__()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.get","text":"get ( key ) Proxies 'self.backend.get'. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.set","text":"set ( key , value , expiration = None ) Proxies 'self.backend.set'. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration Optional [ int ] expiration of cached value in seconds. None Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any","title":"set()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.delete","text":"delete ( key ) Proxies 'self.backend.delete'. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any","title":"delete()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.build_cache_key","text":"build_cache_key ( request , cache_key_builder ) Constructs a unique cache key from the request instance. Parameters: Name Type Description Default request Request A Request instance. required cache_key_builder Optional [ CacheKeyBuilder ] An optional CacheKeyBuilder function. required Returns: Type Description str A unique cache key string.","title":"build_cache_key()"},{"location":"reference/cache/1-simple-cache/","text":"Simple Cache Backend starlite.cache.SimpleCacheBackend Bases: CacheBackendProtocol __init__ __init__ () This class offers a simple thread safe cache backend that stores values in local memory using a dict . get async get ( key ) Retrieve value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value or None . set async set ( key , value , expiration ) Set a value in cache for a given key with a given expiration in seconds. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Returns: Type Description None None delete async delete ( key ) Remove a value from the cache for a given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Returns: Type Description None None","title":"Simple Cache Backend"},{"location":"reference/cache/1-simple-cache/#simple-cache-backend","text":"","title":"Simple Cache Backend"},{"location":"reference/cache/1-simple-cache/#starlite.cache.SimpleCacheBackend","text":"Bases: CacheBackendProtocol","title":"SimpleCacheBackend"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.__init__","text":"__init__ () This class offers a simple thread safe cache backend that stores values in local memory using a dict .","title":"__init__()"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.get","text":"get ( key ) Retrieve value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value or None .","title":"get()"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.set","text":"set ( key , value , expiration ) Set a value in cache for a given key with a given expiration in seconds. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Returns: Type Description None None","title":"set()"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.delete","text":"delete ( key ) Remove a value from the cache for a given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Returns: Type Description None None","title":"delete()"},{"location":"reference/cache/2-redis-cache/","text":"Redis Cache Backend starlite.cache.redis_cache_backend.RedisCacheBackend Bases: CacheBackendProtocol __init__ __init__ ( config ) This class offers a cache backend based on Redis. Parameters: Name Type Description Default config RedisCacheBackendConfig required configuration to connect to Redis. required get async get ( key ) Retrieves a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None delete async delete ( key ) Deletes a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None starlite.cache.redis_cache_backend.RedisCacheBackendConfig Bases: BaseModel Redis cache backend configuration. url class-attribute url : str Redis connection URL db class-attribute db : Optional [ int ] = None Redis DB ID (optional) port class-attribute port : Optional [ int ] = None Redis port (optional) username class-attribute username : Optional [ str ] = None A username to use when connecting to Redis (optional) password class-attribute password : Optional [ str ] = None A password to use when connecting to Redis (optional)","title":"Redis Cache Backend"},{"location":"reference/cache/2-redis-cache/#redis-cache-backend","text":"","title":"Redis Cache Backend"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend","text":"Bases: CacheBackendProtocol","title":"RedisCacheBackend"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.__init__","text":"__init__ ( config ) This class offers a cache backend based on Redis. Parameters: Name Type Description Default config RedisCacheBackendConfig required configuration to connect to Redis. required","title":"__init__()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.get","text":"get ( key ) Retrieves a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.set","text":"set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None","title":"set()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.delete","text":"delete ( key ) Deletes a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None","title":"delete()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig","text":"Bases: BaseModel Redis cache backend configuration.","title":"RedisCacheBackendConfig"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.url","text":"url : str Redis connection URL","title":"url"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.db","text":"db : Optional [ int ] = None Redis DB ID (optional)","title":"db"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.port","text":"port : Optional [ int ] = None Redis port (optional)","title":"port"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.username","text":"username : Optional [ str ] = None A username to use when connecting to Redis (optional)","title":"username"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.password","text":"password : Optional [ str ] = None A password to use when connecting to Redis (optional)","title":"password"},{"location":"reference/cache/3-memcached-cache/","text":"Memcached Cache Backend starlite.cache.memcached_cache_backend.MemcachedCacheBackend Bases: CacheBackendProtocol __init__ __init__ ( config ) This class offers a cache backend based on memcached. Parameters: Name Type Description Default config MemcachedCacheBackendConfig required configuration to connect to memcached. required get async get ( key ) Retrieves a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None delete async delete ( key ) Deletes a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig Bases: BaseModel Memcached cache backend configuration. host class-attribute host : str memcached host port class-attribute port : Optional [ int ] = None memcached port (optional, defaults to 11211) pool_size class-attribute pool_size : Optional [ int ] = None Maximum number of memcached open connections (optional, defaults to 2) pool_minsize class-attribute pool_minsize : Optional [ int ] = None memcached minimum pool size (optional, by default set to pool_size ) serialize class-attribute serialize : Callable [[ Any ], bytes ] = pickle . dumps A callable to serialize data that goes into the cache from an object to bytes, defaults to pickle.dumps deserialize class-attribute deserialize : Callable [[ bytes ], Any ] = pickle . loads A callable to deserialize data coming from the cache from bytes to an object, defaults to pickle.loads","title":"Memcached Cache Backend"},{"location":"reference/cache/3-memcached-cache/#memcached-cache-backend","text":"","title":"Memcached Cache Backend"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend","text":"Bases: CacheBackendProtocol","title":"MemcachedCacheBackend"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.__init__","text":"__init__ ( config ) This class offers a cache backend based on memcached. Parameters: Name Type Description Default config MemcachedCacheBackendConfig required configuration to connect to memcached. required","title":"__init__()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.get","text":"get ( key ) Retrieves a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.set","text":"set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None","title":"set()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.delete","text":"delete ( key ) Deletes a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None","title":"delete()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig","text":"Bases: BaseModel Memcached cache backend configuration.","title":"MemcachedCacheBackendConfig"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.host","text":"host : str memcached host","title":"host"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.port","text":"port : Optional [ int ] = None memcached port (optional, defaults to 11211)","title":"port"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.pool_size","text":"pool_size : Optional [ int ] = None Maximum number of memcached open connections (optional, defaults to 2)","title":"pool_size"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.pool_minsize","text":"pool_minsize : Optional [ int ] = None memcached minimum pool size (optional, by default set to pool_size )","title":"pool_minsize"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.serialize","text":"serialize : Callable [[ Any ], bytes ] = pickle . dumps A callable to serialize data that goes into the cache from an object to bytes, defaults to pickle.dumps","title":"serialize"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.deserialize","text":"deserialize : Callable [[ bytes ], Any ] = pickle . loads A callable to deserialize data coming from the cache from bytes to an object, defaults to pickle.loads","title":"deserialize"},{"location":"reference/config/0-app-config/","text":"App Config starlite.config.app.AppConfig Bases: BaseModel The parameters provided to the Starlite app are used to instantiate an instance, and then the instance is passed to any callbacks registered to on_app_init in the order they are provided. The final attribute values are used to instantiate the application object. after_exception class-attribute after_exception : SingleOrList [ AfterExceptionHookHandler ] An application level exception hook handler or list thereof. This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). after_request class-attribute after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be either an instance of Response or starlette.Response . after_response class-attribute after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. after_shutdown class-attribute after_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. after_startup class-attribute after_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. allowed_hosts class-attribute allowed_hosts : List [ str ] A list of allowed hosts - enables the builtin allowed hosts middleware. before_request class-attribute before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. before_send class-attribute before_send : SingleOrList [ BeforeMessageSendHookHandler ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. before_shutdown class-attribute before_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. before_startup class-attribute before_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. cache_config class-attribute cache_config : CacheConfig Configures caching behavior of the application. cache_control class-attribute cache_control : Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers. compression_config class-attribute compression_config : Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. cors_config class-attribute cors_config : Optional [ CORSConfig ] If set this enables the builtin CORS middleware. csrf_config class-attribute csrf_config : Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. debug class-attribute debug : bool If True , app errors rendered as HTML with a stack trace. dependencies class-attribute dependencies : Dict [ str , Provide ] A string keyed dictionary of dependency Provider instances. exception_handlers class-attribute exception_handlers : ExceptionHandlersMap A dictionary that maps handler functions to status codes and/or exception types. guards class-attribute guards : List [ Guard ] A list of Guard callables. logging_config class-attribute logging_config : Optional [ BaseLoggingConfig ] An instance of BaseLoggingConfig subclass. middleware class-attribute middleware : List [ Middleware ] A list of Middleware . on_shutdown class-attribute on_shutdown : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application shutdown. on_startup class-attribute on_startup : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application startup. openapi_config class-attribute openapi_config : Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG parameters class-attribute parameters : ParametersMap A mapping of Parameter definitions available to all application paths. plugins class-attribute plugins : List [ PluginProtocol ] List of PluginProtocol . request_class class-attribute request_class : Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. response_class class-attribute response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. response_cookies class-attribute response_cookies : ResponseCookies A list of [Cookie](starlite.datastructures.Cookie] instances. response_headers class-attribute response_headers : ResponseHeadersMap A string keyed dictionary mapping ResponseHeader instances. route_handlers class-attribute route_handlers : List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. security class-attribute security : List [ SecurityRequirement ] A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details. static_files_config class-attribute static_files_config : SingleOrList [ StaticFilesConfig ] An instance or list of StaticFilesConfig . tags class-attribute tags : List [ str ] A list of string tags that will be appended to the schema of all route handlers under the application. template_config class-attribute template_config : Optional [ TemplateConfig ] An instance of TemplateConfig . websocket_class class-attribute websocket_class : Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections.","title":"App Config"},{"location":"reference/config/0-app-config/#app-config","text":"","title":"App Config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig","text":"Bases: BaseModel The parameters provided to the Starlite app are used to instantiate an instance, and then the instance is passed to any callbacks registered to on_app_init in the order they are provided. The final attribute values are used to instantiate the application object.","title":"AppConfig"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_exception","text":"after_exception : SingleOrList [ AfterExceptionHookHandler ] An application level exception hook handler or list thereof. This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).","title":"after_exception"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_request","text":"after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be either an instance of Response or starlette.Response .","title":"after_request"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_response","text":"after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.","title":"after_response"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_shutdown","text":"after_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.","title":"after_shutdown"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_startup","text":"after_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.","title":"after_startup"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.allowed_hosts","text":"allowed_hosts : List [ str ] A list of allowed hosts - enables the builtin allowed hosts middleware.","title":"allowed_hosts"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_request","text":"before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler.","title":"before_request"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_send","text":"before_send : SingleOrList [ BeforeMessageSendHookHandler ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called.","title":"before_send"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_shutdown","text":"before_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.","title":"before_shutdown"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_startup","text":"before_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.","title":"before_startup"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cache_config","text":"cache_config : CacheConfig Configures caching behavior of the application.","title":"cache_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cache_control","text":"cache_control : Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers.","title":"cache_control"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.compression_config","text":"compression_config : Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware.","title":"compression_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cors_config","text":"cors_config : Optional [ CORSConfig ] If set this enables the builtin CORS middleware.","title":"cors_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.csrf_config","text":"csrf_config : Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware.","title":"csrf_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.debug","text":"debug : bool If True , app errors rendered as HTML with a stack trace.","title":"debug"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.dependencies","text":"dependencies : Dict [ str , Provide ] A string keyed dictionary of dependency Provider instances.","title":"dependencies"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.exception_handlers","text":"exception_handlers : ExceptionHandlersMap A dictionary that maps handler functions to status codes and/or exception types.","title":"exception_handlers"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.guards","text":"guards : List [ Guard ] A list of Guard callables.","title":"guards"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.logging_config","text":"logging_config : Optional [ BaseLoggingConfig ] An instance of BaseLoggingConfig subclass.","title":"logging_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.middleware","text":"middleware : List [ Middleware ] A list of Middleware .","title":"middleware"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.on_shutdown","text":"on_shutdown : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application shutdown.","title":"on_shutdown"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.on_startup","text":"on_startup : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application startup.","title":"on_startup"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.openapi_config","text":"openapi_config : Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG","title":"openapi_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.parameters","text":"parameters : ParametersMap A mapping of Parameter definitions available to all application paths.","title":"parameters"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.plugins","text":"plugins : List [ PluginProtocol ] List of PluginProtocol .","title":"plugins"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.request_class","text":"request_class : Optional [ Type [ Request ]] An optional subclass of Request to use for http connections.","title":"request_class"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_class","text":"response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response.","title":"response_class"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_cookies","text":"response_cookies : ResponseCookies A list of [Cookie](starlite.datastructures.Cookie] instances.","title":"response_cookies"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_headers","text":"response_headers : ResponseHeadersMap A string keyed dictionary mapping ResponseHeader instances.","title":"response_headers"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.route_handlers","text":"route_handlers : List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators.","title":"route_handlers"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.security","text":"security : List [ SecurityRequirement ] A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details.","title":"security"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.static_files_config","text":"static_files_config : SingleOrList [ StaticFilesConfig ] An instance or list of StaticFilesConfig .","title":"static_files_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.tags","text":"tags : List [ str ] A list of string tags that will be appended to the schema of all route handlers under the application.","title":"tags"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.template_config","text":"template_config : Optional [ TemplateConfig ] An instance of TemplateConfig .","title":"template_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.websocket_class","text":"websocket_class : Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections.","title":"websocket_class"},{"location":"reference/config/1-cache-config/","text":"Cache Config starlite.config.cache.CacheConfig Bases: BaseModel Configuration for response caching. To enable response caching, pass an instance of this class to the Starlite constructor using the 'cache_config' key. backend class-attribute backend : Optional [ CacheBackendProtocol ] = None Instance conforming to CacheBackendProtocol , default SimpleCacheBackend() expiration class-attribute expiration : int = 60 Default cache expiration in seconds cache_key_builder class-attribute cache_key_builder : CacheKeyBuilder = default_cache_key_builder CacheKeyBuilder , default_cache_key_builder if not provided to_cache to_cache () Creates a cache wrapper from the config. Returns: Type Description Cache An instance of Cache starlite.config.cache.default_cache_key_builder starlite . config . cache . default_cache_key_builder ( request ) Given a request object, returns a cache key by combining the path with the sorted query params. Parameters: Name Type Description Default request Request request used to generate cache key. required Returns: Name Type Description str str combination of url path and query parameters","title":"Cache Config"},{"location":"reference/config/1-cache-config/#cache-config","text":"","title":"Cache Config"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig","text":"Bases: BaseModel Configuration for response caching. To enable response caching, pass an instance of this class to the Starlite constructor using the 'cache_config' key.","title":"CacheConfig"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.backend","text":"backend : Optional [ CacheBackendProtocol ] = None Instance conforming to CacheBackendProtocol , default SimpleCacheBackend()","title":"backend"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.expiration","text":"expiration : int = 60 Default cache expiration in seconds","title":"expiration"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.cache_key_builder","text":"cache_key_builder : CacheKeyBuilder = default_cache_key_builder CacheKeyBuilder , default_cache_key_builder if not provided","title":"cache_key_builder"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.to_cache","text":"to_cache () Creates a cache wrapper from the config. Returns: Type Description Cache An instance of Cache","title":"to_cache()"},{"location":"reference/config/1-cache-config/#starlite.config.cache.default_cache_key_builder","text":"starlite . config . cache . default_cache_key_builder ( request ) Given a request object, returns a cache key by combining the path with the sorted query params. Parameters: Name Type Description Default request Request request used to generate cache key. required Returns: Name Type Description str str combination of url path and query parameters","title":"default_cache_key_builder()"},{"location":"reference/config/2-cors-config/","text":"CORS Config starlite.config.cors.CORSConfig Bases: BaseModel Configuration for CORS (Cross-Origin Resource Sharing). To enable CORS, pass an instance of this class to the Starlite constructor using the 'cors_config' key. allow_origins class-attribute allow_origins : List [ str ] = [ '*' ] List of origins that are allowed. Can use ' ' in any component of the path, e.g. 'domain. '. Sets the 'Access-Control-Allow-Origin' header. allow_methods class-attribute allow_methods : List [ str ] = [ '*' ] List of allowed HTTP methods. Sets the 'Access-Control-Allow-Methods' header. allow_headers class-attribute allow_headers : List [ str ] = [ '*' ] List of allowed headers. Sets the 'Access-Control-Allow-Headers' header. allow_credentials class-attribute allow_credentials : bool = False Boolean dictating whether or not to set the 'Access-Control-Allow-Credentials' header. allow_origin_regex class-attribute allow_origin_regex : Optional [ str ] = None Regex to match origins against. expose_headers class-attribute expose_headers : List [ str ] = [] List of headers that are exposed via the 'Access-Control-Expose-Headers' header. max_age class-attribute max_age : int = 600 Response aching TTL in seconds, defaults to 600. Sets the 'Access-Control-Max-Age' header.","title":"CORS Config"},{"location":"reference/config/2-cors-config/#cors-config","text":"","title":"CORS Config"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig","text":"Bases: BaseModel Configuration for CORS (Cross-Origin Resource Sharing). To enable CORS, pass an instance of this class to the Starlite constructor using the 'cors_config' key.","title":"CORSConfig"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_origins","text":"allow_origins : List [ str ] = [ '*' ] List of origins that are allowed. Can use ' ' in any component of the path, e.g. 'domain. '. Sets the 'Access-Control-Allow-Origin' header.","title":"allow_origins"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_methods","text":"allow_methods : List [ str ] = [ '*' ] List of allowed HTTP methods. Sets the 'Access-Control-Allow-Methods' header.","title":"allow_methods"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_headers","text":"allow_headers : List [ str ] = [ '*' ] List of allowed headers. Sets the 'Access-Control-Allow-Headers' header.","title":"allow_headers"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_credentials","text":"allow_credentials : bool = False Boolean dictating whether or not to set the 'Access-Control-Allow-Credentials' header.","title":"allow_credentials"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_origin_regex","text":"allow_origin_regex : Optional [ str ] = None Regex to match origins against.","title":"allow_origin_regex"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.expose_headers","text":"expose_headers : List [ str ] = [] List of headers that are exposed via the 'Access-Control-Expose-Headers' header.","title":"expose_headers"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.max_age","text":"max_age : int = 600 Response aching TTL in seconds, defaults to 600. Sets the 'Access-Control-Max-Age' header.","title":"max_age"},{"location":"reference/config/3-csrf-config/","text":"CSRF Config starlite.config.csrf.CSRFConfig Bases: BaseModel Configuration for CSRF (Cross Site Request Forgery) protection. To enable CSRF protection, pass an instance of this class to the Starlite constructor using the 'csrf_config' key. secret class-attribute secret : str A string that is used to create an HMAC to sign the CSRF token cookie_name class-attribute cookie_name : str = 'csrftoken' The CSRF cookie name cookie_path class-attribute cookie_path : str = '/' The CSRF cookie path header_name class-attribute header_name : str = 'x-csrftoken' The header that will be expected in each request cookie_secure class-attribute cookie_secure : bool = False A boolean value indicating whether to set the Secure attribute on the cookie cookie_httponly class-attribute cookie_httponly : bool = False A boolean value indicating whether to set the HttpOnly attribute on the cookie cookie_samesite class-attribute cookie_samesite : Literal [ lax , strict , none ] = 'lax' The value to set in the SameSite attribute of the cookie cookie_domain class-attribute cookie_domain : Optional [ str ] = None Specifies which hosts can receive the cookie safe_methods class-attribute safe_methods : Set [ Method ] = { 'GET' , 'HEAD' } A set of \"safe methods\" that can set the cookie exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the CSRF middleware exclude_from_csrf_key class-attribute exclude_from_csrf_key : str = 'exclude_from_csrf' An identifier to use on routes to disable CSRF for a particular route","title":"CSRF Config"},{"location":"reference/config/3-csrf-config/#csrf-config","text":"","title":"CSRF Config"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig","text":"Bases: BaseModel Configuration for CSRF (Cross Site Request Forgery) protection. To enable CSRF protection, pass an instance of this class to the Starlite constructor using the 'csrf_config' key.","title":"CSRFConfig"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.secret","text":"secret : str A string that is used to create an HMAC to sign the CSRF token","title":"secret"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_name","text":"cookie_name : str = 'csrftoken' The CSRF cookie name","title":"cookie_name"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_path","text":"cookie_path : str = '/' The CSRF cookie path","title":"cookie_path"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.header_name","text":"header_name : str = 'x-csrftoken' The header that will be expected in each request","title":"header_name"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_secure","text":"cookie_secure : bool = False A boolean value indicating whether to set the Secure attribute on the cookie","title":"cookie_secure"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_httponly","text":"cookie_httponly : bool = False A boolean value indicating whether to set the HttpOnly attribute on the cookie","title":"cookie_httponly"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_samesite","text":"cookie_samesite : Literal [ lax , strict , none ] = 'lax' The value to set in the SameSite attribute of the cookie","title":"cookie_samesite"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_domain","text":"cookie_domain : Optional [ str ] = None Specifies which hosts can receive the cookie","title":"cookie_domain"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.safe_methods","text":"safe_methods : Set [ Method ] = { 'GET' , 'HEAD' } A set of \"safe methods\" that can set the cookie","title":"safe_methods"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the CSRF middleware","title":"exclude"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.exclude_from_csrf_key","text":"exclude_from_csrf_key : str = 'exclude_from_csrf' An identifier to use on routes to disable CSRF for a particular route","title":"exclude_from_csrf_key"},{"location":"reference/config/4-compression-config/","text":"Compression Config starlite.config.compression.CompressionConfig Bases: BaseModel Configuration for response compression. To enable response compression, pass an instance of this class to the Starlite constructor using the 'compression_config' key. backend class-attribute backend : Literal [ gzip , brotli ] Literal of \"gzip\" or \"brotli\" minimum_size class-attribute minimum_size : conint ( gt = 0 ) = 500 Minimum response size (bytes) to enable compression, affects all backends. gzip_compress_level class-attribute gzip_compress_level : conint ( ge = 0 , le = 9 ) = 9 Range [0-9], see official docs . brotli_quality class-attribute brotli_quality : conint ( ge = 0 , le = 11 ) = 5 Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression. brotli_mode class-attribute brotli_mode : Literal [ generic , text , font ] = 'text' MODE_GENERIC, MODE_TEXT (for UTF-8 format text input, default) or MODE_FONT (for WOFF 2.0). brotli_lgwin class-attribute brotli_lgwin : conint ( ge = 10 , le = 24 ) = 22 Base 2 logarithm of size. Range is 10 to 24. Defaults to 22. brotli_lgblock class-attribute brotli_lgblock : Literal [ 0 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] = 0 Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0. brotli_gzip_fallback class-attribute brotli_gzip_fallback : bool = True Use GZIP if Brotli not supported.","title":"Compression Config"},{"location":"reference/config/4-compression-config/#compression-config","text":"","title":"Compression Config"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig","text":"Bases: BaseModel Configuration for response compression. To enable response compression, pass an instance of this class to the Starlite constructor using the 'compression_config' key.","title":"CompressionConfig"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.backend","text":"backend : Literal [ gzip , brotli ] Literal of \"gzip\" or \"brotli\"","title":"backend"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.minimum_size","text":"minimum_size : conint ( gt = 0 ) = 500 Minimum response size (bytes) to enable compression, affects all backends.","title":"minimum_size"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.gzip_compress_level","text":"gzip_compress_level : conint ( ge = 0 , le = 9 ) = 9 Range [0-9], see official docs .","title":"gzip_compress_level"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_quality","text":"brotli_quality : conint ( ge = 0 , le = 11 ) = 5 Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression.","title":"brotli_quality"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_mode","text":"brotli_mode : Literal [ generic , text , font ] = 'text' MODE_GENERIC, MODE_TEXT (for UTF-8 format text input, default) or MODE_FONT (for WOFF 2.0).","title":"brotli_mode"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_lgwin","text":"brotli_lgwin : conint ( ge = 10 , le = 24 ) = 22 Base 2 logarithm of size. Range is 10 to 24. Defaults to 22.","title":"brotli_lgwin"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_lgblock","text":"brotli_lgblock : Literal [ 0 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] = 0 Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0.","title":"brotli_lgblock"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_gzip_fallback","text":"brotli_gzip_fallback : bool = True Use GZIP if Brotli not supported.","title":"brotli_gzip_fallback"},{"location":"reference/config/5-openapi-config/","text":"OpenAPI Config starlite.config.openapi.OpenAPIConfig Bases: BaseModel Configuration for OpenAPI. To enable OpenAPI schema generation and serving, pass an instance of this class to the Starlite constructor using the 'openapi_config' kwargs. contact class-attribute contact : Optional [ Contact ] = None API contact information, should be an Contact instance. create_examples class-attribute create_examples : bool = False Generate examples using the pydantic-factories library. description class-attribute description : Optional [ str ] = None API description. external_docs class-attribute external_docs : Optional [ ExternalDocumentation ] = None Links to external documentation. Should be an instance of ExternalDocumentation . license class-attribute license : Optional [ License ] = None API Licensing information. Should be an instance of License . openapi_controller class-attribute openapi_controller : Type [ OpenAPIController ] = OpenAPIController Controller for generating OpenAPI routes. Must be subclass of OpenAPIController . root_schema_site class-attribute root_schema_site : Literal [ redoc , swagger , elements ] = 'redoc' The static schema generator to use for the \"root\" path of /schema/ . security class-attribute security : Optional [ List [ SecurityRequirement ]] = None API Security requirements information. Should be an instance of SecurityRequirement . servers class-attribute servers : List [ Server ] = [ Server ( url = '/' )] A list of Server instances. summary class-attribute summary : Optional [ str ] = None A summary text. tags class-attribute tags : Optional [ List [ Tag ]] = None A list of Tag instances. terms_of_service class-attribute terms_of_service : Optional [ AnyUrl ] = None URL to page that contains terms of service. title class-attribute title : str Title of API documentation. use_handler_docstrings class-attribute use_handler_docstrings : bool = False Draw operation description from route handler docstring if not otherwise provided. version class-attribute version : str API version, e.g. '1.0.0'. webhooks class-attribute webhooks : Optional [ Dict [ str , Union [ PathItem , Reference ]]] = None A mapping of key to either PathItem or Reference objects. enabled_endpoints class-attribute enabled_endpoints : Set [ str ] = { 'redoc' , 'swagger' , 'elements' , 'openapi.json' , 'openapi.yaml' } A set of the enabled documentation sites and schema download endpoints.","title":"OpenAPI Config"},{"location":"reference/config/5-openapi-config/#openapi-config","text":"","title":"OpenAPI Config"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig","text":"Bases: BaseModel Configuration for OpenAPI. To enable OpenAPI schema generation and serving, pass an instance of this class to the Starlite constructor using the 'openapi_config' kwargs.","title":"OpenAPIConfig"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.contact","text":"contact : Optional [ Contact ] = None API contact information, should be an Contact instance.","title":"contact"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.create_examples","text":"create_examples : bool = False Generate examples using the pydantic-factories library.","title":"create_examples"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.description","text":"description : Optional [ str ] = None API description.","title":"description"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.external_docs","text":"external_docs : Optional [ ExternalDocumentation ] = None Links to external documentation. Should be an instance of ExternalDocumentation .","title":"external_docs"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.license","text":"license : Optional [ License ] = None API Licensing information. Should be an instance of License .","title":"license"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.openapi_controller","text":"openapi_controller : Type [ OpenAPIController ] = OpenAPIController Controller for generating OpenAPI routes. Must be subclass of OpenAPIController .","title":"openapi_controller"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.root_schema_site","text":"root_schema_site : Literal [ redoc , swagger , elements ] = 'redoc' The static schema generator to use for the \"root\" path of /schema/ .","title":"root_schema_site"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.security","text":"security : Optional [ List [ SecurityRequirement ]] = None API Security requirements information. Should be an instance of SecurityRequirement .","title":"security"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.servers","text":"servers : List [ Server ] = [ Server ( url = '/' )] A list of Server instances.","title":"servers"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.summary","text":"summary : Optional [ str ] = None A summary text.","title":"summary"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.tags","text":"tags : Optional [ List [ Tag ]] = None A list of Tag instances.","title":"tags"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.terms_of_service","text":"terms_of_service : Optional [ AnyUrl ] = None URL to page that contains terms of service.","title":"terms_of_service"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.title","text":"title : str Title of API documentation.","title":"title"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.use_handler_docstrings","text":"use_handler_docstrings : bool = False Draw operation description from route handler docstring if not otherwise provided.","title":"use_handler_docstrings"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.version","text":"version : str API version, e.g. '1.0.0'.","title":"version"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.webhooks","text":"webhooks : Optional [ Dict [ str , Union [ PathItem , Reference ]]] = None A mapping of key to either PathItem or Reference objects.","title":"webhooks"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.enabled_endpoints","text":"enabled_endpoints : Set [ str ] = { 'redoc' , 'swagger' , 'elements' , 'openapi.json' , 'openapi.yaml' } A set of the enabled documentation sites and schema download endpoints.","title":"enabled_endpoints"},{"location":"reference/config/6-static-files-config/","text":"Static-Files Config starlite.config.static_files.StaticFilesConfig Bases: BaseModel Configuration for static file service. To enable static files, pass an instance of this class to the Starlite constructor using the 'static_files_config' key. path class-attribute path : constr ( min_length = 1 ) Path to serve static files from. Note that the path cannot contain path parameters. directories class-attribute directories : List [ DirectoryPath ] A list of directories to serve files from. html_mode class-attribute html_mode : bool = False Flag dictating whether or not serving html. If true, the default file will be 'index.html'. name class-attribute name : Optional [ str ] = None An optional string identifying the static files handler.","title":"Static-Files Config"},{"location":"reference/config/6-static-files-config/#static-files-config","text":"","title":"Static-Files Config"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig","text":"Bases: BaseModel Configuration for static file service. To enable static files, pass an instance of this class to the Starlite constructor using the 'static_files_config' key.","title":"StaticFilesConfig"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.path","text":"path : constr ( min_length = 1 ) Path to serve static files from. Note that the path cannot contain path parameters.","title":"path"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.directories","text":"directories : List [ DirectoryPath ] A list of directories to serve files from.","title":"directories"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.html_mode","text":"html_mode : bool = False Flag dictating whether or not serving html. If true, the default file will be 'index.html'.","title":"html_mode"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.name","text":"name : Optional [ str ] = None An optional string identifying the static files handler.","title":"name"},{"location":"reference/config/7-template-config/","text":"Template Config starlite.config.template.TemplateConfig Bases: BaseModel Configuration for Templating. To enable templating, pass an instance of this class to the Starlite constructor using the 'template_config' key. directory class-attribute directory : Union [ DirectoryPath , List [ DirectoryPath ]] A directory or list of directories from which to serve templates. engine class-attribute engine : Type [ TemplateEngineProtocol ] A template engine adhering to the TemplateEngineProtocol . engine_callback class-attribute engine_callback : Optional [ Callable [[ Any ], None ]] = None A callback function that allows modifying the instantiated templating protocol. to_engine to_engine () Instantiates the template engine.","title":"Template Config"},{"location":"reference/config/7-template-config/#template-config","text":"","title":"Template Config"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig","text":"Bases: BaseModel Configuration for Templating. To enable templating, pass an instance of this class to the Starlite constructor using the 'template_config' key.","title":"TemplateConfig"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.directory","text":"directory : Union [ DirectoryPath , List [ DirectoryPath ]] A directory or list of directories from which to serve templates.","title":"directory"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine","text":"engine : Type [ TemplateEngineProtocol ] A template engine adhering to the TemplateEngineProtocol .","title":"engine"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine_callback","text":"engine_callback : Optional [ Callable [[ Any ], None ]] = None A callback function that allows modifying the instantiated templating protocol.","title":"engine_callback"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.to_engine","text":"to_engine () Instantiates the template engine.","title":"to_engine()"},{"location":"reference/config/8-logging-config/","text":"Logging Config starlite.config.logging.BaseLoggingConfig Bases: ABC Abstract class that should be extended by logging configs. configure abstractmethod configure () Configured logger with the given configuration. Returns: Type Description GetLogger A 'logging.getLogger' like function. starlite.config.logging.LoggingConfig Bases: BaseLoggingConfig , BaseModel Configuration class for standard logging. Notes If 'picologging' is installed it will be used by default. disable_existing_loggers class-attribute disable_existing_loggers : bool = False Whether any existing non-root loggers are to be disabled. filters class-attribute filters : Optional [ Dict [ str , Dict [ str , Any ]]] = None A dict in which each key is a filter id and each value is a dict describing how to configure the corresponding Filter instance. formatters class-attribute formatters : Dict [ str , Dict [ str , Any ]] = { \"standard\" : { \"format\" : \" %(levelname)s - %(asctime)s - %(name)s - %(module)s - %(message)s \" } } handlers class-attribute handlers : Dict [ str , Dict [ str , Any ]] = Field ( default_factory = get_default_handlers ) A dict in which each key is a handler id and each value is a dict describing how to configure the corresponding Handler instance. incremental class-attribute incremental : bool = False Whether the configuration is to be interpreted as incremental to the existing configuration. Notes This option is ignored for 'picologging' loggers class-attribute loggers : Dict [ str , Dict [ str , Any ]] = { \"starlite\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ]}} A dict in which each key is a logger name and each value is a dict describing how to configure the corresponding Logger instance. propagate class-attribute propagate : bool = True If messages must propagate to handlers higher up the logger hierarchy from this logger. root class-attribute root : Dict [ str , Union [ Dict [ str , Any ], List [ Any ], str ]] = { \"handlers\" : [ \"queue_listener\" ], \"level\" : \"INFO\" , } This will be the configuration for the root logger. Processing of the configuration will be as for any logger, except that the propagate setting will not be applicable. starlite.config.logging.StructLoggingConfig Bases: BaseLoggingConfig , BaseModel Configuration class for structlog. Notes requires 'structlog' to be installed. cache_logger_on_first_use class-attribute cache_logger_on_first_use : bool = True Whether to cache the logger configuration and reuse. context_class class-attribute context_class : Optional [ Dict [ str , Any ]] = None Context class (a 'contextvar' context) for the logger logger_factory class-attribute logger_factory : Optional [ Callable [ ... , WrappedLogger ]] = Field ( default_factory = default_logger_factory ) Logger factory to use. processors class-attribute processors : Optional [ Iterable [ Processor ]] = Field ( default_factory = default_structlog_processors ) Iterable of structlog logging processors. wrapper_class class-attribute wrapper_class : Optional [ Type [ BindableLogger ]] = Field ( default_factory = default_wrapper_class ) Structlog bindable logger.","title":"Logging Config"},{"location":"reference/config/8-logging-config/#logging-config","text":"","title":"Logging Config"},{"location":"reference/config/8-logging-config/#starlite.config.logging.BaseLoggingConfig","text":"Bases: ABC Abstract class that should be extended by logging configs.","title":"BaseLoggingConfig"},{"location":"reference/config/8-logging-config/#starlite.config.logging.BaseLoggingConfig.configure","text":"configure () Configured logger with the given configuration. Returns: Type Description GetLogger A 'logging.getLogger' like function.","title":"configure()"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig","text":"Bases: BaseLoggingConfig , BaseModel Configuration class for standard logging. Notes If 'picologging' is installed it will be used by default.","title":"LoggingConfig"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.disable_existing_loggers","text":"disable_existing_loggers : bool = False Whether any existing non-root loggers are to be disabled.","title":"disable_existing_loggers"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.filters","text":"filters : Optional [ Dict [ str , Dict [ str , Any ]]] = None A dict in which each key is a filter id and each value is a dict describing how to configure the corresponding Filter instance.","title":"filters"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.formatters","text":"formatters : Dict [ str , Dict [ str , Any ]] = { \"standard\" : { \"format\" : \" %(levelname)s - %(asctime)s - %(name)s - %(module)s - %(message)s \" } }","title":"formatters"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.handlers","text":"handlers : Dict [ str , Dict [ str , Any ]] = Field ( default_factory = get_default_handlers ) A dict in which each key is a handler id and each value is a dict describing how to configure the corresponding Handler instance.","title":"handlers"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.incremental","text":"incremental : bool = False Whether the configuration is to be interpreted as incremental to the existing configuration. Notes This option is ignored for 'picologging'","title":"incremental"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.loggers","text":"loggers : Dict [ str , Dict [ str , Any ]] = { \"starlite\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ]}} A dict in which each key is a logger name and each value is a dict describing how to configure the corresponding Logger instance.","title":"loggers"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.propagate","text":"propagate : bool = True If messages must propagate to handlers higher up the logger hierarchy from this logger.","title":"propagate"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.root","text":"root : Dict [ str , Union [ Dict [ str , Any ], List [ Any ], str ]] = { \"handlers\" : [ \"queue_listener\" ], \"level\" : \"INFO\" , } This will be the configuration for the root logger. Processing of the configuration will be as for any logger, except that the propagate setting will not be applicable.","title":"root"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig","text":"Bases: BaseLoggingConfig , BaseModel Configuration class for structlog. Notes requires 'structlog' to be installed.","title":"StructLoggingConfig"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.cache_logger_on_first_use","text":"cache_logger_on_first_use : bool = True Whether to cache the logger configuration and reuse.","title":"cache_logger_on_first_use"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.context_class","text":"context_class : Optional [ Dict [ str , Any ]] = None Context class (a 'contextvar' context) for the logger","title":"context_class"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.logger_factory","text":"logger_factory : Optional [ Callable [ ... , WrappedLogger ]] = Field ( default_factory = default_logger_factory ) Logger factory to use.","title":"logger_factory"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.processors","text":"processors : Optional [ Iterable [ Processor ]] = Field ( default_factory = default_structlog_processors ) Iterable of structlog logging processors.","title":"processors"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.wrapper_class","text":"wrapper_class : Optional [ Type [ BindableLogger ]] = Field ( default_factory = default_wrapper_class ) Structlog bindable logger.","title":"wrapper_class"},{"location":"reference/connection/0-asgi-connection/","text":"ASGI Connection starlite.connection.base.User module-attribute starlite . connection . base . User = TypeVar ( 'User' ) starlite.connection.base.Auth module-attribute starlite . connection . base . Auth = TypeVar ( 'Auth' ) starlite.connection.base.Handler module-attribute starlite . connection . base . Handler = TypeVar ( 'Handler' ) starlite.connection.base.ASGIConnection Bases: Generic [ Handler , User , Auth ] receive instance-attribute receive = receive scope instance-attribute scope = scope send instance-attribute send = send __init__ __init__ ( scope , receive = empty_receive , send = empty_send ) The base ASGI connection container. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send app property app () Returns: Type Description Starlite The Starlite application instance auth property auth () Allows access to auth data. Raises: Type Description ImproperlyConfiguredException If 'auth' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description Auth A type correlating to the generic variable Auth. base_url property base_url () Returns: Type Description URL A URL instance constructed from the request's scope, representing only the base part URL (host + domain + prefix) of the request. cache property cache () Returns: Type Description Cache A 'Cache' instance. clear_session clear_session () Helper method to remove the session from scope. If the Starlite SessionMiddleware is enabled, this will cause the session data to be cleared. Returns: Type Description None None. client property client () Returns: Type Description Optional [ Address ] A two tuple of the host name and port number. cookies property cookies () Returns: Type Description Dict [ str , str ] Returns any cookies stored in the header as a parsed dictionary. headers property headers () Returns: Type Description Headers A Headers instance with the request's scope[\"headers\"] value. logger property logger () Returns: Type Description Logger A 'Logger' instance. Raises: Type Description ImproperlyConfiguredException if 'log_config' has not been passed to the Starlite constructor. path_params property path_params () Returns: Type Description Dict [ str , Any ] A string keyed dictionary of path parameter values. query_params property query_params () Returns: Type Description Dict [ str , List [ str ]] A normalized dict of query parameters. Multiple values for the same key are returned as a list. route_handler property route_handler () Returns: Type Description Handler The target route handler instance. session property session () Returns: Type Description Dict [ str , Any ] A dictionary representing the session value - if existing. Raises: Type Description ImproperlyConfiguredException if session is not set in scope. set_session set_session ( value ) Helper method to set the session in scope. If the Starlite SessionMiddleware is enabled, the session will be added to the response as a cookie header. Parameters: Name Type Description Default value Union [ Dict [ str , Any ], BaseModel ] Dictionary or pydantic model instance for the session data. required Returns: Type Description None None. state property state () Returns: Type Description State A State instance constructed from the scope[\"state\"] value. url property url () Returns: Type Description URL A URL instance constructed from the request's scope. url_for url_for ( name , ** path_parameters ) Parameters: Name Type Description Default name str The 'name' of the request route handler. required **path_parameters Dict [ str , Any ] Values for path parameters in the route {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type. Returns: Type Description str A string representing the absolute url of the route handler. url_for_static_asset url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved absolute url to the asset. Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A string representing absolute url to the asset. user property user () Allows access to user data. Raises: Type Description ImproperlyConfiguredException If 'user' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description User A type correlating to the generic variable User.","title":"ASGI Connection"},{"location":"reference/connection/0-asgi-connection/#asgi-connection","text":"","title":"ASGI Connection"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.User","text":"starlite . connection . base . User = TypeVar ( 'User' )","title":"User"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.Auth","text":"starlite . connection . base . Auth = TypeVar ( 'Auth' )","title":"Auth"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.Handler","text":"starlite . connection . base . Handler = TypeVar ( 'Handler' )","title":"Handler"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection","text":"Bases: Generic [ Handler , User , Auth ]","title":"ASGIConnection"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.receive","text":"receive = receive","title":"receive"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.scope","text":"scope = scope","title":"scope"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.send","text":"send = send","title":"send"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.__init__","text":"__init__ ( scope , receive = empty_receive , send = empty_send ) The base ASGI connection container. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send","title":"__init__()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.app","text":"app () Returns: Type Description Starlite The Starlite application instance","title":"app()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.auth","text":"auth () Allows access to auth data. Raises: Type Description ImproperlyConfiguredException If 'auth' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description Auth A type correlating to the generic variable Auth.","title":"auth()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.base_url","text":"base_url () Returns: Type Description URL A URL instance constructed from the request's scope, representing only the base part URL (host + domain + prefix) of the request.","title":"base_url()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.cache","text":"cache () Returns: Type Description Cache A 'Cache' instance.","title":"cache()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.clear_session","text":"clear_session () Helper method to remove the session from scope. If the Starlite SessionMiddleware is enabled, this will cause the session data to be cleared. Returns: Type Description None None.","title":"clear_session()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.client","text":"client () Returns: Type Description Optional [ Address ] A two tuple of the host name and port number.","title":"client()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.cookies","text":"cookies () Returns: Type Description Dict [ str , str ] Returns any cookies stored in the header as a parsed dictionary.","title":"cookies()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.headers","text":"headers () Returns: Type Description Headers A Headers instance with the request's scope[\"headers\"] value.","title":"headers()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.logger","text":"logger () Returns: Type Description Logger A 'Logger' instance. Raises: Type Description ImproperlyConfiguredException if 'log_config' has not been passed to the Starlite constructor.","title":"logger()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.path_params","text":"path_params () Returns: Type Description Dict [ str , Any ] A string keyed dictionary of path parameter values.","title":"path_params()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.query_params","text":"query_params () Returns: Type Description Dict [ str , List [ str ]] A normalized dict of query parameters. Multiple values for the same key are returned as a list.","title":"query_params()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.route_handler","text":"route_handler () Returns: Type Description Handler The target route handler instance.","title":"route_handler()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.session","text":"session () Returns: Type Description Dict [ str , Any ] A dictionary representing the session value - if existing. Raises: Type Description ImproperlyConfiguredException if session is not set in scope.","title":"session()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.set_session","text":"set_session ( value ) Helper method to set the session in scope. If the Starlite SessionMiddleware is enabled, the session will be added to the response as a cookie header. Parameters: Name Type Description Default value Union [ Dict [ str , Any ], BaseModel ] Dictionary or pydantic model instance for the session data. required Returns: Type Description None None.","title":"set_session()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.state","text":"state () Returns: Type Description State A State instance constructed from the scope[\"state\"] value.","title":"state()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url","text":"url () Returns: Type Description URL A URL instance constructed from the request's scope.","title":"url()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url_for","text":"url_for ( name , ** path_parameters ) Parameters: Name Type Description Default name str The 'name' of the request route handler. required **path_parameters Dict [ str , Any ] Values for path parameters in the route {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type. Returns: Type Description str A string representing the absolute url of the route handler.","title":"url_for()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url_for_static_asset","text":"url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved absolute url to the asset. Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A string representing absolute url to the asset.","title":"url_for_static_asset()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.user","text":"user () Allows access to user data. Raises: Type Description ImproperlyConfiguredException If 'user' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description User A type correlating to the generic variable User.","title":"user()"},{"location":"reference/connection/1-request/","text":"Request starlite.connection.request.Request Bases: Generic [ User , Auth ] , ASGIConnection [ HTTPRouteHandler , User , Auth ] receive class-attribute receive : Receive The ASGI receive function. scope class-attribute scope : HTTPScope The ASGI scope attached to the connection. send class-attribute send : Send The ASGI send function. __init__ __init__ ( scope , receive = empty_receive , send = empty_send ) The Starlite Request class. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send body async body () Returns: Type Description bytes A byte-string representing the body of the request. content_type property content_type () Parses the request's 'Content-Type' header, returning the header value and any options as a dictionary. Returns: Type Description Tuple [ str , Dict [ str , str ]] A tuple with the parsed value and a dictionary containing any options send in it. form async form () Method to retrieve form data from the request. If the request is either a 'multipart/form-data' or an 'application/x-www-form- urlencoded', this method will return a FormMultiDict instance populated with the values sent in the request. Otherwise, an empty instance is returned. Returns: Type Description FormMultiDict A FormMultiDict instance. json async json () Method to retrieve the json request body from the request. This method overrides the Starlette method using the much faster orjson.loads() function Returns: Type Description Any An arbitrary value method property method () Returns: Type Description Method The request Method send_push_promise async send_push_promise ( path ) Sends a push promise. This method requires the 'http.response.push' extension to be sent from the ASGI server. Parameters: Name Type Description Default path str Path to send the promise to. required Returns: Type Description None None stream async stream () Returns an async generator that streams chunks of bytes. Returns: Type Description AsyncGenerator [ bytes , None] An async generator. Raises: Type Description RuntimeError if the stream is already consumed","title":"Request"},{"location":"reference/connection/1-request/#request","text":"","title":"Request"},{"location":"reference/connection/1-request/#starlite.connection.request.Request","text":"Bases: Generic [ User , Auth ] , ASGIConnection [ HTTPRouteHandler , User , Auth ]","title":"Request"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.receive","text":"receive : Receive The ASGI receive function.","title":"receive"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.scope","text":"scope : HTTPScope The ASGI scope attached to the connection.","title":"scope"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.send","text":"send : Send The ASGI send function.","title":"send"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.__init__","text":"__init__ ( scope , receive = empty_receive , send = empty_send ) The Starlite Request class. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send","title":"__init__()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.body","text":"body () Returns: Type Description bytes A byte-string representing the body of the request.","title":"body()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.content_type","text":"content_type () Parses the request's 'Content-Type' header, returning the header value and any options as a dictionary. Returns: Type Description Tuple [ str , Dict [ str , str ]] A tuple with the parsed value and a dictionary containing any options send in it.","title":"content_type()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.form","text":"form () Method to retrieve form data from the request. If the request is either a 'multipart/form-data' or an 'application/x-www-form- urlencoded', this method will return a FormMultiDict instance populated with the values sent in the request. Otherwise, an empty instance is returned. Returns: Type Description FormMultiDict A FormMultiDict instance.","title":"form()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.json","text":"json () Method to retrieve the json request body from the request. This method overrides the Starlette method using the much faster orjson.loads() function Returns: Type Description Any An arbitrary value","title":"json()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.method","text":"method () Returns: Type Description Method The request Method","title":"method()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.send_push_promise","text":"send_push_promise ( path ) Sends a push promise. This method requires the 'http.response.push' extension to be sent from the ASGI server. Parameters: Name Type Description Default path str Path to send the promise to. required Returns: Type Description None None","title":"send_push_promise()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.stream","text":"stream () Returns an async generator that streams chunks of bytes. Returns: Type Description AsyncGenerator [ bytes , None] An async generator. Raises: Type Description RuntimeError if the stream is already consumed","title":"stream()"},{"location":"reference/connection/2-websocket/","text":"WebSocket starlite.connection.websocket.WebSocket Bases: Generic [ User , Auth ] , ASGIConnection [ WebsocketRouteHandler , User , Auth ] receive class-attribute receive : Receive The ASGI receive function. scope class-attribute scope : WebSocketScope The ASGI scope attached to the connection. send class-attribute send : Send The ASGI send function. __init__ __init__ ( scope , receive = empty_receive , send = empty_send ) The Starlite WebSocket class. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send accept async accept ( subprotocols = None , headers = None ) Accepts the incoming connection. This method should be called before receiving data. Parameters: Name Type Description Default subprotocols Optional [ str ] Websocket sub-protocol to use. None headers Optional [ Union [ Headers , Dict [ str , Any ], List [ Tuple [ bytes , bytes ]]]] Headers to set on the data sent. None Returns: Type Description None None close async close ( code = WS_1000_NORMAL_CLOSURE , reason = None ) Sends an 'websocket.close' event. Parameters: Name Type Description Default code int Status code. WS_1000_NORMAL_CLOSURE reason Optional [ str ] Reason for closing the connection None Returns: Type Description None None receive_bytes async receive_bytes () Receives data as bytes. Returns: Type Description bytes A byte-string. receive_data async receive_data ( mode ) Receive an 'websocket.receive' event and returns the data stored on it. Parameters: Name Type Description Default mode Literal['binary', 'text'] The respective event key to use. required Returns: Type Description Union [ str , bytes ] The event's data. receive_json async receive_json ( mode = 'text' ) Receives data and loads it into JSON using orson. Parameters: Name Type Description Default mode Literal['text', 'binary'] Either 'text' or 'binary'. 'text' Returns: Type Description Any An arbitrary value receive_text async receive_text () Receives data as text. Returns: Type Description str A string. send_bytes async send_bytes ( data , encoding = 'utf-8' ) Sends data using the 'bytes' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None send_data async send_data ( data , mode = 'text' , encoding = 'utf-8' ) Sends a 'websocket.send' event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send. required mode Literal['text', 'binary'] The respective event key to use. 'text' encoding str Encoding to use when converting bytes / str. 'utf-8' Returns: Type Description None None send_json async send_json ( data , mode = 'text' , encoding = 'utf-8' , serializer = default_serializer ) Sends data as JSON. Parameters: Name Type Description Default data Any A value to serialize. required mode Literal['text', 'binary'] Either 'text' or 'binary'. 'text' encoding str Encoding to use for binary data. 'utf-8' serializer Serializer A serializer function. default_serializer Returns: Type Description None None send_text async send_text ( data , encoding = 'utf-8' ) Sends data using the 'text' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None","title":"WebSocket"},{"location":"reference/connection/2-websocket/#websocket","text":"","title":"WebSocket"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket","text":"Bases: Generic [ User , Auth ] , ASGIConnection [ WebsocketRouteHandler , User , Auth ]","title":"WebSocket"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive","text":"receive : Receive The ASGI receive function.","title":"receive"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.scope","text":"scope : WebSocketScope The ASGI scope attached to the connection.","title":"scope"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send","text":"send : Send The ASGI send function.","title":"send"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.__init__","text":"__init__ ( scope , receive = empty_receive , send = empty_send ) The Starlite WebSocket class. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send","title":"__init__()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.accept","text":"accept ( subprotocols = None , headers = None ) Accepts the incoming connection. This method should be called before receiving data. Parameters: Name Type Description Default subprotocols Optional [ str ] Websocket sub-protocol to use. None headers Optional [ Union [ Headers , Dict [ str , Any ], List [ Tuple [ bytes , bytes ]]]] Headers to set on the data sent. None Returns: Type Description None None","title":"accept()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.close","text":"close ( code = WS_1000_NORMAL_CLOSURE , reason = None ) Sends an 'websocket.close' event. Parameters: Name Type Description Default code int Status code. WS_1000_NORMAL_CLOSURE reason Optional [ str ] Reason for closing the connection None Returns: Type Description None None","title":"close()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_bytes","text":"receive_bytes () Receives data as bytes. Returns: Type Description bytes A byte-string.","title":"receive_bytes()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_data","text":"receive_data ( mode ) Receive an 'websocket.receive' event and returns the data stored on it. Parameters: Name Type Description Default mode Literal['binary', 'text'] The respective event key to use. required Returns: Type Description Union [ str , bytes ] The event's data.","title":"receive_data()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_json","text":"receive_json ( mode = 'text' ) Receives data and loads it into JSON using orson. Parameters: Name Type Description Default mode Literal['text', 'binary'] Either 'text' or 'binary'. 'text' Returns: Type Description Any An arbitrary value","title":"receive_json()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_text","text":"receive_text () Receives data as text. Returns: Type Description str A string.","title":"receive_text()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_bytes","text":"send_bytes ( data , encoding = 'utf-8' ) Sends data using the 'bytes' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None","title":"send_bytes()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_data","text":"send_data ( data , mode = 'text' , encoding = 'utf-8' ) Sends a 'websocket.send' event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send. required mode Literal['text', 'binary'] The respective event key to use. 'text' encoding str Encoding to use when converting bytes / str. 'utf-8' Returns: Type Description None None","title":"send_data()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_json","text":"send_json ( data , mode = 'text' , encoding = 'utf-8' , serializer = default_serializer ) Sends data as JSON. Parameters: Name Type Description Default data Any A value to serialize. required mode Literal['text', 'binary'] Either 'text' or 'binary'. 'text' encoding str Encoding to use for binary data. 'utf-8' serializer Serializer A serializer function. default_serializer Returns: Type Description None None","title":"send_json()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_text","text":"send_text ( data , encoding = 'utf-8' ) Sends data using the 'text' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None","title":"send_text()"},{"location":"reference/datastructures/0-state/","text":"State starlite.datastructures.State Bases: MutableMapping [ str , Any ] __init__ __init__ ( state = None ) An object meant to store arbitrary state. It can be accessed using dot notation while exposing dict like functionalities. Parameters: Name Type Description Default state Optional [ Dict [ str , Any ]] An optional string keyed dict for the initial state. None Examples: from starlite import State state_dict = { \"first\" : 1 , \"second\" : 2 , \"third\" : 3 , \"fourth\" : 4 } state = State ( state_dict ) # state can be accessed using '.' notation assert state . fourth == 4 del state . fourth # state implements the Mapping type: assert len ( state ) == 3 assert \"first\" in state assert not \"fourth\" in state assert state [ \"first\" ] == 1 assert [( k , v ) for k , v in state . items ()] == [( \"first\" , 1 ), ( \"second\" , 2 ), ( \"third\" , 3 )] state [ \"fourth\" ] = 4 assert \"fourth\" in state del state [ \"fourth\" ] # state implements __bool__ assert state # state is true when it has values. assert not State () # state is empty when it has no values. # it has shallow copy copied_state = state . copy () del copied_state . first assert state . first # it has a 'dict' method to retrieve a shallow copy of the underlying dict inner_dict = state . dict () assert inner_dict == state_dict copy copy () Returns: Type Description State A shallow copy of 'self'. dict dict () Returns: Type Description Dict [ str , Any ] A shallow copy of the wrapped dict.","title":"State"},{"location":"reference/datastructures/0-state/#state","text":"","title":"State"},{"location":"reference/datastructures/0-state/#starlite.datastructures.State","text":"Bases: MutableMapping [ str , Any ]","title":"State"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.__init__","text":"__init__ ( state = None ) An object meant to store arbitrary state. It can be accessed using dot notation while exposing dict like functionalities. Parameters: Name Type Description Default state Optional [ Dict [ str , Any ]] An optional string keyed dict for the initial state. None Examples: from starlite import State state_dict = { \"first\" : 1 , \"second\" : 2 , \"third\" : 3 , \"fourth\" : 4 } state = State ( state_dict ) # state can be accessed using '.' notation assert state . fourth == 4 del state . fourth # state implements the Mapping type: assert len ( state ) == 3 assert \"first\" in state assert not \"fourth\" in state assert state [ \"first\" ] == 1 assert [( k , v ) for k , v in state . items ()] == [( \"first\" , 1 ), ( \"second\" , 2 ), ( \"third\" , 3 )] state [ \"fourth\" ] = 4 assert \"fourth\" in state del state [ \"fourth\" ] # state implements __bool__ assert state # state is true when it has values. assert not State () # state is empty when it has no values. # it has shallow copy copied_state = state . copy () del copied_state . first assert state . first # it has a 'dict' method to retrieve a shallow copy of the underlying dict inner_dict = state . dict () assert inner_dict == state_dict","title":"__init__()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.copy","text":"copy () Returns: Type Description State A shallow copy of 'self'.","title":"copy()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.dict","text":"dict () Returns: Type Description Dict [ str , Any ] A shallow copy of the wrapped dict.","title":"dict()"},{"location":"reference/datastructures/1-cookie/","text":"Cookie starlite.datastructures.Cookie Bases: BaseModel Container class for defining a cookie using the 'Set-Cookie' header. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie for more details regarding this header. description class-attribute description : Optional [ str ] = None Description of the response cookie header for OpenAPI documentation documentation_only class-attribute documentation_only : bool = False Defines the Cookie instance as for OpenAPI documentation purpose only domain class-attribute domain : Optional [ str ] = None Domain for which the cookie is valid. expires class-attribute expires : Optional [ int ] = None Expiration date as unix MS timestamp. httponly class-attribute httponly : Optional [ bool ] = None Forbids javascript to access the cookie via 'Document.cookie'. key class-attribute key : str Key for the cookie. max_age class-attribute max_age : Optional [ int ] = None Maximal age of the cookie before its invalidated. path class-attribute path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. samesite class-attribute samesite : Literal [ lax , strict , none ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'. secure class-attribute secure : Optional [ bool ] = None Https is required for the cookie. value class-attribute value : Optional [ str ] = None Value for the cookie, if none given defaults to empty string. to_header to_header ( ** kwargs ) Return a string representation suitable to be sent as HTTP headers. Parameters: Name Type Description Default **kwargs Any Passed to SimpleCookie {}","title":"Cookie"},{"location":"reference/datastructures/1-cookie/#cookie","text":"","title":"Cookie"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.Cookie","text":"Bases: BaseModel Container class for defining a cookie using the 'Set-Cookie' header. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie for more details regarding this header.","title":"Cookie"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.description","text":"description : Optional [ str ] = None Description of the response cookie header for OpenAPI documentation","title":"description"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.documentation_only","text":"documentation_only : bool = False Defines the Cookie instance as for OpenAPI documentation purpose only","title":"documentation_only"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.domain","text":"domain : Optional [ str ] = None Domain for which the cookie is valid.","title":"domain"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.expires","text":"expires : Optional [ int ] = None Expiration date as unix MS timestamp.","title":"expires"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.httponly","text":"httponly : Optional [ bool ] = None Forbids javascript to access the cookie via 'Document.cookie'.","title":"httponly"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.key","text":"key : str Key for the cookie.","title":"key"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.max_age","text":"max_age : Optional [ int ] = None Maximal age of the cookie before its invalidated.","title":"max_age"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.path","text":"path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'.","title":"path"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.samesite","text":"samesite : Literal [ lax , strict , none ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'.","title":"samesite"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.secure","text":"secure : Optional [ bool ] = None Https is required for the cookie.","title":"secure"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.value","text":"value : Optional [ str ] = None Value for the cookie, if none given defaults to empty string.","title":"value"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.to_header","text":"to_header ( ** kwargs ) Return a string representation suitable to be sent as HTTP headers. Parameters: Name Type Description Default **kwargs Any Passed to SimpleCookie {}","title":"to_header()"},{"location":"reference/datastructures/2-provide/","text":"Provide starlite.datastructures.Provide","title":"Provide"},{"location":"reference/datastructures/2-provide/#provide","text":"","title":"Provide"},{"location":"reference/datastructures/2-provide/#starlite.datastructures.Provide","text":"","title":"Provide"},{"location":"reference/datastructures/3-header/","text":"Headers starlite.datastructures.ResponseHeader Bases: Header Container type for a response header. documentation_only class-attribute documentation_only : bool = False defines the ResponseHeader instance as for OpenAPI documentation purpose only value class-attribute value : Any = None value to set for the response header starlite.datastructures.headers.Header Bases: BaseModel , ABC An abstract type for HTTP headers. documentation_only class-attribute documentation_only : bool = False Defines the header instance as for OpenAPI documentation purpose only starlite.datastructures.CacheControlHeader Bases: Header A cache-control header. max_age class-attribute max_age : Optional [ int ] = None Accessor for the max-age directive. s_maxage class-attribute s_maxage : Optional [ int ] = None Accessor for the s-maxage directive. no_cache class-attribute no_cache : Optional [ bool ] = None Accessor for the no-cache directive. no_store class-attribute no_store : Optional [ bool ] = None Accessor for the no-store directive. private class-attribute private : Optional [ bool ] = None Accessor for the private directive. public class-attribute public : Optional [ bool ] = None Accessor for the public directive. no_transform class-attribute no_transform : Optional [ bool ] = None Accessor for the no-transform directive. must_revalidate class-attribute must_revalidate : Optional [ bool ] = None Accessor for the must-revalidate directive. proxy_revalidate class-attribute proxy_revalidate : Optional [ bool ] = None Accessor for the proxy-revalidate directive. must_understand class-attribute must_understand : Optional [ bool ] = None Accessor for the must-understand directive. immutable class-attribute immutable : Optional [ bool ] = None Accessor for the immutable directive. stale_while_revalidate class-attribute stale_while_revalidate : Optional [ int ] = None Accessor for the stale-while-revalidate directive. from_header classmethod from_header ( header_value ) Create a CacheControlHeader instance from the header value. Parameters: Name Type Description Default header_value str the header value as string required Returns: Type Description CacheControlHeader An instance of CacheControlHeader prevent_storing classmethod prevent_storing () Create a cache-control header with the no-store directive which indicates that any caches of any kind (private or shared) should not store this response.","title":"Headers"},{"location":"reference/datastructures/3-header/#headers","text":"","title":"Headers"},{"location":"reference/datastructures/3-header/#starlite.datastructures.ResponseHeader","text":"Bases: Header Container type for a response header.","title":"ResponseHeader"},{"location":"reference/datastructures/3-header/#starlite.datastructures.response_header.ResponseHeader.documentation_only","text":"documentation_only : bool = False defines the ResponseHeader instance as for OpenAPI documentation purpose only","title":"documentation_only"},{"location":"reference/datastructures/3-header/#starlite.datastructures.response_header.ResponseHeader.value","text":"value : Any = None value to set for the response header","title":"value"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.Header","text":"Bases: BaseModel , ABC An abstract type for HTTP headers.","title":"Header"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.Header.documentation_only","text":"documentation_only : bool = False Defines the header instance as for OpenAPI documentation purpose only","title":"documentation_only"},{"location":"reference/datastructures/3-header/#starlite.datastructures.CacheControlHeader","text":"Bases: Header A cache-control header.","title":"CacheControlHeader"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.max_age","text":"max_age : Optional [ int ] = None Accessor for the max-age directive.","title":"max_age"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.s_maxage","text":"s_maxage : Optional [ int ] = None Accessor for the s-maxage directive.","title":"s_maxage"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.no_cache","text":"no_cache : Optional [ bool ] = None Accessor for the no-cache directive.","title":"no_cache"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.no_store","text":"no_store : Optional [ bool ] = None Accessor for the no-store directive.","title":"no_store"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.private","text":"private : Optional [ bool ] = None Accessor for the private directive.","title":"private"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.public","text":"public : Optional [ bool ] = None Accessor for the public directive.","title":"public"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.no_transform","text":"no_transform : Optional [ bool ] = None Accessor for the no-transform directive.","title":"no_transform"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.must_revalidate","text":"must_revalidate : Optional [ bool ] = None Accessor for the must-revalidate directive.","title":"must_revalidate"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.proxy_revalidate","text":"proxy_revalidate : Optional [ bool ] = None Accessor for the proxy-revalidate directive.","title":"proxy_revalidate"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.must_understand","text":"must_understand : Optional [ bool ] = None Accessor for the must-understand directive.","title":"must_understand"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.immutable","text":"immutable : Optional [ bool ] = None Accessor for the immutable directive.","title":"immutable"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.stale_while_revalidate","text":"stale_while_revalidate : Optional [ int ] = None Accessor for the stale-while-revalidate directive.","title":"stale_while_revalidate"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.from_header","text":"from_header ( header_value ) Create a CacheControlHeader instance from the header value. Parameters: Name Type Description Default header_value str the header value as string required Returns: Type Description CacheControlHeader An instance of CacheControlHeader","title":"from_header()"},{"location":"reference/datastructures/3-header/#starlite.datastructures.headers.CacheControlHeader.prevent_storing","text":"prevent_storing () Create a cache-control header with the no-store directive which indicates that any caches of any kind (private or shared) should not store this response.","title":"prevent_storing()"},{"location":"reference/datastructures/4-background/","text":"Background starlite.datastructures.BackgroundTask Bases: StarletteBackgroundTask __init__ __init__ ( func , * args , ** kwargs ) A container for a 'background' task function. Background tasks are called once a Response finishes. Parameters: Name Type Description Default func Callable [ P , Any ] A sync or async function to call as the background task. required *args P . args Args to pass to the func. () **kwargs P . kwargs Kwargs to pass to the func {} starlite.datastructures.BackgroundTasks Bases: StarletteBackgroundTasks __init__ __init__ ( tasks ) A container for multiple 'background' task functions. Background tasks are called once a Response finishes. Parameters: Name Type Description Default tasks List [ BackgroundTask ] A list of BackgroundTask instances. required","title":"Background"},{"location":"reference/datastructures/4-background/#background","text":"","title":"Background"},{"location":"reference/datastructures/4-background/#starlite.datastructures.BackgroundTask","text":"Bases: StarletteBackgroundTask","title":"BackgroundTask"},{"location":"reference/datastructures/4-background/#starlite.datastructures.background_tasks.BackgroundTask.__init__","text":"__init__ ( func , * args , ** kwargs ) A container for a 'background' task function. Background tasks are called once a Response finishes. Parameters: Name Type Description Default func Callable [ P , Any ] A sync or async function to call as the background task. required *args P . args Args to pass to the func. () **kwargs P . kwargs Kwargs to pass to the func {}","title":"__init__()"},{"location":"reference/datastructures/4-background/#starlite.datastructures.BackgroundTasks","text":"Bases: StarletteBackgroundTasks","title":"BackgroundTasks"},{"location":"reference/datastructures/4-background/#starlite.datastructures.background_tasks.BackgroundTasks.__init__","text":"__init__ ( tasks ) A container for multiple 'background' task functions. Background tasks are called once a Response finishes. Parameters: Name Type Description Default tasks List [ BackgroundTask ] A list of BackgroundTask instances. required","title":"__init__()"},{"location":"reference/datastructures/5-response-containers/","text":"Response Containers starlite.datastructures.ResponseContainer Bases: GenericModel , ABC , Generic [ R ] background class-attribute background : Optional [ Union [ BackgroundTask , BackgroundTasks ]] = None A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. headers class-attribute headers : Dict [ str , Any ] = {} A string/string dictionary of response headers. Header keys are insensitive. Defaults to None. cookies class-attribute cookies : List [ Cookie ] = [] A list of Cookie instances to be set under the response 'Set-Cookie' header. Defaults to None. to_response abstractmethod to_response ( headers , media_type , status_code , app , request ) Abstract method that should be implemented by subclasses. Returns a Starlette compatible Response instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description R A Response Object starlite.datastructures.File Bases: ResponseContainer [ FileResponse ] Container type for returning File responses. path class-attribute path : FilePath Path to the file to send filename class-attribute filename : str The filename stat_result class-attribute stat_result : Optional [ os . stat_result ] = None File statistics to_response to_response ( headers , media_type , status_code , app , request ) Creates a FileResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description FileResponse A FileResponse instance starlite.datastructures.Redirect Bases: ResponseContainer [ RedirectResponse ] Container type for returning Redirect responses. path class-attribute path : str Redirection path to_response to_response ( headers , media_type , status_code , app , request ) Creates a RedirectResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description RedirectResponse A RedirectResponse instance starlite.datastructures.Stream Bases: ResponseContainer [ StreamingResponse ] Container type for returning Stream responses. iterator class-attribute iterator : Union [ Iterator [ Union [ str , bytes ]], Generator [ Union [ str , bytes ], Any , Any ], AsyncIterator [ Union [ str , bytes ]], AsyncGenerator [ Union [ str , bytes ], Any ], Type [ Iterator [ Union [ str , bytes ]]], Type [ AsyncIterator [ Union [ str , bytes ]]], Callable [[], AsyncGenerator [ Union [ str , bytes ], Any ]], Callable [[], Generator [ Union [ str , bytes ], Any , Any ]], ] Iterator, Generator or async Iterator or Generator returning stream chunks to_response to_response ( headers , media_type , status_code , app , request ) Creates a StreamingResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description StreamingResponse A StreamingResponse instance starlite.datastructures.Template Bases: ResponseContainer [ TemplateResponse ] Container type for returning Template responses. name class-attribute name : str Path-like name for the template to be rendered, e.g. \"index.html\". context class-attribute context : Dict [ str , Any ] = {} A dictionary of key/value pairs to be passed to the temple engine's render method. Defaults to None. to_response to_response ( headers , media_type , status_code , app , request ) Creates a TemplateResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] if app.template_engine is not configured. Returns: Type Description TemplateResponse A TemplateResponse instance","title":"Response Containers"},{"location":"reference/datastructures/5-response-containers/#response-containers","text":"","title":"Response Containers"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.ResponseContainer","text":"Bases: GenericModel , ABC , Generic [ R ]","title":"ResponseContainer"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.background","text":"background : Optional [ Union [ BackgroundTask , BackgroundTasks ]] = None A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.","title":"background"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.headers","text":"headers : Dict [ str , Any ] = {} A string/string dictionary of response headers. Header keys are insensitive. Defaults to None.","title":"headers"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.cookies","text":"cookies : List [ Cookie ] = [] A list of Cookie instances to be set under the response 'Set-Cookie' header. Defaults to None.","title":"cookies"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Abstract method that should be implemented by subclasses. Returns a Starlette compatible Response instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description R A Response Object","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.File","text":"Bases: ResponseContainer [ FileResponse ] Container type for returning File responses.","title":"File"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.path","text":"path : FilePath Path to the file to send","title":"path"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.filename","text":"filename : str The filename","title":"filename"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.stat_result","text":"stat_result : Optional [ os . stat_result ] = None File statistics","title":"stat_result"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Creates a FileResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description FileResponse A FileResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Redirect","text":"Bases: ResponseContainer [ RedirectResponse ] Container type for returning Redirect responses.","title":"Redirect"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Redirect.path","text":"path : str Redirection path","title":"path"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Redirect.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Creates a RedirectResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description RedirectResponse A RedirectResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Stream","text":"Bases: ResponseContainer [ StreamingResponse ] Container type for returning Stream responses.","title":"Stream"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Stream.iterator","text":"iterator : Union [ Iterator [ Union [ str , bytes ]], Generator [ Union [ str , bytes ], Any , Any ], AsyncIterator [ Union [ str , bytes ]], AsyncGenerator [ Union [ str , bytes ], Any ], Type [ Iterator [ Union [ str , bytes ]]], Type [ AsyncIterator [ Union [ str , bytes ]]], Callable [[], AsyncGenerator [ Union [ str , bytes ], Any ]], Callable [[], Generator [ Union [ str , bytes ], Any , Any ]], ] Iterator, Generator or async Iterator or Generator returning stream chunks","title":"iterator"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Stream.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Creates a StreamingResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description StreamingResponse A StreamingResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Template","text":"Bases: ResponseContainer [ TemplateResponse ] Container type for returning Template responses.","title":"Template"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.name","text":"name : str Path-like name for the template to be rendered, e.g. \"index.html\".","title":"name"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.context","text":"context : Dict [ str , Any ] = {} A dictionary of key/value pairs to be passed to the temple engine's render method. Defaults to None.","title":"context"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Creates a TemplateResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] if app.template_engine is not configured. Returns: Type Description TemplateResponse A TemplateResponse instance","title":"to_response()"},{"location":"reference/datastructures/6-upload-file/","text":"Upload File starlite.datastructures.UploadFile Bases: MultipartUploadFile","title":"Upload File"},{"location":"reference/datastructures/6-upload-file/#upload-file","text":"","title":"Upload File"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.UploadFile","text":"Bases: MultipartUploadFile","title":"UploadFile"},{"location":"reference/datastructures/7-form-multi-dict/","text":"Form Multi-Dict starlite.datastructures.FormMultiDict Bases: ImmutableMultiDict [ str , Any ] close async close () Closes all files in the multi-dict. Returns: Type Description None None","title":"Form Multi-Dict"},{"location":"reference/datastructures/7-form-multi-dict/#form-multi-dict","text":"","title":"Form Multi-Dict"},{"location":"reference/datastructures/7-form-multi-dict/#starlite.datastructures.FormMultiDict","text":"Bases: ImmutableMultiDict [ str , Any ]","title":"FormMultiDict"},{"location":"reference/datastructures/7-form-multi-dict/#starlite.datastructures.form_multi_dict.FormMultiDict.close","text":"close () Closes all files in the multi-dict. Returns: Type Description None None","title":"close()"},{"location":"reference/exceptions/0-base-exceptions/","text":"Base Exceptions starlite.exceptions.StarLiteException Bases: Exception __init__ __init__ ( * args , detail = '' ) Base exception class from which all Starlite exceptions inherit. Parameters: Name Type Description Default *args Any args are cast to str before passing to Exception.__init__() () detail str detail of the exception. '' starlite.exceptions.MissingDependencyException Bases: StarLiteException Missing optional dependency. This exception is raised only when a module depends on a dependency that has not been installed.","title":"Base Exceptions"},{"location":"reference/exceptions/0-base-exceptions/#base-exceptions","text":"","title":"Base Exceptions"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.StarLiteException","text":"Bases: Exception","title":"StarLiteException"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.base_exceptions.StarLiteException.__init__","text":"__init__ ( * args , detail = '' ) Base exception class from which all Starlite exceptions inherit. Parameters: Name Type Description Default *args Any args are cast to str before passing to Exception.__init__() () detail str detail of the exception. ''","title":"__init__()"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.MissingDependencyException","text":"Bases: StarLiteException Missing optional dependency. This exception is raised only when a module depends on a dependency that has not been installed.","title":"MissingDependencyException"},{"location":"reference/exceptions/1-http-exceptions/","text":"HTTP Exceptions starlite.exceptions.HTTPException Bases: StarletteHTTPException , StarLiteException detail instance-attribute detail = detail extra instance-attribute extra = extra headers instance-attribute headers = headers status_code class-attribute status_code : int = HTTP_500_INTERNAL_SERVER_ERROR Exception status code. __init__ __init__ ( * args , detail = '' , status_code = None , headers = None , extra = None ) Base exception for HTTP error responses. These exceptions carry information to construct an HTTP response. Parameters: Name Type Description Default *args Any if detail kwarg not provided, first arg should be error detail. () detail str Exception details or message. Will default to args[0] if not provided. '' status_code Optional [ int ] Exception HTTP status code. None headers Optional [ Dict [ str , str ]] Headers to set on the response. None extra Optional [ Union [ Dict [ str , Any ], List [ Any ]]] An extra mapping to attach to the exception. None starlite.exceptions.ImproperlyConfiguredException Bases: HTTPException , ValueError Application has improper configuration. starlite.exceptions.InternalServerException Bases: HTTPException Server encountered an unexpected condition that prevented it from fulfilling the request. status_code class-attribute status_code = HTTP_500_INTERNAL_SERVER_ERROR starlite.exceptions.MethodNotAllowedException Bases: HTTPException Server knows the request method, but the target resource doesn't support this method. status_code class-attribute status_code = HTTP_405_METHOD_NOT_ALLOWED starlite.exceptions.NotAuthorizedException Bases: HTTPException Request lacks valid authentication credentials for the requested resource. status_code class-attribute status_code = HTTP_401_UNAUTHORIZED starlite.exceptions.NoRouteMatchFoundException Bases: InternalServerException A route with the given name could not be found. starlite.exceptions.NotFoundException Bases: HTTPException , ValueError Cannot find the requested resource. status_code class-attribute status_code = HTTP_404_NOT_FOUND starlite.exceptions.PermissionDeniedException Bases: HTTPException Request understood, but not authorized. status_code class-attribute status_code = HTTP_403_FORBIDDEN starlite.exceptions.ServiceUnavailableException Bases: HTTPException Server is not ready to handle the request. starlite.exceptions.TemplateNotFoundException Bases: InternalServerException __init__ __init__ ( * args , template_name ) Referenced template could not be found. Parameters: Name Type Description Default *args Any Passed through to super().__init__() - should not include detail . () template_name str Name of template that could not be found. required starlite.exceptions.TooManyRequestsException Bases: HTTPException Request limits have been exceeded. status_code class-attribute status_code = HTTP_429_TOO_MANY_REQUESTS starlite.exceptions.ValidationException Bases: HTTPException , ValueError Client error. status_code class-attribute status_code = HTTP_400_BAD_REQUEST","title":"HTTP Exceptions"},{"location":"reference/exceptions/1-http-exceptions/#http-exceptions","text":"","title":"HTTP Exceptions"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.HTTPException","text":"Bases: StarletteHTTPException , StarLiteException","title":"HTTPException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.detail","text":"detail = detail","title":"detail"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.extra","text":"extra = extra","title":"extra"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.headers","text":"headers = headers","title":"headers"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.status_code","text":"status_code : int = HTTP_500_INTERNAL_SERVER_ERROR Exception status code.","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.__init__","text":"__init__ ( * args , detail = '' , status_code = None , headers = None , extra = None ) Base exception for HTTP error responses. These exceptions carry information to construct an HTTP response. Parameters: Name Type Description Default *args Any if detail kwarg not provided, first arg should be error detail. () detail str Exception details or message. Will default to args[0] if not provided. '' status_code Optional [ int ] Exception HTTP status code. None headers Optional [ Dict [ str , str ]] Headers to set on the response. None extra Optional [ Union [ Dict [ str , Any ], List [ Any ]]] An extra mapping to attach to the exception. None","title":"__init__()"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ImproperlyConfiguredException","text":"Bases: HTTPException , ValueError Application has improper configuration.","title":"ImproperlyConfiguredException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.InternalServerException","text":"Bases: HTTPException Server encountered an unexpected condition that prevented it from fulfilling the request.","title":"InternalServerException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.InternalServerException.status_code","text":"status_code = HTTP_500_INTERNAL_SERVER_ERROR","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.MethodNotAllowedException","text":"Bases: HTTPException Server knows the request method, but the target resource doesn't support this method.","title":"MethodNotAllowedException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.MethodNotAllowedException.status_code","text":"status_code = HTTP_405_METHOD_NOT_ALLOWED","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NotAuthorizedException","text":"Bases: HTTPException Request lacks valid authentication credentials for the requested resource.","title":"NotAuthorizedException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.NotAuthorizedException.status_code","text":"status_code = HTTP_401_UNAUTHORIZED","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NoRouteMatchFoundException","text":"Bases: InternalServerException A route with the given name could not be found.","title":"NoRouteMatchFoundException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NotFoundException","text":"Bases: HTTPException , ValueError Cannot find the requested resource.","title":"NotFoundException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.NotFoundException.status_code","text":"status_code = HTTP_404_NOT_FOUND","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.PermissionDeniedException","text":"Bases: HTTPException Request understood, but not authorized.","title":"PermissionDeniedException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.PermissionDeniedException.status_code","text":"status_code = HTTP_403_FORBIDDEN","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ServiceUnavailableException","text":"Bases: HTTPException Server is not ready to handle the request.","title":"ServiceUnavailableException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.TemplateNotFoundException","text":"Bases: InternalServerException","title":"TemplateNotFoundException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.TemplateNotFoundException.__init__","text":"__init__ ( * args , template_name ) Referenced template could not be found. Parameters: Name Type Description Default *args Any Passed through to super().__init__() - should not include detail . () template_name str Name of template that could not be found. required","title":"__init__()"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.TooManyRequestsException","text":"Bases: HTTPException Request limits have been exceeded.","title":"TooManyRequestsException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.TooManyRequestsException.status_code","text":"status_code = HTTP_429_TOO_MANY_REQUESTS","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ValidationException","text":"Bases: HTTPException , ValueError Client error.","title":"ValidationException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.ValidationException.status_code","text":"status_code = HTTP_400_BAD_REQUEST","title":"status_code"},{"location":"reference/exceptions/2-websocket-exceptions/","text":"WebSocket Exceptions starlite.exceptions.WebSocketException Bases: StarLiteException","title":"WebSocket Exceptions"},{"location":"reference/exceptions/2-websocket-exceptions/#websocket-exceptions","text":"","title":"WebSocket Exceptions"},{"location":"reference/exceptions/2-websocket-exceptions/#starlite.exceptions.WebSocketException","text":"Bases: StarLiteException","title":"WebSocketException"},{"location":"reference/handlers/0-http-handlers/","text":"HTTP Route Handler Decorators starlite.handlers.HTTPRouteHandler Bases: BaseRouteHandler [ HTTPRouteHandler ] __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , http_method , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) HTTP Route Decorator. Use this decorator to decorate an HTTP handler with multiple methods. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None http_method Union [ HttpMethod , Method , List [ Union [ HttpMethod , Method ]]] An http method string , a member of the enum HttpMethod or a list of these that correlates to the methods the route handler function should handle. required media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200' for mixed method or 'GET', 'PUT' and 'PATCH', '201' for 'POST' and '204' for 'DELETE'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.route module-attribute starlite . handlers . route = HTTPRouteHandler starlite.handlers.get Bases: HTTPRouteHandler __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) GET Route Decorator. Use this decorator to decorate an HTTP handler for GET requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.post Bases: HTTPRouteHandler __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) POST Route Decorator. Use this decorator to decorate an HTTP handler for POST requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '201' for 'POST'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.put Bases: HTTPRouteHandler __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) PUT Route Decorator. Use this decorator to decorate an HTTP handler for PUT requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.patch Bases: HTTPRouteHandler __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) PATCH Route Decorator. Use this decorator to decorate an HTTP handler for PATCH requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.delete Bases: HTTPRouteHandler __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) DELETE Route Decorator. Use this decorator to decorate an HTTP handler for DELETE requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '204'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"HTTP Route Handler Decorators"},{"location":"reference/handlers/0-http-handlers/#http-route-handler-decorators","text":"","title":"HTTP Route Handler Decorators"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.HTTPRouteHandler","text":"Bases: BaseRouteHandler [ HTTPRouteHandler ]","title":"HTTPRouteHandler"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.http.HTTPRouteHandler.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , http_method , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) HTTP Route Decorator. Use this decorator to decorate an HTTP handler with multiple methods. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None http_method Union [ HttpMethod , Method , List [ Union [ HttpMethod , Method ]]] An http method string , a member of the enum HttpMethod or a list of these that correlates to the methods the route handler function should handle. required media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200' for mixed method or 'GET', 'PUT' and 'PATCH', '201' for 'POST' and '204' for 'DELETE'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.route","text":"starlite . handlers . route = HTTPRouteHandler","title":"route"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.get","text":"Bases: HTTPRouteHandler","title":"get"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.http.get.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) GET Route Decorator. Use this decorator to decorate an HTTP handler for GET requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.post","text":"Bases: HTTPRouteHandler","title":"post"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.http.post.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) POST Route Decorator. Use this decorator to decorate an HTTP handler for POST requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '201' for 'POST'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.put","text":"Bases: HTTPRouteHandler","title":"put"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.http.put.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) PUT Route Decorator. Use this decorator to decorate an HTTP handler for PUT requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.patch","text":"Bases: HTTPRouteHandler","title":"patch"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.http.patch.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) PATCH Route Decorator. Use this decorator to decorate an HTTP handler for PATCH requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.delete","text":"Bases: HTTPRouteHandler","title":"delete"},{"location":"reference/handlers/0-http-handlers/#starlite.handlers.http.delete.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , exception_handlers = None , guards = None , media_type = MediaType . JSON , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) DELETE Route Decorator. Use this decorator to decorate an HTTP handler for DELETE requests. Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Union [ MediaType , str ] A member of the MediaType enum or a string with a valid IANA Media-Type. MediaType.JSON middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '204'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-websocket-handlers/","text":"WebSocket Route Handler Decorators starlite.handlers.WebsocketRouteHandler Bases: BaseRouteHandler [ WebsocketRouteHandler ] __init__ __init__ ( path = None , * , dependencies = None , exception_handlers = None , guards = None , middleware = None , name = None , opt = None , ** kwargs ) WebSocket Route Handler decorator. Use this decorator to decorate websocket handler functions. Parameters: Name Type Description Default dependencies Optional [ Dependencies ] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ]] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.websocket","title":"WebSocket Route Handler Decorators"},{"location":"reference/handlers/1-websocket-handlers/#websocket-route-handler-decorators","text":"","title":"WebSocket Route Handler Decorators"},{"location":"reference/handlers/1-websocket-handlers/#starlite.handlers.WebsocketRouteHandler","text":"Bases: BaseRouteHandler [ WebsocketRouteHandler ]","title":"WebsocketRouteHandler"},{"location":"reference/handlers/1-websocket-handlers/#starlite.handlers.websocket.WebsocketRouteHandler.__init__","text":"__init__ ( path = None , * , dependencies = None , exception_handlers = None , guards = None , middleware = None , name = None , opt = None , ** kwargs ) WebSocket Route Handler decorator. Use this decorator to decorate websocket handler functions. Parameters: Name Type Description Default dependencies Optional [ Dependencies ] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ]] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-websocket-handlers/#starlite.handlers.websocket","text":"","title":"websocket"},{"location":"reference/handlers/2-asgi-handlers/","text":"ASGI Route Handler Decorators starlite.handlers.ASGIRouteHandler Bases: BaseRouteHandler [ ASGIRouteHandler ] __init__ __init__ ( path = None , * , exception_handlers = None , guards = None , name = None , opt = None , ** kwargs ) ASGI Route Handler decorator. Use this decorator to decorate ASGI apps. Parameters: Name Type Description Default exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.asgi","title":"ASGI Route Handler Decorators"},{"location":"reference/handlers/2-asgi-handlers/#asgi-route-handler-decorators","text":"","title":"ASGI Route Handler Decorators"},{"location":"reference/handlers/2-asgi-handlers/#starlite.handlers.ASGIRouteHandler","text":"Bases: BaseRouteHandler [ ASGIRouteHandler ]","title":"ASGIRouteHandler"},{"location":"reference/handlers/2-asgi-handlers/#starlite.handlers.asgi.ASGIRouteHandler.__init__","text":"__init__ ( path = None , * , exception_handlers = None , guards = None , name = None , opt = None , ** kwargs ) ASGI Route Handler decorator. Use this decorator to decorate ASGI apps. Parameters: Name Type Description Default exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed Guards . None path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/2-asgi-handlers/#starlite.handlers.asgi","text":"","title":"asgi"},{"location":"reference/middleware/0-base/","text":"Middleware Base starlite.middleware.MiddlewareProtocol Bases: Protocol __call__ async __call__ ( scope , receive , send ) Executes the ASGI middleware. Called by the previous middleware in the stack if a response is not awaited prior. Upon completion, middleware should call the next ASGI handler and await it - or await a response created in its closure. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. required send Send The ASGI send function. required Returns: Type Description None None starlite.middleware.DefineMiddleware __init__ __init__ ( middleware , * args , ** kwargs ) This class is a container that allows passing args and *kwargs to Middleware class constructors and factory functions. Parameters: Name Type Description Default middleware Callable [..., ASGIApp ] A callable that returns an ASGIApp. required *args Any Positional arguments to pass to the callable. () **kwargs Any Key word arguments to pass to the callable. {} Notes The callable will be passed a kwarg app , which is the next ASGI app to call in the middleware stack. It therefore must define such a kwarg.","title":"Middleware Base"},{"location":"reference/middleware/0-base/#middleware-base","text":"","title":"Middleware Base"},{"location":"reference/middleware/0-base/#starlite.middleware.MiddlewareProtocol","text":"Bases: Protocol","title":"MiddlewareProtocol"},{"location":"reference/middleware/0-base/#starlite.middleware.base.MiddlewareProtocol.__call__","text":"__call__ ( scope , receive , send ) Executes the ASGI middleware. Called by the previous middleware in the stack if a response is not awaited prior. Upon completion, middleware should call the next ASGI handler and await it - or await a response created in its closure. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. required send Send The ASGI send function. required Returns: Type Description None None","title":"__call__()"},{"location":"reference/middleware/0-base/#starlite.middleware.DefineMiddleware","text":"","title":"DefineMiddleware"},{"location":"reference/middleware/0-base/#starlite.middleware.base.DefineMiddleware.__init__","text":"__init__ ( middleware , * args , ** kwargs ) This class is a container that allows passing args and *kwargs to Middleware class constructors and factory functions. Parameters: Name Type Description Default middleware Callable [..., ASGIApp ] A callable that returns an ASGIApp. required *args Any Positional arguments to pass to the callable. () **kwargs Any Key word arguments to pass to the callable. {} Notes The callable will be passed a kwarg app , which is the next ASGI app to call in the middleware stack. It therefore must define such a kwarg.","title":"__init__()"},{"location":"reference/middleware/1-authentication-middleware/","text":"Authentication Middleware starlite.middleware.AuthenticationResult Bases: BaseModel This pydantic model is a container for authentication data. user class-attribute user : Any The user model, this can be any value corresponding to a user of the API auth class-attribute auth : Any = None The auth value, this can for example be a JWT token. starlite.middleware.AbstractAuthenticationMiddleware Bases: ABC scopes class-attribute scopes = { ScopeType . HTTP , ScopeType . WEBSOCKET } Scopes supported by the middleware. __init__ __init__ ( app , exclude = None , exclude_from_auth_key = 'exclude_from_auth' ) This is an abstract AuthenticationMiddleware that allows users to create their own AuthenticationMiddleware by extending it and overriding the 'authenticate_request' method. Parameters: Name Type Description Default app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip in the authentication middleware. None exclude_from_auth_key str An identifier to use on routes to disable authentication for a particular route. 'exclude_from_auth' authenticate_request async abstractmethod authenticate_request ( connection ) This method must be overridden by subclasses. It receives the http connection and returns an instance of. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance. required Raises: Type Description NotAuthorizedException | PermissionDeniedException if authentication fails. Returns: Type Description AuthenticationResult An instance of AuthenticationResult .","title":"Authentication Middleware"},{"location":"reference/middleware/1-authentication-middleware/#authentication-middleware","text":"","title":"Authentication Middleware"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.AuthenticationResult","text":"Bases: BaseModel This pydantic model is a container for authentication data.","title":"AuthenticationResult"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AuthenticationResult.user","text":"user : Any The user model, this can be any value corresponding to a user of the API","title":"user"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AuthenticationResult.auth","text":"auth : Any = None The auth value, this can for example be a JWT token.","title":"auth"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.AbstractAuthenticationMiddleware","text":"Bases: ABC","title":"AbstractAuthenticationMiddleware"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.scopes","text":"scopes = { ScopeType . HTTP , ScopeType . WEBSOCKET } Scopes supported by the middleware.","title":"scopes"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.__init__","text":"__init__ ( app , exclude = None , exclude_from_auth_key = 'exclude_from_auth' ) This is an abstract AuthenticationMiddleware that allows users to create their own AuthenticationMiddleware by extending it and overriding the 'authenticate_request' method. Parameters: Name Type Description Default app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip in the authentication middleware. None exclude_from_auth_key str An identifier to use on routes to disable authentication for a particular route. 'exclude_from_auth'","title":"__init__()"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.authenticate_request","text":"authenticate_request ( connection ) This method must be overridden by subclasses. It receives the http connection and returns an instance of. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance. required Raises: Type Description NotAuthorizedException | PermissionDeniedException if authentication fails. Returns: Type Description AuthenticationResult An instance of AuthenticationResult .","title":"authenticate_request()"},{"location":"reference/middleware/2-logging-middleware/","text":"Logging Middleware starlite.middleware.logging.LoggingMiddlewareConfig Bases: BaseModel exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None List of paths to exclude from logging. logger_name class-attribute logger_name : str = 'starlite' Name of the logger to retrieve using app.get_logger(\"<name>\") . middleware_class class-attribute middleware_class : Type [ LoggingMiddleware ] = LoggingMiddleware Middleware class to use. Should be a subclass of [starlite.middleware.LoggingMiddleware]. request_cookies_to_obfuscate class-attribute request_cookies_to_obfuscate : Set [ str ] = { 'session' } Request cookie keys to obfuscate. Obfuscated values are replaced with ' * '. request_headers_to_obfuscate class-attribute request_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Request header keys to obfuscate. Obfuscated values are replaced with ' * '. request_log_fields class-attribute request_log_fields : Iterable [ RequestExtractorField ] = ( \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , ) Fields to extract and log from the request. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of requests, use and empty iterable. request_log_message class-attribute request_log_message : str = 'HTTP Request' Log message to prepend when logging a request. response_cookies_to_obfuscate class-attribute response_cookies_to_obfuscate : Set [ str ] = { 'session' } Response cookie keys to obfuscate. Obfuscated values are replaced with ' * '. response_headers_to_obfuscate class-attribute response_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Response header keys to obfuscate. Obfuscated values are replaced with ' * '. response_log_fields class-attribute response_log_fields : Iterable [ ResponseExtractorField ] = ( \"status_code\" , \"cookies\" , \"headers\" , \"body\" , ) Fields to extract and log from the response. The order of fields in the iterable determines the order of the log message logged out. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of responses, use and empty iterable. response_log_message class-attribute response_log_message : str = 'HTTP Response' Log message to prepend when logging a response. middleware property middleware () Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , LoggingConfig , get from starlite.middleware.logging import LoggingMiddlewareConfig logging_config = LoggingConfig () logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], logging_config = logging_config , middleware = [ logging_middleware_config . middleware ], ) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. starlite.middleware.logging.LoggingMiddleware Bases: MiddlewareProtocol __init__ __init__ ( app , config ) LoggingMiddleware. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config LoggingMiddlewareConfig An instance of LoggingMiddlewareConfig. required create_send_wrapper create_send_wrapper ( scope , send ) Creates a 'send' wrapper, which handles logging response data. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required send Send The ASGI send function. required Returns: Type Description Send An ASGI send function. extract_request_data async extract_request_data ( request ) Creates a dictionary of values for the message. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Dict [ str , Any ] An OrderedDict. extract_response_data extract_response_data ( scope ) Extracts data from the response. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Dict [ str , Any ] An OrderedDict. log_message log_message ( values ) Parameters: Name Type Description Default values Dict [ str , Any ] Extract values to log. required Returns: Type Description None None log_request async log_request ( scope ) Handles extracting the request data and logging the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description None None log_response log_response ( scope ) Handles extracting the response data and logging the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description None None","title":"Logging Middleware"},{"location":"reference/middleware/2-logging-middleware/#logging-middleware","text":"","title":"Logging Middleware"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig","text":"Bases: BaseModel","title":"LoggingMiddlewareConfig"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None List of paths to exclude from logging.","title":"exclude"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.logger_name","text":"logger_name : str = 'starlite' Name of the logger to retrieve using app.get_logger(\"<name>\") .","title":"logger_name"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.middleware_class","text":"middleware_class : Type [ LoggingMiddleware ] = LoggingMiddleware Middleware class to use. Should be a subclass of [starlite.middleware.LoggingMiddleware].","title":"middleware_class"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_cookies_to_obfuscate","text":"request_cookies_to_obfuscate : Set [ str ] = { 'session' } Request cookie keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"request_cookies_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_headers_to_obfuscate","text":"request_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Request header keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"request_headers_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_log_fields","text":"request_log_fields : Iterable [ RequestExtractorField ] = ( \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , ) Fields to extract and log from the request. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of requests, use and empty iterable.","title":"request_log_fields"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_log_message","text":"request_log_message : str = 'HTTP Request' Log message to prepend when logging a request.","title":"request_log_message"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_cookies_to_obfuscate","text":"response_cookies_to_obfuscate : Set [ str ] = { 'session' } Response cookie keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"response_cookies_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_headers_to_obfuscate","text":"response_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Response header keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"response_headers_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_log_fields","text":"response_log_fields : Iterable [ ResponseExtractorField ] = ( \"status_code\" , \"cookies\" , \"headers\" , \"body\" , ) Fields to extract and log from the response. The order of fields in the iterable determines the order of the log message logged out. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of responses, use and empty iterable.","title":"response_log_fields"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_log_message","text":"response_log_message : str = 'HTTP Response' Log message to prepend when logging a response.","title":"response_log_message"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.middleware","text":"middleware () Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , LoggingConfig , get from starlite.middleware.logging import LoggingMiddlewareConfig logging_config = LoggingConfig () logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], logging_config = logging_config , middleware = [ logging_middleware_config . middleware ], ) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware","text":"Bases: MiddlewareProtocol","title":"LoggingMiddleware"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.__init__","text":"__init__ ( app , config ) LoggingMiddleware. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config LoggingMiddlewareConfig An instance of LoggingMiddlewareConfig. required","title":"__init__()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.create_send_wrapper","text":"create_send_wrapper ( scope , send ) Creates a 'send' wrapper, which handles logging response data. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required send Send The ASGI send function. required Returns: Type Description Send An ASGI send function.","title":"create_send_wrapper()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.extract_request_data","text":"extract_request_data ( request ) Creates a dictionary of values for the message. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Dict [ str , Any ] An OrderedDict.","title":"extract_request_data()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.extract_response_data","text":"extract_response_data ( scope ) Extracts data from the response. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Dict [ str , Any ] An OrderedDict.","title":"extract_response_data()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_message","text":"log_message ( values ) Parameters: Name Type Description Default values Dict [ str , Any ] Extract values to log. required Returns: Type Description None None","title":"log_message()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_request","text":"log_request ( scope ) Handles extracting the request data and logging the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description None None","title":"log_request()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_response","text":"log_response ( scope ) Handles extracting the response data and logging the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description None None","title":"log_response()"},{"location":"reference/middleware/3-rate-limit-middleware/","text":"Rate-Limit Middleware starlite.middleware.rate_limit.RateLimitConfig Bases: BaseModel cache_key_builder class-attribute cache_key_builder : Optional [ Callable [[ Request ], str ]] = None check_throttle_handler class-attribute check_throttle_handler : Optional [ Callable [[ Request [ Any , Any ]], SyncOrAsyncUnion [ bool ]]] = None Handler callable that receives the request instance, returning a boolean dictating whether or not the request should be checked for rate limiting. exclude class-attribute exclude : Optional [ List [ str ]] = None List of patterns to skip in the authentication middleware. middleware_class class-attribute middleware_class : Type [ RateLimitMiddleware ] = RateLimitMiddleware The middleware class to use. rate_limit class-attribute rate_limit : Tuple [ DurationUnit , int ] A tuple containing a time unit (second, minute, hour, day) and quantity, e.g. (\"day\", 1) or (\"minute\", 5). rate_limit_limit_header_key class-attribute rate_limit_limit_header_key : str = 'RateLimit-Limit' Key to use for the rate limit limit header. rate_limit_policy_header_key class-attribute rate_limit_policy_header_key : str = 'RateLimit-Policy' Key to use for the rate limit policy header. rate_limit_remaining_header_key class-attribute rate_limit_remaining_header_key : str = 'RateLimit-Remaining' Key to use for the rate limit remaining header. rate_limit_reset_header_key class-attribute rate_limit_reset_header_key : str = 'RateLimit-Reset' Key to use for the rate limit reset header. set_rate_limit_headers class-attribute set_rate_limit_headers : bool = True Boolean dictating whether to set the rate limit headers on the response. middleware property middleware () Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , get from starlite.middleware import RateLimitConfig # limit to 10 requests per minute, excluding the schema path throttle_config = RateLimitConfig ( rate_limit = ( \"minute\" , 10 ), exclude = [ \"/schema\" ]) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ throttle_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. starlite.middleware.rate_limit.RateLimitMiddleware __init__ __init__ ( app , config ) Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config RateLimitConfig An instance of RateLimitConfig. required cache_key_from_request cache_key_from_request ( request ) Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description str A cache key. create_response_headers create_response_headers ( cache_object ) Creates ratelimit response headers. Notes see the [IETF RateLimit draft][https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/] Parameters: Name Type Description Default cache_object CacheObject An instance of Cache Object. required Returns: Type Description Dict [ str , str ] A dict of http headers. retrieve_cached_history async retrieve_cached_history ( key ) Retrieves a list of time stamps for the given duration unit. Parameters: Name Type Description Default key str Cache key. required Returns: Type Description CacheObject An instance of CacheObject. set_cached_history async set_cached_history ( key , cache_object ) Stores history extended with the current timestamp in cache. Parameters: Name Type Description Default key str Cache key. required cache_object CacheObject An instance of CacheObject. required Returns: Type Description None None should_check_request async should_check_request ( request ) Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description bool Boolean dictating whether the request should be checked for rate-limiting.","title":"Rate-Limit Middleware"},{"location":"reference/middleware/3-rate-limit-middleware/#rate-limit-middleware","text":"","title":"Rate-Limit Middleware"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig","text":"Bases: BaseModel","title":"RateLimitConfig"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.cache_key_builder","text":"cache_key_builder : Optional [ Callable [[ Request ], str ]] = None","title":"cache_key_builder"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.check_throttle_handler","text":"check_throttle_handler : Optional [ Callable [[ Request [ Any , Any ]], SyncOrAsyncUnion [ bool ]]] = None Handler callable that receives the request instance, returning a boolean dictating whether or not the request should be checked for rate limiting.","title":"check_throttle_handler"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.exclude","text":"exclude : Optional [ List [ str ]] = None List of patterns to skip in the authentication middleware.","title":"exclude"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.middleware_class","text":"middleware_class : Type [ RateLimitMiddleware ] = RateLimitMiddleware The middleware class to use.","title":"middleware_class"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit","text":"rate_limit : Tuple [ DurationUnit , int ] A tuple containing a time unit (second, minute, hour, day) and quantity, e.g. (\"day\", 1) or (\"minute\", 5).","title":"rate_limit"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_limit_header_key","text":"rate_limit_limit_header_key : str = 'RateLimit-Limit' Key to use for the rate limit limit header.","title":"rate_limit_limit_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_policy_header_key","text":"rate_limit_policy_header_key : str = 'RateLimit-Policy' Key to use for the rate limit policy header.","title":"rate_limit_policy_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_remaining_header_key","text":"rate_limit_remaining_header_key : str = 'RateLimit-Remaining' Key to use for the rate limit remaining header.","title":"rate_limit_remaining_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_reset_header_key","text":"rate_limit_reset_header_key : str = 'RateLimit-Reset' Key to use for the rate limit reset header.","title":"rate_limit_reset_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.set_rate_limit_headers","text":"set_rate_limit_headers : bool = True Boolean dictating whether to set the rate limit headers on the response.","title":"set_rate_limit_headers"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.middleware","text":"middleware () Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , get from starlite.middleware import RateLimitConfig # limit to 10 requests per minute, excluding the schema path throttle_config = RateLimitConfig ( rate_limit = ( \"minute\" , 10 ), exclude = [ \"/schema\" ]) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ throttle_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware","text":"","title":"RateLimitMiddleware"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.__init__","text":"__init__ ( app , config ) Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config RateLimitConfig An instance of RateLimitConfig. required","title":"__init__()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.cache_key_from_request","text":"cache_key_from_request ( request ) Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description str A cache key.","title":"cache_key_from_request()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.create_response_headers","text":"create_response_headers ( cache_object ) Creates ratelimit response headers. Notes see the [IETF RateLimit draft][https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/] Parameters: Name Type Description Default cache_object CacheObject An instance of Cache Object. required Returns: Type Description Dict [ str , str ] A dict of http headers.","title":"create_response_headers()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.retrieve_cached_history","text":"retrieve_cached_history ( key ) Retrieves a list of time stamps for the given duration unit. Parameters: Name Type Description Default key str Cache key. required Returns: Type Description CacheObject An instance of CacheObject.","title":"retrieve_cached_history()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.set_cached_history","text":"set_cached_history ( key , cache_object ) Stores history extended with the current timestamp in cache. Parameters: Name Type Description Default key str Cache key. required cache_object CacheObject An instance of CacheObject. required Returns: Type Description None None","title":"set_cached_history()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.should_check_request","text":"should_check_request ( request ) Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description bool Boolean dictating whether the request should be checked for rate-limiting.","title":"should_check_request()"},{"location":"reference/middleware/4-session-middleware/","text":"Session Middleware starlite.middleware.session.SessionCookieConfig Bases: BaseModel Configuration for Session middleware. domain class-attribute domain : Optional [ str ] = None Domain for which the cookie is valid. httponly class-attribute httponly : bool = True Forbids javascript to access the cookie via 'Document.cookie'. key class-attribute key : constr ( min_length = 1 , max_length = 256 ) = 'session' Key to use for the cookie inside the header, e.g. session=<data> where 'session' is the cookie key and is the session data. Notes If a session cookie exceeds 4KB in size it is split. In this case the key will be of the format 'session-{segment number}'. max_age class-attribute max_age : conint ( ge = 1 ) = ONE_DAY_IN_SECONDS * 14 Maximal age of the cookie before its invalidated. path class-attribute path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. samesite class-attribute samesite : Literal [ lax , strict , none ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'. scopes class-attribute scopes : conlist ( Literal [ http , websocket ], min_items = 1 , max_items = 2 ) = [ 'http' , 'websocket' ] Scopes for the middleware - options are 'http' and 'websocket' with the default being both secret class-attribute secret : SecretBytes A secret key to use for generating an encryption key. Must have a length of 16 (128 bits), 24 (192 bits) or 32 (256 bits) characters. secure class-attribute secure : bool = False Https is required for the cookie. middleware property middleware () Use this property to insert the config into a middleware list on one of the application layers. Examples: from os import urandom from starlite import Starlite , Request , get from starlite.middleware.session import SessionCookieConfig session_config = SessionCookieConfig ( secret = urandom ( 16 )) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ session_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. starlite.middleware.session.SessionMiddleware Bases: MiddlewareProtocol __init__ __init__ ( app , config ) Starlite SessionMiddleware. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config SessionCookieConfig SessionCookieConfig instance. required dump_data dump_data ( data , scope = None ) Given orjson serializable data, including pydantic models and numpy types, dump it into a bytes string, encrypt, encode and split it into chunks of the desirable size. Parameters: Name Type Description Default data Any Data to serialize, encrypt, encode and chunk. required scope Optional [ Scope ] The ASGI connection scope. None Notes The returned list is composed of a chunks of a single base64 encoded string that is encrypted using AES-CGM. Returns: Type Description List [ bytes ] List of encoded bytes string of a maximum length equal to the 'CHUNK_SIZE' constant. load_data load_data ( data ) Given a list of strings, decodes them into the session object. Parameters: Name Type Description Default data List [ bytes ] A list of strings derived from the request's session cookie(s). required Returns: Type Description Dict [ str , Any ] A deserialized session value.","title":"Session Middleware"},{"location":"reference/middleware/4-session-middleware/#session-middleware","text":"","title":"Session Middleware"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig","text":"Bases: BaseModel Configuration for Session middleware.","title":"SessionCookieConfig"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.domain","text":"domain : Optional [ str ] = None Domain for which the cookie is valid.","title":"domain"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.httponly","text":"httponly : bool = True Forbids javascript to access the cookie via 'Document.cookie'.","title":"httponly"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.key","text":"key : constr ( min_length = 1 , max_length = 256 ) = 'session' Key to use for the cookie inside the header, e.g. session=<data> where 'session' is the cookie key and is the session data. Notes If a session cookie exceeds 4KB in size it is split. In this case the key will be of the format 'session-{segment number}'.","title":"key"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.max_age","text":"max_age : conint ( ge = 1 ) = ONE_DAY_IN_SECONDS * 14 Maximal age of the cookie before its invalidated.","title":"max_age"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.path","text":"path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'.","title":"path"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.samesite","text":"samesite : Literal [ lax , strict , none ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'.","title":"samesite"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.scopes","text":"scopes : conlist ( Literal [ http , websocket ], min_items = 1 , max_items = 2 ) = [ 'http' , 'websocket' ] Scopes for the middleware - options are 'http' and 'websocket' with the default being both","title":"scopes"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.secret","text":"secret : SecretBytes A secret key to use for generating an encryption key. Must have a length of 16 (128 bits), 24 (192 bits) or 32 (256 bits) characters.","title":"secret"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.secure","text":"secure : bool = False Https is required for the cookie.","title":"secure"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionCookieConfig.middleware","text":"middleware () Use this property to insert the config into a middleware list on one of the application layers. Examples: from os import urandom from starlite import Starlite , Request , get from starlite.middleware.session import SessionCookieConfig session_config = SessionCookieConfig ( secret = urandom ( 16 )) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ session_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware()"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionMiddleware","text":"Bases: MiddlewareProtocol","title":"SessionMiddleware"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionMiddleware.__init__","text":"__init__ ( app , config ) Starlite SessionMiddleware. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config SessionCookieConfig SessionCookieConfig instance. required","title":"__init__()"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionMiddleware.dump_data","text":"dump_data ( data , scope = None ) Given orjson serializable data, including pydantic models and numpy types, dump it into a bytes string, encrypt, encode and split it into chunks of the desirable size. Parameters: Name Type Description Default data Any Data to serialize, encrypt, encode and chunk. required scope Optional [ Scope ] The ASGI connection scope. None Notes The returned list is composed of a chunks of a single base64 encoded string that is encrypted using AES-CGM. Returns: Type Description List [ bytes ] List of encoded bytes string of a maximum length equal to the 'CHUNK_SIZE' constant.","title":"dump_data()"},{"location":"reference/middleware/4-session-middleware/#starlite.middleware.session.SessionMiddleware.load_data","text":"load_data ( data ) Given a list of strings, decodes them into the session object. Parameters: Name Type Description Default data List [ bytes ] A list of strings derived from the request's session cookie(s). required Returns: Type Description Dict [ str , Any ] A deserialized session value.","title":"load_data()"},{"location":"reference/middleware/5-compression-middleware/","text":"Compression Middleware starlite.middleware.CompressionMiddleware Bases: MiddlewareProtocol __init__ __init__ ( app , config ) Compression Middleware Wrapper. This is a wrapper allowing for generic compression configuration / handler middleware Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CompressionConfig An instance of CompressionConfig. required starlite.middleware.compression.brotli.BrotliMode module-attribute starlite . middleware . compression . brotli . BrotliMode = Literal [ 'text' , 'generic' , 'font' ] starlite.middleware.compression.brotli.CompressionEncoding Bases: str , Enum An Enum for supported compression encodings. GZIP class-attribute GZIP = 'gzip' BROTLI class-attribute BROTLI = 'br' starlite.middleware.compression.brotli.BrotliMiddleware Bases: MiddlewareProtocol __init__ __init__ ( app , minimum_size = 400 , brotli_quality = 4 , brotli_mode = \"text\" , brotli_lgwin = 22 , brotli_lgblock = 0 , brotli_gzip_fallback = True , ) Brotli middleware for Starlite. Compresses responses using Brotli and optional fallback to Gzip. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required minimum_size int Minimum size for the response body to affect compression. 400 brotli_quality int Controls the compression-speed vs compression-density tradeoffs. The higher the quality, the slower the compression. The range of this value is 0 to 11. 4 brotli_mode BrotliMode The encoder mode. 'text' brotli_lgwin int The base-2 logarithm of the sliding window size. The range of this value is 10 to 24. 22 brotli_lgblock int The base-2 logarithm of the maximum input block size. The range of this value is 16 to 24. If set to 0, the value will be set based on quality. 0 brotli_gzip_fallback bool Allow falling back to GZIP. True starlite.middleware.compression.gzip.GZipMiddleware Bases: StarletteGzipMiddleware __init__ __init__ ( app , minimum_size = 400 , gzip_compress_level = 9 ) GZIP Compression middleware for Starlite. This is a wrapper around the Starlette GZipMiddleware. It converts the Starlite parameters into the expected Gzip parameters. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required minimum_size int Minimum size for the response body to affect compression. 400 gzip_compress_level int The gzip compression level, value is in range from 1 to 9. 9","title":"Compression Middleware"},{"location":"reference/middleware/5-compression-middleware/#compression-middleware","text":"","title":"Compression Middleware"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.CompressionMiddleware","text":"Bases: MiddlewareProtocol","title":"CompressionMiddleware"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.base.CompressionMiddleware.__init__","text":"__init__ ( app , config ) Compression Middleware Wrapper. This is a wrapper allowing for generic compression configuration / handler middleware Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CompressionConfig An instance of CompressionConfig. required","title":"__init__()"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.brotli.BrotliMode","text":"starlite . middleware . compression . brotli . BrotliMode = Literal [ 'text' , 'generic' , 'font' ]","title":"BrotliMode"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.brotli.CompressionEncoding","text":"Bases: str , Enum An Enum for supported compression encodings.","title":"CompressionEncoding"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.brotli.CompressionEncoding.GZIP","text":"GZIP = 'gzip'","title":"GZIP"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.brotli.CompressionEncoding.BROTLI","text":"BROTLI = 'br'","title":"BROTLI"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.brotli.BrotliMiddleware","text":"Bases: MiddlewareProtocol","title":"BrotliMiddleware"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.brotli.BrotliMiddleware.__init__","text":"__init__ ( app , minimum_size = 400 , brotli_quality = 4 , brotli_mode = \"text\" , brotli_lgwin = 22 , brotli_lgblock = 0 , brotli_gzip_fallback = True , ) Brotli middleware for Starlite. Compresses responses using Brotli and optional fallback to Gzip. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required minimum_size int Minimum size for the response body to affect compression. 400 brotli_quality int Controls the compression-speed vs compression-density tradeoffs. The higher the quality, the slower the compression. The range of this value is 0 to 11. 4 brotli_mode BrotliMode The encoder mode. 'text' brotli_lgwin int The base-2 logarithm of the sliding window size. The range of this value is 10 to 24. 22 brotli_lgblock int The base-2 logarithm of the maximum input block size. The range of this value is 16 to 24. If set to 0, the value will be set based on quality. 0 brotli_gzip_fallback bool Allow falling back to GZIP. True","title":"__init__()"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.gzip.GZipMiddleware","text":"Bases: StarletteGzipMiddleware","title":"GZipMiddleware"},{"location":"reference/middleware/5-compression-middleware/#starlite.middleware.compression.gzip.GZipMiddleware.__init__","text":"__init__ ( app , minimum_size = 400 , gzip_compress_level = 9 ) GZIP Compression middleware for Starlite. This is a wrapper around the Starlette GZipMiddleware. It converts the Starlite parameters into the expected Gzip parameters. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required minimum_size int Minimum size for the response body to affect compression. 400 gzip_compress_level int The gzip compression level, value is in range from 1 to 9. 9","title":"__init__()"},{"location":"reference/middleware/6-csrf-middleware/","text":"CSRF Middleware starlite.middleware.CSRFMiddleware Bases: MiddlewareProtocol __init__ __init__ ( app , config ) CSRF Middleware class. This Middleware protects against attacks by setting a CSRF cookie with a token and verifying it in request headers. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CSRFConfig The CSRFConfig instance. required","title":"CSRF Middleware"},{"location":"reference/middleware/6-csrf-middleware/#csrf-middleware","text":"","title":"CSRF Middleware"},{"location":"reference/middleware/6-csrf-middleware/#starlite.middleware.CSRFMiddleware","text":"Bases: MiddlewareProtocol","title":"CSRFMiddleware"},{"location":"reference/middleware/6-csrf-middleware/#starlite.middleware.csrf.CSRFMiddleware.__init__","text":"__init__ ( app , config ) CSRF Middleware class. This Middleware protects against attacks by setting a CSRF cookie with a token and verifying it in request headers. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CSRFConfig The CSRFConfig instance. required","title":"__init__()"},{"location":"reference/middleware/7-exceptions-middleware/","text":"Exceptions Middleware starlite.middleware.ExceptionHandlerMiddleware __init__ __init__ ( app , debug , exception_handlers ) This middleware is used to wrap an ASGIApp inside a try catch block and handles any exceptions raised. Notes It's used in multiple layers of Starlite. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required debug bool Whether 'debug' mode is enabled required exception_handlers ExceptionHandlersMap A dictionary mapping status codes and/or exception types to handler functions. required default_http_exception_handler default_http_exception_handler ( request , exc ) Default handler for exceptions subclassed from HTTPException.","title":"Exceptions Middleware"},{"location":"reference/middleware/7-exceptions-middleware/#exceptions-middleware","text":"","title":"Exceptions Middleware"},{"location":"reference/middleware/7-exceptions-middleware/#starlite.middleware.ExceptionHandlerMiddleware","text":"","title":"ExceptionHandlerMiddleware"},{"location":"reference/middleware/7-exceptions-middleware/#starlite.middleware.exceptions.ExceptionHandlerMiddleware.__init__","text":"__init__ ( app , debug , exception_handlers ) This middleware is used to wrap an ASGIApp inside a try catch block and handles any exceptions raised. Notes It's used in multiple layers of Starlite. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required debug bool Whether 'debug' mode is enabled required exception_handlers ExceptionHandlersMap A dictionary mapping status codes and/or exception types to handler functions. required","title":"__init__()"},{"location":"reference/middleware/7-exceptions-middleware/#starlite.middleware.exceptions.ExceptionHandlerMiddleware.default_http_exception_handler","text":"default_http_exception_handler ( request , exc ) Default handler for exceptions subclassed from HTTPException.","title":"default_http_exception_handler()"},{"location":"reference/openapi/0-openapi-controller/","text":"OpenAPI Controller starlite.openapi.controller.OpenAPIController Bases: Controller Controller for OpenAPI endpoints. favicon_url class-attribute favicon_url : str = '' URL to download a favicon from. path class-attribute path : str = '/schema' Base path for the OpenAPI documentation endpoints. redoc_version class-attribute redoc_version : str = 'next' Redoc version to download from the CDN. redoc_google_fonts class-attribute redoc_google_fonts : bool = True Download google fonts via CDN. Should be set to False when not using a CDN. redoc_js_url class-attribute redoc_js_url : str = ( f \"https://cdn.jsdelivr.net/npm/redoc@ { redoc_version } /bundles/redoc.standalone.js\" ) Download url for the Redoc JS bundle. stoplight_elements_version class-attribute stoplight_elements_version : str = '7.6.5' StopLight Elements version to download from the CDN. stoplight_elements_css_url class-attribute stoplight_elements_css_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /styles.min.css\" ) Download url for the Stoplight Elements CSS bundle. stoplight_elements_js_url class-attribute stoplight_elements_js_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /web-components.min.js\" ) Download url for the Stoplight Elements JS bundle. style class-attribute style : str = 'body { margin: 0; padding: 0 }' Base styling of the html body. swagger_ui_version class-attribute swagger_ui_version : str = '4.14.0' SwaggerUI version to download from the CDN. swagger_css_url class-attribute swagger_css_url : str = ( f \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@ { swagger_ui_version } /swagger-ui.css\" ) Download url for the Swagger UI CSS bundle. favicon property favicon () Returns: Type Description str A link tag if self.favicon_url is not empty, otherwise returns a placeholder meta tag. redoc redoc ( request ) Route handler responsible for rendering Redoc. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered redoc documentation site render_404_page render_404_page () This method renders an HTML 404 page. Returns: Type Description str A rendered html string. render_methods_map property render_methods_map () Returns: Type Description Dict [ Literal['redoc', 'swagger', 'elements'] , Callable [[ Request ], str ]] A mapping of string keys to render methods. render_redoc render_redoc ( request ) This method renders an HTML page for Redoc. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string. render_stoplight_elements render_stoplight_elements ( request ) This method renders an HTML page for StopLight Elements. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string. render_swagger_ui render_swagger_ui ( request ) This method renders an HTML page for Swagger-UI. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string. retrieve_schema_json retrieve_schema_json ( request ) Returns the OpenAPI schema as JSON with an 'application/vnd.oai.openapi+json' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the JSON object rendered into a string. retrieve_schema_yaml retrieve_schema_yaml ( request ) Returns the OpenAPI schema as YAML with an 'application/vnd.oai.openapi' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the YAML object rendered into a string. root root ( request ) The root route handler. Renders a static site based on the 'root_schema_site' value set in the application's. OpenAPIConfig . Defaults to 'redoc'. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with the rendered site defined in root_schema_site. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None . should_serve_endpoint should_serve_endpoint ( request ) This method verifies that the requested path is within the enabled endpoints in the openapi_config. Parameters: Name Type Description Default request Request To be tested if endpoint enabled. required Returns: Type Description bool A boolean. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None . stoplight_elements stoplight_elements ( request ) Route handler responsible for rendering StopLight Elements. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered stoplight elements documentation site swagger_ui swagger_ui ( request ) Route handler responsible for rendering Swagger-UI. Parameters: Name Type Description Default request Request A Request instance. required Returns: Name Type Description response Response With a rendered swagger documentation site","title":"OpenAPI Controller"},{"location":"reference/openapi/0-openapi-controller/#openapi-controller","text":"","title":"OpenAPI Controller"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController","text":"Bases: Controller Controller for OpenAPI endpoints.","title":"OpenAPIController"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.favicon_url","text":"favicon_url : str = '' URL to download a favicon from.","title":"favicon_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.path","text":"path : str = '/schema' Base path for the OpenAPI documentation endpoints.","title":"path"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_version","text":"redoc_version : str = 'next' Redoc version to download from the CDN.","title":"redoc_version"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_google_fonts","text":"redoc_google_fonts : bool = True Download google fonts via CDN. Should be set to False when not using a CDN.","title":"redoc_google_fonts"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_js_url","text":"redoc_js_url : str = ( f \"https://cdn.jsdelivr.net/npm/redoc@ { redoc_version } /bundles/redoc.standalone.js\" ) Download url for the Redoc JS bundle.","title":"redoc_js_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_version","text":"stoplight_elements_version : str = '7.6.5' StopLight Elements version to download from the CDN.","title":"stoplight_elements_version"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_css_url","text":"stoplight_elements_css_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /styles.min.css\" ) Download url for the Stoplight Elements CSS bundle.","title":"stoplight_elements_css_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_js_url","text":"stoplight_elements_js_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /web-components.min.js\" ) Download url for the Stoplight Elements JS bundle.","title":"stoplight_elements_js_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.style","text":"style : str = 'body { margin: 0; padding: 0 }' Base styling of the html body.","title":"style"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_ui_version","text":"swagger_ui_version : str = '4.14.0' SwaggerUI version to download from the CDN.","title":"swagger_ui_version"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_css_url","text":"swagger_css_url : str = ( f \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@ { swagger_ui_version } /swagger-ui.css\" ) Download url for the Swagger UI CSS bundle.","title":"swagger_css_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.favicon","text":"favicon () Returns: Type Description str A link tag if self.favicon_url is not empty, otherwise returns a placeholder meta tag.","title":"favicon()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc","text":"redoc ( request ) Route handler responsible for rendering Redoc. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered redoc documentation site","title":"redoc()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_404_page","text":"render_404_page () This method renders an HTML 404 page. Returns: Type Description str A rendered html string.","title":"render_404_page()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_methods_map","text":"render_methods_map () Returns: Type Description Dict [ Literal['redoc', 'swagger', 'elements'] , Callable [[ Request ], str ]] A mapping of string keys to render methods.","title":"render_methods_map()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_redoc","text":"render_redoc ( request ) This method renders an HTML page for Redoc. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string.","title":"render_redoc()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_stoplight_elements","text":"render_stoplight_elements ( request ) This method renders an HTML page for StopLight Elements. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string.","title":"render_stoplight_elements()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_swagger_ui","text":"render_swagger_ui ( request ) This method renders an HTML page for Swagger-UI. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string.","title":"render_swagger_ui()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.retrieve_schema_json","text":"retrieve_schema_json ( request ) Returns the OpenAPI schema as JSON with an 'application/vnd.oai.openapi+json' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the JSON object rendered into a string.","title":"retrieve_schema_json()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.retrieve_schema_yaml","text":"retrieve_schema_yaml ( request ) Returns the OpenAPI schema as YAML with an 'application/vnd.oai.openapi' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the YAML object rendered into a string.","title":"retrieve_schema_yaml()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.root","text":"root ( request ) The root route handler. Renders a static site based on the 'root_schema_site' value set in the application's. OpenAPIConfig . Defaults to 'redoc'. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with the rendered site defined in root_schema_site. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None .","title":"root()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.should_serve_endpoint","text":"should_serve_endpoint ( request ) This method verifies that the requested path is within the enabled endpoints in the openapi_config. Parameters: Name Type Description Default request Request To be tested if endpoint enabled. required Returns: Type Description bool A boolean. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None .","title":"should_serve_endpoint()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements","text":"stoplight_elements ( request ) Route handler responsible for rendering StopLight Elements. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered stoplight elements documentation site","title":"stoplight_elements()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_ui","text":"swagger_ui ( request ) Route handler responsible for rendering Swagger-UI. Parameters: Name Type Description Default request Request A Request instance. required Returns: Name Type Description response Response With a rendered swagger documentation site","title":"swagger_ui()"},{"location":"reference/openapi/1-openapi-response-spec/","text":"OpenAPI Response Spec starlite.openapi.datastructures.ResponseSpec Bases: BaseModel Container type of additional responses. model class-attribute model : Type [ BaseModel ] A model that describes the content of the response generate_examples class-attribute generate_examples : bool = True Generate examples for the response content description class-attribute description : str = 'Additional response' A description of the response media_type class-attribute media_type : MediaType = MediaType . JSON Response media type","title":"OpenAPI Response Spec"},{"location":"reference/openapi/1-openapi-response-spec/#openapi-response-spec","text":"","title":"OpenAPI Response Spec"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec","text":"Bases: BaseModel Container type of additional responses.","title":"ResponseSpec"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.model","text":"model : Type [ BaseModel ] A model that describes the content of the response","title":"model"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.generate_examples","text":"generate_examples : bool = True Generate examples for the response content","title":"generate_examples"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.description","text":"description : str = 'Additional response' A description of the response","title":"description"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.media_type","text":"media_type : MediaType = MediaType . JSON Response media type","title":"media_type"},{"location":"reference/params/0-parameter/","text":"Parameter starlite . params . Parameter ( value_type = Undefined , * , header = None , cookie = None , query = None , examples = None , external_docs = None , content_encoding = None , required = True , default = Undefined , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None ) Creates a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default value_type Any Undefined by default. Undefined header Optional [ str ] The header parameter key - required for header parameters. None cookie Optional [ str ] The cookie parameter key - required for cookie parameters. None query Optional [ str ] The query parameter key for this parameter. None examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None required bool A boolean flag dictating whether this parameter is required. If set to False, None values will be allowed. Defaults to True. True default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Parameter"},{"location":"reference/params/0-parameter/#parameter","text":"","title":"Parameter"},{"location":"reference/params/0-parameter/#starlite.params.Parameter","text":"Creates a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default value_type Any Undefined by default. Undefined header Optional [ str ] The header parameter key - required for header parameters. None cookie Optional [ str ] The cookie parameter key - required for cookie parameters. None query Optional [ str ] The query parameter key for this parameter. None examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None required bool A boolean flag dictating whether this parameter is required. If set to False, None values will be allowed. Defaults to True. True default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Parameter()"},{"location":"reference/params/1-body/","text":"Body starlite . params . Body ( * , media_type = RequestEncodingType . JSON , examples = None , external_docs = None , content_encoding = None , default = Undefined , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None ) Creates a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default media_type Union [ str , RequestEncodingType ] Defaults to RequestEncodingType.JSON. RequestEncodingType.JSON examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Body"},{"location":"reference/params/1-body/#body","text":"","title":"Body"},{"location":"reference/params/1-body/#starlite.params.Body","text":"Creates a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default media_type Union [ str , RequestEncodingType ] Defaults to RequestEncodingType.JSON. RequestEncodingType.JSON examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Body()"},{"location":"reference/params/2-dependency/","text":"Dependency starlite . params . Dependency ( * , default = Undefined , skip_validation = False ) Creates a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default default Any default value if dependency not provided. Undefined skip_validation bool If True provided dependency values are not validated by signature model. False","title":"Dependency"},{"location":"reference/params/2-dependency/#dependency","text":"","title":"Dependency"},{"location":"reference/params/2-dependency/#starlite.params.Dependency","text":"Creates a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default default Any default value if dependency not provided. Undefined skip_validation bool If True provided dependency values are not validated by signature model. False","title":"Dependency()"},{"location":"reference/plugins/0-plugin-protocol/","text":"Plugin Protocol starlite.plugins.base.PluginProtocol Bases: Protocol [ ModelT ] on_app_init on_app_init ( app ) Receives the Starlite application instance before init is finalized and allows the plugin to update various attributes. Examples: from starlite import PluginProtocol , Starlite , get @get ( \"/my-path\" ) def my_route_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # update app attributes app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... ) # register a route handler app . register ( my_route_handler ) Parameters: Name Type Description Default app Starlite The Starlite instance. required Returns: Type Description None None is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. Parameters: Name Type Description Default value Any An arbitrary value. required Returns: Type Description TypeGuard [ ModelT ] A typeguard dictating whether the value is supported by the plugin. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Given a model_class supported by the plugin, convert it to a subclass of the pydantic BaseModel. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any Any additional kwargs. {} Returns: Type Description Type [ BaseModel ] A pydantic model class. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description ModelT A model instance. to_dict to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. Parameters: Name Type Description Default model_instance ModelT A model instance of the type supported by the plugin. required Notes This method can be async as well. Returns: Type Description Union [ Dict [ str , Any ], Awaitable [ Dict [ str , Any ]]] A string keyed dictionary of values. from_dict from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any A string keyed mapping of values. {} Returns: Type Description ModelT A model instance.","title":"Plugin Protocol"},{"location":"reference/plugins/0-plugin-protocol/#plugin-protocol","text":"","title":"Plugin Protocol"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol","text":"Bases: Protocol [ ModelT ]","title":"PluginProtocol"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.on_app_init","text":"on_app_init ( app ) Receives the Starlite application instance before init is finalized and allows the plugin to update various attributes. Examples: from starlite import PluginProtocol , Starlite , get @get ( \"/my-path\" ) def my_route_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # update app attributes app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... ) # register a route handler app . register ( my_route_handler ) Parameters: Name Type Description Default app Starlite The Starlite instance. required Returns: Type Description None None","title":"on_app_init()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. Parameters: Name Type Description Default value Any An arbitrary value. required Returns: Type Description TypeGuard [ ModelT ] A typeguard dictating whether the value is supported by the plugin.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Given a model_class supported by the plugin, convert it to a subclass of the pydantic BaseModel. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any Any additional kwargs. {} Returns: Type Description Type [ BaseModel ] A pydantic model class.","title":"to_pydantic_model_class()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description ModelT A model instance.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.to_dict","text":"to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. Parameters: Name Type Description Default model_instance ModelT A model instance of the type supported by the plugin. required Notes This method can be async as well. Returns: Type Description Union [ Dict [ str , Any ], Awaitable [ Dict [ str , Any ]]] A string keyed dictionary of values.","title":"to_dict()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any A string keyed mapping of values. {} Returns: Type Description ModelT A model instance.","title":"from_dict()"},{"location":"reference/plugins/1-sqlalchemy-plugin/","text":"SQLAlchemy Plugin starlite.plugins.sql_alchemy.SQLAlchemyPlugin Bases: PluginProtocol [ DeclarativeMeta ] __init__ __init__ ( config = None ) A Plugin for SQLAlchemy. Support (de)serialization and OpenAPI generation for SQLAlchemy ORM types. Parameters: Name Type Description Default config Optional [ SQLAlchemyConfig ] Optional SQLAlchemyConfig instance. If passed, the plugin will establish a DB connection and hook handlers and dependencies. None from_dict from_dict ( model_class , ** kwargs ) Given a dictionary of kwargs, return an instance of the given model_class. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required **kwargs Any Kwargs to instantiate the table with. {} Returns: Type Description DeclarativeMeta An instantiated table instance. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Create an instance of a given model_class using the values stored in the given pydantic_model_instance. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description Any A declarative meta table instance. get_pydantic_type get_pydantic_type ( column_type ) Given a 'Column.type' value, return a type supported by pydantic. Parameters: Name Type Description Default column_type Any The type of the SQLColumn. required Returns: Type Description Any A pydantic supported type. is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) A typeguard that tests whether values are subclasses of SQLAlchemy's 'DeclarativeMeta' class. Parameters: Name Type Description Default value Any An arbitrary type to test. required Returns: Type Description TypeGuard[DeclarativeMeta] A boolean typeguard. on_app_init on_app_init ( app ) Executed on the application's init process. If config has been passed to the plugin, it will initialize SQLAlchemy and add the dependencies as expected. Parameters: Name Type Description Default app Starlite The Starlite application instance. required Returns: Type Description None None providers_map property providers_map () A map of SQLAlchemy column types to provider functions. This method is separated to allow for easy overriding in subclasses. Returns A dictionary mapping SQLAlchemy types to callables. to_dict to_dict ( model_instance ) Given a model instance, convert it to a dict of values that can be serialized. Parameters: Name Type Description Default model_instance DeclarativeMeta An SQLAlchemy declarative table instance. required Returns: Type Description Dict [ str , Any ] A string keyed dict of values. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Generates a pydantic model for a given SQLAlchemy declarative table and any nested relations. Parameters: Name Type Description Default model_class Type [ DeclarativeMeta ] An SQLAlchemy declarative class instance. required **kwargs Any Kwargs to pass to the model. {} Returns: Type Description Type[BaseModel] A pydantic model instance. starlite.plugins.sql_alchemy.SQLAlchemyConfig Bases: BaseModel This class represents the SQLAlchemy sessionmaker configuration. For details see: https://docs.sqlalchemy.org/en/14/orm/session_api.html before_send_handler class-attribute before_send_handler : BeforeMessageSendHookHandler = default_before_send_handler Handler to call before the ASGI message is sent. The handler should handle closing the session stored in the ASGI scope, if its still open, and committing and uncommitted data. connection_string class-attribute connection_string : Optional [ str ] = None Database connection string in one of the formats supported by SQLAlchemy. Notes: - For async connections, the connection string must include the correct async prefix. e.g. 'postgresql+asyncpg://...' instead of 'postgresql://', and for sync connections its the opposite. create_async_engine_callable class-attribute create_async_engine_callable : Callable [[ str ], AsyncEngine ] = create_async_engine Callable that creates an 'AsyncEngine' instance or instance of its subclass. create_engine_callable class-attribute create_engine_callable : Callable [[ str ], Union [ Engine , FutureEngine ]] = create_engine Callable that creates an 'Engine' or 'FutureEngine' instance or instance of its subclass. dependency_key class-attribute dependency_key : str = 'db_session' Key to use for the dependency injection of database sessions. engine_app_state_key class-attribute engine_app_state_key : str = 'db_engine' Key under which to store the SQLAlchemy engine in the application State instance. engine_config class-attribute engine_config : SQLAlchemyEngineConfig = SQLAlchemyEngineConfig () Configuration for the SQLAlchemy engine. The configuration options are documented in the SQLAlchemy documentation. engine_instance class-attribute engine_instance : Optional [ Union [ Engine , FutureEngine , AsyncEngine ]] = None Optional engine to use. If set, the plugin will use the provided instance rather than instantiate an engine. session_class class-attribute session_class : Optional [ Union [ Type [ Session ], Type [ AsyncSession ]]] = None The session class to use. If not set, the session class will default to 'sqlalchemy.orm.Session' for sync connections and 'sqlalchemy.ext.asyncio.AsyncSession' for async ones. session_config class-attribute session_config : SQLAlchemySessionConfig = SQLAlchemySessionConfig () Configuration options for the 'sessionmaker'. The configuration options are documented in the SQLAlchemy documentation. session_maker_app_state_key class-attribute session_maker_app_state_key : str = 'session_maker_class' Key under which to store the SQLAlchemy 'sessionmaker' in the application State instance. session_maker_class class-attribute session_maker_class : Type [ SessionMakerTypeProtocol ] = sessionmaker Sessionmaker class to use. session_maker_instance class-attribute session_maker_instance : Optional [ SessionMakerInstanceProtocol ] = None Optional sessionmaker to use. If set, the plugin will use the provided instance rather than instantiate a sessionmaker. engine property engine () Returns: Type Description Union [ Engine , FutureEngine , AsyncEngine ] Getter that returns the engine instance used by the plugin. session_maker property session_maker () Returns: Type Description sessionmaker Getter that returns the session_maker instance used by the plugin. starlite.plugins.sql_alchemy.SQLAlchemyEngineConfig Bases: BaseModel This class represents the SQLAlchemy Engine configuration. For details see: https://docs.sqlalchemy.org/en/14/core/engines.html connect_args class-attribute connect_args : Optional [ Dict [ str , Any ]] = None echo class-attribute echo : Optional [ bool ] = None echo_pool class-attribute echo_pool : Optional [ bool ] = None enable_from_linting class-attribute enable_from_linting : Optional [ bool ] = None future class-attribute future : bool = True hide_parameters class-attribute hide_parameters : Optional [ bool ] = None isolation_level class-attribute isolation_level : Optional [ IsolationLevel ] = None json_deserializer class-attribute json_deserializer : Callable [[ str ], Any ] = loads json_serializer class-attribute json_serializer : Callable [[ Any ], str ] = serializer label_length class-attribute label_length : Optional [ int ] = None listeners class-attribute listeners : Any = None logging_level class-attribute logging_level : Optional [ Union [ int , str ]] = None logging_name class-attribute logging_name : Optional [ str ] = None max_identifier_length class-attribute max_identifier_length : Optional [ int ] = None max_overflow class-attribute max_overflow : Optional [ int ] = None module class-attribute module : Any = None paramstyle class-attribute paramstyle : Optional [ Literal [ qmark , numeric , named , format , pyformat ]] = None plugins class-attribute plugins : Optional [ List [ str ]] = None pool class-attribute pool : Optional [ Pool ] = None pool_logging_name class-attribute pool_logging_name : Optional [ str ] = None pool_pre_ping class-attribute pool_pre_ping : Optional [ bool ] = None pool_recycle class-attribute pool_recycle : Optional [ int ] = None pool_reset_on_return class-attribute pool_reset_on_return : Optional [ Literal [ rollback , commit ]] = None pool_size class-attribute pool_size : Optional [ int ] = None pool_timeout class-attribute pool_timeout : Optional [ int ] = None pool_use_lifo class-attribute pool_use_lifo : Optional [ bool ] = None poolclass class-attribute poolclass : Optional [ Type [ Pool ]] = None query_cache_size class-attribute query_cache_size : Optional [ int ] = None strategy class-attribute strategy : Optional [ str ] = None starlite.plugins.sql_alchemy.SQLAlchemySessionConfig Bases: BaseModel autocommit class-attribute autocommit : Optional [ bool ] = None autoflush class-attribute autoflush : Optional [ bool ] = None bind class-attribute bind : Optional [ Any ] = None binds class-attribute binds : Optional [ Any ] = None enable_baked_queries class-attribute enable_baked_queries : Optional [ bool ] = None expire_on_commit class-attribute expire_on_commit : bool = False future class-attribute future : Optional [ bool ] = None info class-attribute info : Optional [ Dict [ str , Any ]] = None query_cls class-attribute query_cls : Optional [ Type [ Query ]] = None twophase class-attribute twophase : Optional [ bool ] = None","title":"SQLAlchemy Plugin"},{"location":"reference/plugins/1-sqlalchemy-plugin/#sqlalchemy-plugin","text":"","title":"SQLAlchemy Plugin"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyPlugin","text":"Bases: PluginProtocol [ DeclarativeMeta ]","title":"SQLAlchemyPlugin"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.__init__","text":"__init__ ( config = None ) A Plugin for SQLAlchemy. Support (de)serialization and OpenAPI generation for SQLAlchemy ORM types. Parameters: Name Type Description Default config Optional [ SQLAlchemyConfig ] Optional SQLAlchemyConfig instance. If passed, the plugin will establish a DB connection and hook handlers and dependencies. None","title":"__init__()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a dictionary of kwargs, return an instance of the given model_class. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required **kwargs Any Kwargs to instantiate the table with. {} Returns: Type Description DeclarativeMeta An instantiated table instance.","title":"from_dict()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Create an instance of a given model_class using the values stored in the given pydantic_model_instance. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description Any A declarative meta table instance.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.get_pydantic_type","text":"get_pydantic_type ( column_type ) Given a 'Column.type' value, return a type supported by pydantic. Parameters: Name Type Description Default column_type Any The type of the SQLColumn. required Returns: Type Description Any A pydantic supported type.","title":"get_pydantic_type()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) A typeguard that tests whether values are subclasses of SQLAlchemy's 'DeclarativeMeta' class. Parameters: Name Type Description Default value Any An arbitrary type to test. required Returns: Type Description TypeGuard[DeclarativeMeta] A boolean typeguard.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.on_app_init","text":"on_app_init ( app ) Executed on the application's init process. If config has been passed to the plugin, it will initialize SQLAlchemy and add the dependencies as expected. Parameters: Name Type Description Default app Starlite The Starlite application instance. required Returns: Type Description None None","title":"on_app_init()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.providers_map","text":"providers_map () A map of SQLAlchemy column types to provider functions. This method is separated to allow for easy overriding in subclasses. Returns A dictionary mapping SQLAlchemy types to callables.","title":"providers_map()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.to_dict","text":"to_dict ( model_instance ) Given a model instance, convert it to a dict of values that can be serialized. Parameters: Name Type Description Default model_instance DeclarativeMeta An SQLAlchemy declarative table instance. required Returns: Type Description Dict [ str , Any ] A string keyed dict of values.","title":"to_dict()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Generates a pydantic model for a given SQLAlchemy declarative table and any nested relations. Parameters: Name Type Description Default model_class Type [ DeclarativeMeta ] An SQLAlchemy declarative class instance. required **kwargs Any Kwargs to pass to the model. {} Returns: Type Description Type[BaseModel] A pydantic model instance.","title":"to_pydantic_model_class()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyConfig","text":"Bases: BaseModel This class represents the SQLAlchemy sessionmaker configuration. For details see: https://docs.sqlalchemy.org/en/14/orm/session_api.html","title":"SQLAlchemyConfig"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.before_send_handler","text":"before_send_handler : BeforeMessageSendHookHandler = default_before_send_handler Handler to call before the ASGI message is sent. The handler should handle closing the session stored in the ASGI scope, if its still open, and committing and uncommitted data.","title":"before_send_handler"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.connection_string","text":"connection_string : Optional [ str ] = None Database connection string in one of the formats supported by SQLAlchemy. Notes: - For async connections, the connection string must include the correct async prefix. e.g. 'postgresql+asyncpg://...' instead of 'postgresql://', and for sync connections its the opposite.","title":"connection_string"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.create_async_engine_callable","text":"create_async_engine_callable : Callable [[ str ], AsyncEngine ] = create_async_engine Callable that creates an 'AsyncEngine' instance or instance of its subclass.","title":"create_async_engine_callable"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.create_engine_callable","text":"create_engine_callable : Callable [[ str ], Union [ Engine , FutureEngine ]] = create_engine Callable that creates an 'Engine' or 'FutureEngine' instance or instance of its subclass.","title":"create_engine_callable"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.dependency_key","text":"dependency_key : str = 'db_session' Key to use for the dependency injection of database sessions.","title":"dependency_key"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_app_state_key","text":"engine_app_state_key : str = 'db_engine' Key under which to store the SQLAlchemy engine in the application State instance.","title":"engine_app_state_key"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_config","text":"engine_config : SQLAlchemyEngineConfig = SQLAlchemyEngineConfig () Configuration for the SQLAlchemy engine. The configuration options are documented in the SQLAlchemy documentation.","title":"engine_config"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_instance","text":"engine_instance : Optional [ Union [ Engine , FutureEngine , AsyncEngine ]] = None Optional engine to use. If set, the plugin will use the provided instance rather than instantiate an engine.","title":"engine_instance"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_class","text":"session_class : Optional [ Union [ Type [ Session ], Type [ AsyncSession ]]] = None The session class to use. If not set, the session class will default to 'sqlalchemy.orm.Session' for sync connections and 'sqlalchemy.ext.asyncio.AsyncSession' for async ones.","title":"session_class"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_config","text":"session_config : SQLAlchemySessionConfig = SQLAlchemySessionConfig () Configuration options for the 'sessionmaker'. The configuration options are documented in the SQLAlchemy documentation.","title":"session_config"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_app_state_key","text":"session_maker_app_state_key : str = 'session_maker_class' Key under which to store the SQLAlchemy 'sessionmaker' in the application State instance.","title":"session_maker_app_state_key"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_class","text":"session_maker_class : Type [ SessionMakerTypeProtocol ] = sessionmaker Sessionmaker class to use.","title":"session_maker_class"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_instance","text":"session_maker_instance : Optional [ SessionMakerInstanceProtocol ] = None Optional sessionmaker to use. If set, the plugin will use the provided instance rather than instantiate a sessionmaker.","title":"session_maker_instance"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine","text":"engine () Returns: Type Description Union [ Engine , FutureEngine , AsyncEngine ] Getter that returns the engine instance used by the plugin.","title":"engine()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker","text":"session_maker () Returns: Type Description sessionmaker Getter that returns the session_maker instance used by the plugin.","title":"session_maker()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyEngineConfig","text":"Bases: BaseModel This class represents the SQLAlchemy Engine configuration. For details see: https://docs.sqlalchemy.org/en/14/core/engines.html","title":"SQLAlchemyEngineConfig"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.connect_args","text":"connect_args : Optional [ Dict [ str , Any ]] = None","title":"connect_args"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.echo","text":"echo : Optional [ bool ] = None","title":"echo"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.echo_pool","text":"echo_pool : Optional [ bool ] = None","title":"echo_pool"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.enable_from_linting","text":"enable_from_linting : Optional [ bool ] = None","title":"enable_from_linting"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.future","text":"future : bool = True","title":"future"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.hide_parameters","text":"hide_parameters : Optional [ bool ] = None","title":"hide_parameters"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.isolation_level","text":"isolation_level : Optional [ IsolationLevel ] = None","title":"isolation_level"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.json_deserializer","text":"json_deserializer : Callable [[ str ], Any ] = loads","title":"json_deserializer"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.json_serializer","text":"json_serializer : Callable [[ Any ], str ] = serializer","title":"json_serializer"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.label_length","text":"label_length : Optional [ int ] = None","title":"label_length"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.listeners","text":"listeners : Any = None","title":"listeners"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.logging_level","text":"logging_level : Optional [ Union [ int , str ]] = None","title":"logging_level"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.logging_name","text":"logging_name : Optional [ str ] = None","title":"logging_name"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.max_identifier_length","text":"max_identifier_length : Optional [ int ] = None","title":"max_identifier_length"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.max_overflow","text":"max_overflow : Optional [ int ] = None","title":"max_overflow"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.module","text":"module : Any = None","title":"module"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.paramstyle","text":"paramstyle : Optional [ Literal [ qmark , numeric , named , format , pyformat ]] = None","title":"paramstyle"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.plugins","text":"plugins : Optional [ List [ str ]] = None","title":"plugins"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool","text":"pool : Optional [ Pool ] = None","title":"pool"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_logging_name","text":"pool_logging_name : Optional [ str ] = None","title":"pool_logging_name"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_pre_ping","text":"pool_pre_ping : Optional [ bool ] = None","title":"pool_pre_ping"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_recycle","text":"pool_recycle : Optional [ int ] = None","title":"pool_recycle"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_reset_on_return","text":"pool_reset_on_return : Optional [ Literal [ rollback , commit ]] = None","title":"pool_reset_on_return"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_size","text":"pool_size : Optional [ int ] = None","title":"pool_size"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_timeout","text":"pool_timeout : Optional [ int ] = None","title":"pool_timeout"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_use_lifo","text":"pool_use_lifo : Optional [ bool ] = None","title":"pool_use_lifo"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.poolclass","text":"poolclass : Optional [ Type [ Pool ]] = None","title":"poolclass"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.query_cache_size","text":"query_cache_size : Optional [ int ] = None","title":"query_cache_size"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.strategy","text":"strategy : Optional [ str ] = None","title":"strategy"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemySessionConfig","text":"Bases: BaseModel","title":"SQLAlchemySessionConfig"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.autocommit","text":"autocommit : Optional [ bool ] = None","title":"autocommit"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.autoflush","text":"autoflush : Optional [ bool ] = None","title":"autoflush"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.bind","text":"bind : Optional [ Any ] = None","title":"bind"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.binds","text":"binds : Optional [ Any ] = None","title":"binds"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.enable_baked_queries","text":"enable_baked_queries : Optional [ bool ] = None","title":"enable_baked_queries"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.expire_on_commit","text":"expire_on_commit : bool = False","title":"expire_on_commit"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.future","text":"future : Optional [ bool ] = None","title":"future"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.info","text":"info : Optional [ Dict [ str , Any ]] = None","title":"info"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.query_cls","text":"query_cls : Optional [ Type [ Query ]] = None","title":"query_cls"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.twophase","text":"twophase : Optional [ bool ] = None","title":"twophase"},{"location":"reference/plugins/2-piccolo-orm-plugin/","text":"PiccoloORM Plugin starlite.plugins.piccolo_orm.PiccoloORMPlugin Bases: PluginProtocol [ Table ] Support (de)serialization and OpenAPI generation for Piccolo ORM types. from_dict from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. to_dict to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Given a piccolo model_class instance, convert it to a subclass of the piccolo \"BaseModel\". Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in piccolo-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"PiccoloORM Plugin"},{"location":"reference/plugins/2-piccolo-orm-plugin/#piccoloorm-plugin","text":"","title":"PiccoloORM Plugin"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin","text":"Bases: PluginProtocol [ Table ] Support (de)serialization and OpenAPI generation for Piccolo ORM types.","title":"PiccoloORMPlugin"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class.","title":"from_dict()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.to_dict","text":"to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values.","title":"to_dict()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Given a piccolo model_class instance, convert it to a subclass of the piccolo \"BaseModel\". Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in piccolo-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"to_pydantic_model_class()"},{"location":"reference/plugins/3-tortoise-orm-plugin/","text":"TortoiseORM Plugin starlite.plugins.tortoise_orm.TortoiseORMPlugin Bases: PluginProtocol [ Model ] Support (de)serialization and OpenAPI generation for Tortoise ORM types. from_dict from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. to_dict async to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Given a tortoise model_class instance, convert it to a subclass of the tortoise PydanticModel. Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in tortoise-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"TortoiseORM Plugin"},{"location":"reference/plugins/3-tortoise-orm-plugin/#tortoiseorm-plugin","text":"","title":"TortoiseORM Plugin"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin","text":"Bases: PluginProtocol [ Model ] Support (de)serialization and OpenAPI generation for Tortoise ORM types.","title":"TortoiseORMPlugin"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class.","title":"from_dict()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.to_dict","text":"to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values.","title":"to_dict()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Given a tortoise model_class instance, convert it to a subclass of the tortoise PydanticModel. Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in tortoise-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"to_pydantic_model_class()"},{"location":"reference/template/0-base/","text":"Templating starlite.template.base.TemplateProtocol Bases: Protocol Protocol Defining a 'Template'. Template is a class that has a render method which renders the template into a string. render render ( * args , ** kwargs ) Returns the rendered template as a string. Parameters: Name Type Description Default **kwargs Any A string keyed mapping of values passed to the TemplateEngine {} Returns: Type Description str The rendered template string starlite.template.base.T_co module-attribute starlite . template . base . T_co = TypeVar ( 'T_co' , bound = TemplateProtocol , covariant = True ) starlite.template.base.TemplateEngineProtocol Bases: Protocol [ T_co ] __init__ __init__ ( directory ) Protocol for a templating engine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required get_template get_template ( template_name ) Retrieves a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description T_co Template instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found. register_template_callable register_template_callable ( key , template_callable ) Registers a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"Templating"},{"location":"reference/template/0-base/#templating","text":"","title":"Templating"},{"location":"reference/template/0-base/#starlite.template.base.TemplateProtocol","text":"Bases: Protocol Protocol Defining a 'Template'. Template is a class that has a render method which renders the template into a string.","title":"TemplateProtocol"},{"location":"reference/template/0-base/#starlite.template.base.TemplateProtocol.render","text":"render ( * args , ** kwargs ) Returns the rendered template as a string. Parameters: Name Type Description Default **kwargs Any A string keyed mapping of values passed to the TemplateEngine {} Returns: Type Description str The rendered template string","title":"render()"},{"location":"reference/template/0-base/#starlite.template.base.T_co","text":"starlite . template . base . T_co = TypeVar ( 'T_co' , bound = TemplateProtocol , covariant = True )","title":"T_co"},{"location":"reference/template/0-base/#starlite.template.base.TemplateEngineProtocol","text":"Bases: Protocol [ T_co ]","title":"TemplateEngineProtocol"},{"location":"reference/template/0-base/#starlite.template.base.TemplateEngineProtocol.__init__","text":"__init__ ( directory ) Protocol for a templating engine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required","title":"__init__()"},{"location":"reference/template/0-base/#starlite.template.base.TemplateEngineProtocol.get_template","text":"get_template ( template_name ) Retrieves a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description T_co Template instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found.","title":"get_template()"},{"location":"reference/template/0-base/#starlite.template.base.TemplateEngineProtocol.register_template_callable","text":"register_template_callable ( key , template_callable ) Registers a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"register_template_callable()"},{"location":"reference/template/1-jinja/","text":"Jinja Template Engine starlite.template.jinja.JinjaTemplateEngine Bases: TemplateEngineProtocol [ JinjaTemplate ] The engine instance. __init__ __init__ ( directory ) Jinja2 based TemplateEngine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required get_template get_template ( template_name ) Retrieves a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description JinjaTemplate JinjaTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found. register_template_callable register_template_callable ( key , template_callable ) Registers a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"Jinja Template Engine"},{"location":"reference/template/1-jinja/#jinja-template-engine","text":"","title":"Jinja Template Engine"},{"location":"reference/template/1-jinja/#starlite.template.jinja.JinjaTemplateEngine","text":"Bases: TemplateEngineProtocol [ JinjaTemplate ] The engine instance.","title":"JinjaTemplateEngine"},{"location":"reference/template/1-jinja/#starlite.template.jinja.JinjaTemplateEngine.__init__","text":"__init__ ( directory ) Jinja2 based TemplateEngine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required","title":"__init__()"},{"location":"reference/template/1-jinja/#starlite.template.jinja.JinjaTemplateEngine.get_template","text":"get_template ( template_name ) Retrieves a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description JinjaTemplate JinjaTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found.","title":"get_template()"},{"location":"reference/template/1-jinja/#starlite.template.jinja.JinjaTemplateEngine.register_template_callable","text":"register_template_callable ( key , template_callable ) Registers a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"register_template_callable()"},{"location":"reference/template/2-mako/","text":"Mako Template Engine starlite.template.mako.MakoTemplateEngine Bases: TemplateEngineProtocol [ MakoTemplate ] __init__ __init__ ( directory ) Mako based TemplateEngine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required get_template get_template ( template_name ) Retrieves a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description MakoTemplate MakoTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found. register_template_callable register_template_callable ( key , template_callable ) Registers a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"Mako Template Engine"},{"location":"reference/template/2-mako/#mako-template-engine","text":"","title":"Mako Template Engine"},{"location":"reference/template/2-mako/#starlite.template.mako.MakoTemplateEngine","text":"Bases: TemplateEngineProtocol [ MakoTemplate ]","title":"MakoTemplateEngine"},{"location":"reference/template/2-mako/#starlite.template.mako.MakoTemplateEngine.__init__","text":"__init__ ( directory ) Mako based TemplateEngine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required","title":"__init__()"},{"location":"reference/template/2-mako/#starlite.template.mako.MakoTemplateEngine.get_template","text":"get_template ( template_name ) Retrieves a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description MakoTemplate MakoTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found.","title":"get_template()"},{"location":"reference/template/2-mako/#starlite.template.mako.MakoTemplateEngine.register_template_callable","text":"register_template_callable ( key , template_callable ) Registers a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"register_template_callable()"},{"location":"reference/testing/0-test-client/","text":"Test Client starlite.testing.TestClient Bases: StarletteTestClient __init__ __init__ ( app , base_url = \"http://testserver\" , raise_server_exceptions = True , root_path = \"\" , backend = \"asyncio\" , backend_options = None , session_config = None , ) A client implementation providing a context manager for testing applications. Parameters: Name Type Description Default app Starlite The instance of Starlite under test. required base_url str URL scheme and domain for test request paths, e.g. 'http://testserver'. 'http://testserver' raise_server_exceptions bool Flag for underlying Starlette test client to raise server exceptions instead of wrapping them in an HTTP response. True root_path str Path prefix for requests. '' backend Literal['asyncio', 'trio' ] The async backend to use, options are \"asyncio\" or \"trio\". 'asyncio' backend_options Optional [ Dict [ str , Any ]] 'anyio' options. None session_config Optional [ SessionCookieConfig ] Configuration for Session Middleware class to create raw session cookies for request to the route handlers. None __enter__ __enter__ () Starlette's TestClient.__enter__() return value is strongly typed to return their own TestClient , i.e., not-generic to support subclassing. We override here to provide a nicer typing experience for our user Returns: Type Description TestClient TestClient create_session_cookies create_session_cookies ( session_data ) Creates raw session cookies that are loaded into the session by the Session Middleware. It creates cookies the same way as if they are coming from the browser. Your tests must set up session middleware to load raw session cookies into the session. Parameters: Name Type Description Default session_data Dict [ str , Any ] Dictionary to create raw session cookies from. required Returns: Type Description Dict [ str , str ] A dictionary with cookie name as key and cookie value as value. Examples: import pytest from starlite.testing import TestClient from my_app.main import app , session_cookie_config_instance class TestClass : @pytest . fixture () def test_client ( self ) -> TestClient : with TestClient ( app = app , session_config = session_cookie_config_instance ) as client : yield client def test_something ( self , test_client : TestClient ) -> None : cookies = test_client . create_session_cookies ( session_data = { \"user\" : \"test_user\" }) # Set raw session cookies to the \"cookies\" attribute of test_client instance. test_client . cookies = cookies test_client . get ( url = \"/my_route\" ) get_session_from_cookies get_session_from_cookies () Raw session cookies are a serialized image of session which are created by session middleware and sent with the response. To assert data in session, this method deserializes the raw session cookies and creates session from them. Returns: Type Description Dict [ str , Any ] A dictionary containing session data. Examples: def test_something ( self , test_client : TestClient ) -> None : test_client . get ( url = \"/my_route\" ) session = test_client . get_session_from_cookies () assert \"user\" in session starlite . testing . create_test_client ( route_handlers , * , after_exception = None , after_request = None , after_response = None , after_shutdown = None , after_startup = None , allowed_hosts = None , backend = 'asyncio' , backend_options = None , base_url = 'http://testserver' , before_request = None , before_send = None , before_shutdown = None , before_startup = None , cache_config = DEFAULT_CACHE_CONFIG , compression_config = None , cors_config = None , csrf_config = None , dependencies = None , exception_handlers = None , guards = None , logging_config = None , middleware = None , on_shutdown = None , on_startup = None , openapi_config = None , parameters = None , plugins = None , raise_server_exceptions = True , request_class = None , response_class = None , root_path = '' , session_config = None , static_files_config = None , template_config = None , websocket_class = None ) Creates a Starlite app instance and initializes it. TestClient with it. Notes This function should be called as a context manager to ensure async startup and shutdown are handled correctly. Examples: from starlite import get , create_test_client @get ( \"/some-path\" ) def my_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } def test_my_handler () -> None : with create_test_client ( my_handler ) as client : response == client . get ( \"/some-path\" ) assert response . json () == { \"hello\" : \"world\" } Parameters: Name Type Description Default route_handlers Union [ ControllerRouterHandler , List [ ControllerRouterHandler ]] A single handler or a list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required after_exception Optional [ SingleOrList[AfterExceptionHookHandler] ] An application level exception event handler . This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be either an instance of Response or starlette.Response . None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None after_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. None after_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. None allowed_hosts Optional [ List [ str ]] A list of allowed hosts - enables the builtin allowed hosts middleware. None backend Literal['asyncio', 'trio'] The async backend to use, options are \"asyncio\" or \"trio\". 'asyncio' backend_options Optional [ Dict [ str , Any ]] 'anyio' options. None base_url str URL scheme and domain for test request paths, e.g. 'http://testserver'. 'http://testserver' before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. None before_send Optional [ SingleOrList[BeforeMessageSendHookHandler] ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. None before_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. None before_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. None cache_config CacheConfig Configures caching behavior of the application. DEFAULT_CACHE_CONFIG compression_config Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. None cors_config Optional [ CORSConfig ] If set this enables the builtin CORS middleware. None csrf_config Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. None dependencies Optional [ Dependencies ] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None logging_config Optional [ BaseLoggingConfig ] A subclass of BaseLoggingConfig . None middleware Optional [ List [ Middleware ]] A list of Middleware . None on_shutdown Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application shutdown. None on_startup Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application startup. None openapi_config Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None plugins Optional [ List [ PluginProtocol ]] List of plugins. None request_class Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. None raise_server_exceptions bool Flag for underlying Starlette test client to raise server exceptions instead of wrapping them in an HTTP response. True response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. None root_path str Path prefix for requests. '' static_files_config Optional [ Union [ StaticFilesConfig , List [ StaticFilesConfig ]]] An instance or list of StaticFilesConfig None session_config Optional [ SessionCookieConfig ] Configuration for Session Middleware class to create raw session cookies for request to the route handlers. None template_config Optional [ TemplateConfig ] An instance of TemplateConfig None websocket_class Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections. None Returns: Type Description TestClient An instance of TestClient with a created app instance.","title":"Test Client"},{"location":"reference/testing/0-test-client/#test-client","text":"","title":"Test Client"},{"location":"reference/testing/0-test-client/#starlite.testing.TestClient","text":"Bases: StarletteTestClient","title":"TestClient"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.TestClient.__init__","text":"__init__ ( app , base_url = \"http://testserver\" , raise_server_exceptions = True , root_path = \"\" , backend = \"asyncio\" , backend_options = None , session_config = None , ) A client implementation providing a context manager for testing applications. Parameters: Name Type Description Default app Starlite The instance of Starlite under test. required base_url str URL scheme and domain for test request paths, e.g. 'http://testserver'. 'http://testserver' raise_server_exceptions bool Flag for underlying Starlette test client to raise server exceptions instead of wrapping them in an HTTP response. True root_path str Path prefix for requests. '' backend Literal['asyncio', 'trio' ] The async backend to use, options are \"asyncio\" or \"trio\". 'asyncio' backend_options Optional [ Dict [ str , Any ]] 'anyio' options. None session_config Optional [ SessionCookieConfig ] Configuration for Session Middleware class to create raw session cookies for request to the route handlers. None","title":"__init__()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.TestClient.__enter__","text":"__enter__ () Starlette's TestClient.__enter__() return value is strongly typed to return their own TestClient , i.e., not-generic to support subclassing. We override here to provide a nicer typing experience for our user Returns: Type Description TestClient TestClient","title":"__enter__()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.TestClient.create_session_cookies","text":"create_session_cookies ( session_data ) Creates raw session cookies that are loaded into the session by the Session Middleware. It creates cookies the same way as if they are coming from the browser. Your tests must set up session middleware to load raw session cookies into the session. Parameters: Name Type Description Default session_data Dict [ str , Any ] Dictionary to create raw session cookies from. required Returns: Type Description Dict [ str , str ] A dictionary with cookie name as key and cookie value as value. Examples: import pytest from starlite.testing import TestClient from my_app.main import app , session_cookie_config_instance class TestClass : @pytest . fixture () def test_client ( self ) -> TestClient : with TestClient ( app = app , session_config = session_cookie_config_instance ) as client : yield client def test_something ( self , test_client : TestClient ) -> None : cookies = test_client . create_session_cookies ( session_data = { \"user\" : \"test_user\" }) # Set raw session cookies to the \"cookies\" attribute of test_client instance. test_client . cookies = cookies test_client . get ( url = \"/my_route\" )","title":"create_session_cookies()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.TestClient.get_session_from_cookies","text":"get_session_from_cookies () Raw session cookies are a serialized image of session which are created by session middleware and sent with the response. To assert data in session, this method deserializes the raw session cookies and creates session from them. Returns: Type Description Dict [ str , Any ] A dictionary containing session data. Examples: def test_something ( self , test_client : TestClient ) -> None : test_client . get ( url = \"/my_route\" ) session = test_client . get_session_from_cookies () assert \"user\" in session","title":"get_session_from_cookies()"},{"location":"reference/testing/0-test-client/#starlite.testing.create_test_client","text":"Creates a Starlite app instance and initializes it. TestClient with it. Notes This function should be called as a context manager to ensure async startup and shutdown are handled correctly. Examples: from starlite import get , create_test_client @get ( \"/some-path\" ) def my_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } def test_my_handler () -> None : with create_test_client ( my_handler ) as client : response == client . get ( \"/some-path\" ) assert response . json () == { \"hello\" : \"world\" } Parameters: Name Type Description Default route_handlers Union [ ControllerRouterHandler , List [ ControllerRouterHandler ]] A single handler or a list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required after_exception Optional [ SingleOrList[AfterExceptionHookHandler] ] An application level exception event handler . This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be either an instance of Response or starlette.Response . None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None after_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. None after_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. None allowed_hosts Optional [ List [ str ]] A list of allowed hosts - enables the builtin allowed hosts middleware. None backend Literal['asyncio', 'trio'] The async backend to use, options are \"asyncio\" or \"trio\". 'asyncio' backend_options Optional [ Dict [ str , Any ]] 'anyio' options. None base_url str URL scheme and domain for test request paths, e.g. 'http://testserver'. 'http://testserver' before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. None before_send Optional [ SingleOrList[BeforeMessageSendHookHandler] ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. None before_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. None before_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level LifeSpan hook handler . This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. None cache_config CacheConfig Configures caching behavior of the application. DEFAULT_CACHE_CONFIG compression_config Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. None cors_config Optional [ CORSConfig ] If set this enables the builtin CORS middleware. None csrf_config Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. None dependencies Optional [ Dependencies ] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None logging_config Optional [ BaseLoggingConfig ] A subclass of BaseLoggingConfig . None middleware Optional [ List [ Middleware ]] A list of Middleware . None on_shutdown Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application shutdown. None on_startup Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application startup. None openapi_config Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None plugins Optional [ List [ PluginProtocol ]] List of plugins. None request_class Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. None raise_server_exceptions bool Flag for underlying Starlette test client to raise server exceptions instead of wrapping them in an HTTP response. True response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. None root_path str Path prefix for requests. '' static_files_config Optional [ Union [ StaticFilesConfig , List [ StaticFilesConfig ]]] An instance or list of StaticFilesConfig None session_config Optional [ SessionCookieConfig ] Configuration for Session Middleware class to create raw session cookies for request to the route handlers. None template_config Optional [ TemplateConfig ] An instance of TemplateConfig None websocket_class Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections. None Returns: Type Description TestClient An instance of TestClient with a created app instance.","title":"create_test_client()"},{"location":"reference/testing/1-request-factory/","text":"Request Factory starlite.testing.RequestFactory __init__ __init__ ( app = Starlite ( route_handlers = [ _default_route_handler ]), server = \"test.org\" , port = 3000 , root_path = \"\" , scheme = \"http\" , ) A factory object to create Request instances. Parameters: Name Type Description Default app Starlite An instance of Starlite to set as request.scope[\"app\"] . Starlite(route_handlers=[_default_route_handler]) server str The server's domain. 'test.org' port int The server's port. 3000 root_path str Root path for the server. '' scheme str Scheme for the server. 'http' Examples: from starlite import RequestEncodingType , Starlite from starlite.testing import RequestFactory from tests import PersonFactory my_app = Starlite ( route_handlers = []) my_server = \"starlite.org\" # Create a GET request query_params = { \"id\" : 1 } get_user_request = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params ) # Create a POST request new_person = PersonFactory . build () create_user_request = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person ) # Create a request with a special header headers = { \"header1\" : \"value1\" } request_with_header = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params , headers = headers ) # Create a request with a media type request_with_media_type = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person , request_media_type = RequestEncodingType . MULTI_PART ) get get ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a GET Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance post post ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance put put ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PUT Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance patch patch ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PATCH Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance delete delete ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"Request Factory"},{"location":"reference/testing/1-request-factory/#request-factory","text":"","title":"Request Factory"},{"location":"reference/testing/1-request-factory/#starlite.testing.RequestFactory","text":"","title":"RequestFactory"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.__init__","text":"__init__ ( app = Starlite ( route_handlers = [ _default_route_handler ]), server = \"test.org\" , port = 3000 , root_path = \"\" , scheme = \"http\" , ) A factory object to create Request instances. Parameters: Name Type Description Default app Starlite An instance of Starlite to set as request.scope[\"app\"] . Starlite(route_handlers=[_default_route_handler]) server str The server's domain. 'test.org' port int The server's port. 3000 root_path str Root path for the server. '' scheme str Scheme for the server. 'http' Examples: from starlite import RequestEncodingType , Starlite from starlite.testing import RequestFactory from tests import PersonFactory my_app = Starlite ( route_handlers = []) my_server = \"starlite.org\" # Create a GET request query_params = { \"id\" : 1 } get_user_request = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params ) # Create a POST request new_person = PersonFactory . build () create_user_request = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person ) # Create a request with a special header headers = { \"header1\" : \"value1\" } request_with_header = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params , headers = headers ) # Create a request with a media type request_with_media_type = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person , request_media_type = RequestEncodingType . MULTI_PART )","title":"__init__()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.get","text":"get ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a GET Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"get()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.post","text":"post ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"post()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.put","text":"put ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PUT Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"put()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.patch","text":"patch ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PATCH Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"patch()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.delete","text":"delete ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"delete()"},{"location":"reference/types/0-types-intro/","text":"Types Starlite exports many types. Some types are meant for internal usage only, and are as such undocumented in this section.","title":"Types"},{"location":"reference/types/0-types-intro/#types","text":"Starlite exports many types. Some types are meant for internal usage only, and are as such undocumented in this section.","title":"Types"},{"location":"reference/types/1-callable-types/","text":"Callable Types Callables types represent callables - functions, methods or classes that implement the __call__ dunder method. starlite.types.AfterExceptionHookHandler module-attribute starlite . types . AfterExceptionHookHandler = Callable [ [ Exception , Scope , State ], SyncOrAsyncUnion [ None ] ] starlite.types.AfterRequestHookHandler module-attribute starlite . types . AfterRequestHookHandler = Union [ Callable [[ StarletteResponse ], SyncOrAsyncUnion [ StarletteResponse ]], Callable [[ Response ], SyncOrAsyncUnion [ Response ]], ] starlite.types.AfterResponseHookHandler module-attribute starlite . types . AfterResponseHookHandler = Callable [[ Request ], SyncOrAsyncUnion [ None ]] starlite.types.AnyCallable module-attribute starlite . types . AnyCallable = Callable [ Ellipsis , Any ] starlite.types.AsyncAnyCallable module-attribute starlite . types . AsyncAnyCallable = Callable [ Ellipsis , Awaitable [ Any ]] starlite.types.BeforeMessageSendHookHandler module-attribute starlite . types . BeforeMessageSendHookHandler = Union [ Callable [[ Message , State , Scope ], SyncOrAsyncUnion [ None ]], Callable [[ Message , State ], SyncOrAsyncUnion [ None ]], ] starlite.types.BeforeRequestHookHandler module-attribute starlite . types . BeforeRequestHookHandler = Callable [[ Request ], Union [ Any , Awaitable [ Any ]]] starlite.types.CacheKeyBuilder module-attribute starlite . types . CacheKeyBuilder = Callable [[ Request ], str ] starlite.types.ExceptionHandler module-attribute starlite . types . ExceptionHandler = Callable [[ Request , _ExceptionT ], StarletteResponse ] starlite.types.Guard module-attribute starlite . types . Guard = Union [ Callable [[ Request , HTTPRouteHandler ], SyncOrAsyncUnion [ None ]], Callable [[ WebSocket , WebsocketRouteHandler ], SyncOrAsyncUnion [ None ]], ] starlite.types.LifeSpanHandler module-attribute starlite . types . LifeSpanHandler = Union [ Callable [[], SyncOrAsyncUnion [ Any ]], Callable [[ State ], SyncOrAsyncUnion [ Any ]] ] starlite.types.LifeSpanHookHandler module-attribute starlite . types . LifeSpanHookHandler = Callable [[ StarliteType ], SyncOrAsyncUnion [ None ]] starlite.types.OnAppInitHandler module-attribute starlite . types . OnAppInitHandler = Callable [[ AppConfig ], AppConfig ] starlite.types.Serializer module-attribute starlite . types . Serializer = Callable [[ Any ], Any ]","title":"Callable Types"},{"location":"reference/types/1-callable-types/#callable-types","text":"Callables types represent callables - functions, methods or classes that implement the __call__ dunder method.","title":"Callable Types"},{"location":"reference/types/1-callable-types/#starlite.types.AfterExceptionHookHandler","text":"starlite . types . AfterExceptionHookHandler = Callable [ [ Exception , Scope , State ], SyncOrAsyncUnion [ None ] ]","title":"AfterExceptionHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.AfterRequestHookHandler","text":"starlite . types . AfterRequestHookHandler = Union [ Callable [[ StarletteResponse ], SyncOrAsyncUnion [ StarletteResponse ]], Callable [[ Response ], SyncOrAsyncUnion [ Response ]], ]","title":"AfterRequestHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.AfterResponseHookHandler","text":"starlite . types . AfterResponseHookHandler = Callable [[ Request ], SyncOrAsyncUnion [ None ]]","title":"AfterResponseHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.AnyCallable","text":"starlite . types . AnyCallable = Callable [ Ellipsis , Any ]","title":"AnyCallable"},{"location":"reference/types/1-callable-types/#starlite.types.AsyncAnyCallable","text":"starlite . types . AsyncAnyCallable = Callable [ Ellipsis , Awaitable [ Any ]]","title":"AsyncAnyCallable"},{"location":"reference/types/1-callable-types/#starlite.types.BeforeMessageSendHookHandler","text":"starlite . types . BeforeMessageSendHookHandler = Union [ Callable [[ Message , State , Scope ], SyncOrAsyncUnion [ None ]], Callable [[ Message , State ], SyncOrAsyncUnion [ None ]], ]","title":"BeforeMessageSendHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.BeforeRequestHookHandler","text":"starlite . types . BeforeRequestHookHandler = Callable [[ Request ], Union [ Any , Awaitable [ Any ]]]","title":"BeforeRequestHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.CacheKeyBuilder","text":"starlite . types . CacheKeyBuilder = Callable [[ Request ], str ]","title":"CacheKeyBuilder"},{"location":"reference/types/1-callable-types/#starlite.types.ExceptionHandler","text":"starlite . types . ExceptionHandler = Callable [[ Request , _ExceptionT ], StarletteResponse ]","title":"ExceptionHandler"},{"location":"reference/types/1-callable-types/#starlite.types.Guard","text":"starlite . types . Guard = Union [ Callable [[ Request , HTTPRouteHandler ], SyncOrAsyncUnion [ None ]], Callable [[ WebSocket , WebsocketRouteHandler ], SyncOrAsyncUnion [ None ]], ]","title":"Guard"},{"location":"reference/types/1-callable-types/#starlite.types.LifeSpanHandler","text":"starlite . types . LifeSpanHandler = Union [ Callable [[], SyncOrAsyncUnion [ Any ]], Callable [[ State ], SyncOrAsyncUnion [ Any ]] ]","title":"LifeSpanHandler"},{"location":"reference/types/1-callable-types/#starlite.types.LifeSpanHookHandler","text":"starlite . types . LifeSpanHookHandler = Callable [[ StarliteType ], SyncOrAsyncUnion [ None ]]","title":"LifeSpanHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.OnAppInitHandler","text":"starlite . types . OnAppInitHandler = Callable [[ AppConfig ], AppConfig ]","title":"OnAppInitHandler"},{"location":"reference/types/1-callable-types/#starlite.types.Serializer","text":"starlite . types . Serializer = Callable [[ Any ], Any ]","title":"Serializer"},{"location":"reference/types/2-asgi-types/","text":"ASGI Types starlite.types.Method module-attribute starlite . types . Method = Literal [ \"GET\" , \"POST\" , \"DELETE\" , \"PATCH\" , \"PUT\" , \"HEAD\" , \"TRACE\" , \"OPTIONS\" ] ASGI Application starlite.types.ASGIApp module-attribute starlite . types . ASGIApp = Callable [[ Scope , Receive , Send ], Awaitable [ None ]] ASGI Application Parameters starlite.types.Scope module-attribute starlite . types . Scope = Union [ HTTPScope , WebSocketScope ] starlite.types.Receive module-attribute starlite . types . Receive = Callable [ Ellipsis , Awaitable [ Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]] ] starlite.types.Send module-attribute starlite . types . Send = Callable [[ Message ], Awaitable [ None ]] ASGI Scopes starlite.types.ASGIVersion Bases: TypedDict starlite.types.BaseScope Bases: TypedDict starlite.types.WebSocketScope Bases: BaseScope starlite.types.HTTPScope Bases: BaseScope starlite.types.LifeSpanScope Bases: TypedDict ASGI Events starlite.types.HTTPRequestEvent Bases: TypedDict starlite.types.HTTPResponseStartEvent Bases: TypedDict starlite.types.HTTPResponseBodyEvent Bases: TypedDict starlite.types.HTTPServerPushEvent Bases: TypedDict starlite.types.HTTPDisconnectEvent Bases: TypedDict starlite.types.WebSocketConnectEvent Bases: TypedDict starlite.types.WebSocketAcceptEvent Bases: TypedDict starlite.types.WebSocketReceiveEvent Bases: TypedDict starlite.types.WebSocketSendEvent Bases: TypedDict starlite.types.WebSocketResponseStartEvent Bases: TypedDict starlite.types.WebSocketResponseBodyEvent Bases: TypedDict starlite.types.WebSocketDisconnectEvent Bases: TypedDict starlite.types.WebSocketCloseEvent Bases: TypedDict starlite.types.LifeSpanStartupEvent Bases: TypedDict starlite.types.LifeSpanShutdownEvent Bases: TypedDict starlite.types.LifeSpanStartupCompleteEvent Bases: TypedDict starlite.types.LifeSpanStartupFailedEvent Bases: TypedDict starlite.types.LifeSpanShutdownCompleteEvent Bases: TypedDict starlite.types.LifeSpanShutdownFailedEvent Bases: TypedDict Event Groupings starlite.types.HTTPReceiveMessage module-attribute starlite . types . HTTPReceiveMessage = Union [ HTTPRequestEvent , HTTPDisconnectEvent ] starlite.types.WebSocketReceiveMessage module-attribute starlite . types . WebSocketReceiveMessage = Union [ WebSocketConnectEvent , WebSocketReceiveEvent , WebSocketDisconnectEvent ] starlite.types.LifeSpanReceiveMessage module-attribute starlite . types . LifeSpanReceiveMessage = Union [ LifeSpanStartupEvent , LifeSpanShutdownEvent ] starlite.types.HTTPSendMessage module-attribute starlite . types . HTTPSendMessage = Union [ HTTPResponseStartEvent , HTTPResponseBodyEvent , HTTPServerPushEvent , HTTPDisconnectEvent ] starlite.types.WebSocketSendMessage module-attribute starlite . types . WebSocketSendMessage = Union [ WebSocketAcceptEvent , WebSocketSendEvent , WebSocketResponseStartEvent , WebSocketResponseBodyEvent , WebSocketCloseEvent , ] starlite.types.LifeSpanSendMessage module-attribute starlite . types . LifeSpanSendMessage = Union [ LifeSpanStartupCompleteEvent , LifeSpanStartupFailedEvent , LifeSpanShutdownCompleteEvent , LifeSpanShutdownFailedEvent , ] starlite.types.LifeSpanReceive module-attribute starlite . types . LifeSpanReceive = Callable [ Ellipsis , Awaitable [ LifeSpanReceiveMessage ]] starlite.types.LifeSpanSend module-attribute starlite . types . LifeSpanSend = Callable [[ LifeSpanSendMessage ], Awaitable [ None ]] Send / Receive Parameter Types starlite.types.Message module-attribute starlite . types . Message = Union [ HTTPSendMessage , WebSocketSendMessage ] starlite.types.ReceiveMessage module-attribute starlite . types . ReceiveMessage = Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]","title":"ASGI Types"},{"location":"reference/types/2-asgi-types/#asgi-types","text":"","title":"ASGI Types"},{"location":"reference/types/2-asgi-types/#starlite.types.Method","text":"starlite . types . Method = Literal [ \"GET\" , \"POST\" , \"DELETE\" , \"PATCH\" , \"PUT\" , \"HEAD\" , \"TRACE\" , \"OPTIONS\" ]","title":"Method"},{"location":"reference/types/2-asgi-types/#asgi-application","text":"","title":"ASGI Application"},{"location":"reference/types/2-asgi-types/#starlite.types.ASGIApp","text":"starlite . types . ASGIApp = Callable [[ Scope , Receive , Send ], Awaitable [ None ]]","title":"ASGIApp"},{"location":"reference/types/2-asgi-types/#asgi-application-parameters","text":"","title":"ASGI Application Parameters"},{"location":"reference/types/2-asgi-types/#starlite.types.Scope","text":"starlite . types . Scope = Union [ HTTPScope , WebSocketScope ]","title":"Scope"},{"location":"reference/types/2-asgi-types/#starlite.types.Receive","text":"starlite . types . Receive = Callable [ Ellipsis , Awaitable [ Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]] ]","title":"Receive"},{"location":"reference/types/2-asgi-types/#starlite.types.Send","text":"starlite . types . Send = Callable [[ Message ], Awaitable [ None ]]","title":"Send"},{"location":"reference/types/2-asgi-types/#asgi-scopes","text":"","title":"ASGI Scopes"},{"location":"reference/types/2-asgi-types/#starlite.types.ASGIVersion","text":"Bases: TypedDict","title":"ASGIVersion"},{"location":"reference/types/2-asgi-types/#starlite.types.BaseScope","text":"Bases: TypedDict","title":"BaseScope"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketScope","text":"Bases: BaseScope","title":"WebSocketScope"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPScope","text":"Bases: BaseScope","title":"HTTPScope"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanScope","text":"Bases: TypedDict","title":"LifeSpanScope"},{"location":"reference/types/2-asgi-types/#asgi-events","text":"","title":"ASGI Events"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPRequestEvent","text":"Bases: TypedDict","title":"HTTPRequestEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPResponseStartEvent","text":"Bases: TypedDict","title":"HTTPResponseStartEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPResponseBodyEvent","text":"Bases: TypedDict","title":"HTTPResponseBodyEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPServerPushEvent","text":"Bases: TypedDict","title":"HTTPServerPushEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPDisconnectEvent","text":"Bases: TypedDict","title":"HTTPDisconnectEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketConnectEvent","text":"Bases: TypedDict","title":"WebSocketConnectEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketAcceptEvent","text":"Bases: TypedDict","title":"WebSocketAcceptEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketReceiveEvent","text":"Bases: TypedDict","title":"WebSocketReceiveEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketSendEvent","text":"Bases: TypedDict","title":"WebSocketSendEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketResponseStartEvent","text":"Bases: TypedDict","title":"WebSocketResponseStartEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketResponseBodyEvent","text":"Bases: TypedDict","title":"WebSocketResponseBodyEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketDisconnectEvent","text":"Bases: TypedDict","title":"WebSocketDisconnectEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketCloseEvent","text":"Bases: TypedDict","title":"WebSocketCloseEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupEvent","text":"Bases: TypedDict","title":"LifeSpanStartupEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownEvent","text":"Bases: TypedDict","title":"LifeSpanShutdownEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupCompleteEvent","text":"Bases: TypedDict","title":"LifeSpanStartupCompleteEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupFailedEvent","text":"Bases: TypedDict","title":"LifeSpanStartupFailedEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownCompleteEvent","text":"Bases: TypedDict","title":"LifeSpanShutdownCompleteEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownFailedEvent","text":"Bases: TypedDict","title":"LifeSpanShutdownFailedEvent"},{"location":"reference/types/2-asgi-types/#event-groupings","text":"","title":"Event Groupings"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPReceiveMessage","text":"starlite . types . HTTPReceiveMessage = Union [ HTTPRequestEvent , HTTPDisconnectEvent ]","title":"HTTPReceiveMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketReceiveMessage","text":"starlite . types . WebSocketReceiveMessage = Union [ WebSocketConnectEvent , WebSocketReceiveEvent , WebSocketDisconnectEvent ]","title":"WebSocketReceiveMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanReceiveMessage","text":"starlite . types . LifeSpanReceiveMessage = Union [ LifeSpanStartupEvent , LifeSpanShutdownEvent ]","title":"LifeSpanReceiveMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPSendMessage","text":"starlite . types . HTTPSendMessage = Union [ HTTPResponseStartEvent , HTTPResponseBodyEvent , HTTPServerPushEvent , HTTPDisconnectEvent ]","title":"HTTPSendMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketSendMessage","text":"starlite . types . WebSocketSendMessage = Union [ WebSocketAcceptEvent , WebSocketSendEvent , WebSocketResponseStartEvent , WebSocketResponseBodyEvent , WebSocketCloseEvent , ]","title":"WebSocketSendMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanSendMessage","text":"starlite . types . LifeSpanSendMessage = Union [ LifeSpanStartupCompleteEvent , LifeSpanStartupFailedEvent , LifeSpanShutdownCompleteEvent , LifeSpanShutdownFailedEvent , ]","title":"LifeSpanSendMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanReceive","text":"starlite . types . LifeSpanReceive = Callable [ Ellipsis , Awaitable [ LifeSpanReceiveMessage ]]","title":"LifeSpanReceive"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanSend","text":"starlite . types . LifeSpanSend = Callable [[ LifeSpanSendMessage ], Awaitable [ None ]]","title":"LifeSpanSend"},{"location":"reference/types/2-asgi-types/#send-receive-parameter-types","text":"","title":"Send / Receive Parameter Types"},{"location":"reference/types/2-asgi-types/#starlite.types.Message","text":"starlite . types . Message = Union [ HTTPSendMessage , WebSocketSendMessage ]","title":"Message"},{"location":"reference/types/2-asgi-types/#starlite.types.ReceiveMessage","text":"starlite . types . ReceiveMessage = Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]","title":"ReceiveMessage"},{"location":"reference/types/3-helper-types/","text":"Helper Types Helper types are useful generic types that can be used. starlite.types.SyncOrAsyncUnion module-attribute starlite . types . SyncOrAsyncUnion = Union [ T , Awaitable [ T ]] Types 'T' as a union of T and awaitable T starlite.types.SingleOrList module-attribute starlite . types . SingleOrList = Union [ T , List [ T ]] Types 'T' as a single value or a list T","title":"Helper Types"},{"location":"reference/types/3-helper-types/#helper-types","text":"Helper types are useful generic types that can be used.","title":"Helper Types"},{"location":"reference/types/3-helper-types/#starlite.types.SyncOrAsyncUnion","text":"starlite . types . SyncOrAsyncUnion = Union [ T , Awaitable [ T ]] Types 'T' as a union of T and awaitable T","title":"SyncOrAsyncUnion"},{"location":"reference/types/3-helper-types/#starlite.types.SingleOrList","text":"starlite . types . SingleOrList = Union [ T , List [ T ]] Types 'T' as a single value or a list T","title":"SingleOrList"},{"location":"reference/types/4-protocol-types/","text":"Protocols starlite.types.Logger Bases: Protocol","title":"Protocols"},{"location":"reference/types/4-protocol-types/#protocols","text":"","title":"Protocols"},{"location":"reference/types/4-protocol-types/#starlite.types.Logger","text":"Bases: Protocol","title":"Logger"},{"location":"reference/types/5-composite-types/","text":"Composite Types starlite.types.Dependencies module-attribute starlite . types . Dependencies = Dict [ str , Provide ] starlite.types.ExceptionHandlersMap module-attribute starlite . types . ExceptionHandlersMap = Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ] starlite.types.Middleware module-attribute starlite . types . Middleware = Union [ Callable [ Ellipsis , ASGIApp ], DefineMiddleware , StarletteMiddleware , Type [ BaseHTTPMiddleware ], Type [ MiddlewareProtocol ], ] starlite.types.ResponseCookies module-attribute starlite . types . ResponseCookies = List [ Cookie ] starlite.types.ResponseHeadersMap module-attribute starlite . types . ResponseHeadersMap = Dict [ str , ResponseHeader ]","title":"Composite Types"},{"location":"reference/types/5-composite-types/#composite-types","text":"","title":"Composite Types"},{"location":"reference/types/5-composite-types/#starlite.types.Dependencies","text":"starlite . types . Dependencies = Dict [ str , Provide ]","title":"Dependencies"},{"location":"reference/types/5-composite-types/#starlite.types.ExceptionHandlersMap","text":"starlite . types . ExceptionHandlersMap = Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ]","title":"ExceptionHandlersMap"},{"location":"reference/types/5-composite-types/#starlite.types.Middleware","text":"starlite . types . Middleware = Union [ Callable [ Ellipsis , ASGIApp ], DefineMiddleware , StarletteMiddleware , Type [ BaseHTTPMiddleware ], Type [ MiddlewareProtocol ], ]","title":"Middleware"},{"location":"reference/types/5-composite-types/#starlite.types.ResponseCookies","text":"starlite . types . ResponseCookies = List [ Cookie ]","title":"ResponseCookies"},{"location":"reference/types/5-composite-types/#starlite.types.ResponseHeadersMap","text":"starlite . types . ResponseHeadersMap = Dict [ str , ResponseHeader ]","title":"ResponseHeadersMap"},{"location":"reference/types/6-partial-types/","text":"Partial starlite.types.partial.T module-attribute starlite . types . partial . T = TypeVar ( 'T' ) starlite.types.partial.Partial Bases: Generic [ T ] Type generation for PATCH routes. Partial is a special typing helper that takes a generic T, which must be a TypedDict , dataclass or pydantic model class, and returns to static type checkers a version of this T in which all fields - and nested fields - are optional.","title":"Partial"},{"location":"reference/types/6-partial-types/#partial","text":"","title":"Partial"},{"location":"reference/types/6-partial-types/#starlite.types.partial.T","text":"starlite . types . partial . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/types/6-partial-types/#starlite.types.partial.Partial","text":"Bases: Generic [ T ] Type generation for PATCH routes. Partial is a special typing helper that takes a generic T, which must be a TypedDict , dataclass or pydantic model class, and returns to static type checkers a version of this T in which all fields - and nested fields - are optional.","title":"Partial"},{"location":"reference/utils/0-predicate-utils/","text":"Predicate Utils starlite.utils.predicates.P module-attribute starlite . utils . predicates . P = ParamSpec ( 'P' ) starlite.utils.predicates.T module-attribute starlite . utils . predicates . T = TypeVar ( 'T' ) starlite.utils.predicates.is_async_callable starlite . utils . predicates . is_async_callable ( value ) Extends asyncio.iscoroutinefunction() to additionally detect async partial objects and class instances with async def __call__() defined. Parameters: Name Type Description Default value Callable [ P , T ] Any required Returns: Type Description TypeGuard [ Callable [ P , Awaitable [ T ]]] Bool determining if type of value is an awaitable. starlite.utils.predicates.is_class_and_subclass starlite . utils . predicates . is_class_and_subclass ( value , t_type ) Return True if value is a class and is a subtype of t_type . See https://github.com/starlite-api/starlite/issues/367 Parameters: Name Type Description Default value Any The value to check if is class and subclass of t_type . required t_type Type [ T ] Type used for issubclass() check of value required Returns: Type Description TypeGuard [ Type [ T ]] bool starlite.utils.predicates.is_dataclass_class_or_instance_typeguard starlite . utils . predicates . is_dataclass_class_or_instance_typeguard ( value ) Wrapper for is_dataclass() that narrows type. Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[DataclassClassOrInstance] True if instance or type of dataclass . starlite.utils.predicates.is_dataclass_class_typeguard starlite . utils . predicates . is_dataclass_class_typeguard ( value ) Wrapper for is_dataclass() that narrows to type only, not instance. Parameters: Name Type Description Default value Any tested to determine if type of dataclass . required Returns: Type Description TypeGuard[DataclassClass] True if value is a dataclass type. starlite.utils.predicates.is_optional_union starlite . utils . predicates . is_optional_union ( annotation ) Given a type annotation determine if the annotation infers an optional union. Parameters: Name Type Description Default annotation Any A type. required Returns: Type Description bool True for a union, False otherwise. starlite.utils.predicates.is_typeddict_typeguard starlite . utils . predicates . is_typeddict_typeguard ( value ) Wrapper for is_typeddict() that narrows type. Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[TypedDictClass] True if instance or type of dataclass .","title":"Predicate Utils"},{"location":"reference/utils/0-predicate-utils/#predicate-utils","text":"","title":"Predicate Utils"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.P","text":"starlite . utils . predicates . P = ParamSpec ( 'P' )","title":"P"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.T","text":"starlite . utils . predicates . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_async_callable","text":"starlite . utils . predicates . is_async_callable ( value ) Extends asyncio.iscoroutinefunction() to additionally detect async partial objects and class instances with async def __call__() defined. Parameters: Name Type Description Default value Callable [ P , T ] Any required Returns: Type Description TypeGuard [ Callable [ P , Awaitable [ T ]]] Bool determining if type of value is an awaitable.","title":"is_async_callable()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_class_and_subclass","text":"starlite . utils . predicates . is_class_and_subclass ( value , t_type ) Return True if value is a class and is a subtype of t_type . See https://github.com/starlite-api/starlite/issues/367 Parameters: Name Type Description Default value Any The value to check if is class and subclass of t_type . required t_type Type [ T ] Type used for issubclass() check of value required Returns: Type Description TypeGuard [ Type [ T ]] bool","title":"is_class_and_subclass()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_dataclass_class_or_instance_typeguard","text":"starlite . utils . predicates . is_dataclass_class_or_instance_typeguard ( value ) Wrapper for is_dataclass() that narrows type. Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[DataclassClassOrInstance] True if instance or type of dataclass .","title":"is_dataclass_class_or_instance_typeguard()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_dataclass_class_typeguard","text":"starlite . utils . predicates . is_dataclass_class_typeguard ( value ) Wrapper for is_dataclass() that narrows to type only, not instance. Parameters: Name Type Description Default value Any tested to determine if type of dataclass . required Returns: Type Description TypeGuard[DataclassClass] True if value is a dataclass type.","title":"is_dataclass_class_typeguard()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_optional_union","text":"starlite . utils . predicates . is_optional_union ( annotation ) Given a type annotation determine if the annotation infers an optional union. Parameters: Name Type Description Default annotation Any A type. required Returns: Type Description bool True for a union, False otherwise.","title":"is_optional_union()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_typeddict_typeguard","text":"starlite . utils . predicates . is_typeddict_typeguard ( value ) Wrapper for is_typeddict() that narrows type. Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[TypedDictClass] True if instance or type of dataclass .","title":"is_typeddict_typeguard()"},{"location":"reference/utils/1-sync-utils/","text":"Async Utils starlite.utils.sync.P module-attribute starlite . utils . sync . P = ParamSpec ( 'P' ) starlite.utils.sync.T module-attribute starlite . utils . sync . T = TypeVar ( 'T' ) starlite.utils.AsyncCallable Bases: Generic [ P , T ] __init__ __init__ ( fn ) Utility class that wraps a callable and ensures it can be called as an async function. Parameters: Name Type Description Default fn Callable [ P , T ] Callable to wrap - can be any sync or async callable. required __call__ async __call__ ( * args , ** kwargs ) A proxy to the wrapped function's call method. Parameters: Name Type Description Default *args P . args Args of the wrapped function. () **kwargs P . kwargs Kwargs of the wrapper function. {} Returns: Type Description T The return value of the wrapped function. starlite.utils.as_async_callable_list starlite . utils . as_async_callable_list ( value ) Helper function to handle wrapping values in AsyncCallables Parameters: Name Type Description Default value Union [ Callable , List [ Callable ]] A callable or list of callables. required Returns: Type Description List [ AsyncCallable ] A list of AsyncCallable instances starlite.utils.async_partial starlite . utils . async_partial ( fn ) This function wraps a given sync function making it async. In difference to the 'asyncio.run_sync' function, it allows for passing kwargs. Parameters: Name Type Description Default fn Callable A sync callable to wrap. required Returns: Type Description Callable A wrapper","title":"Async Utils"},{"location":"reference/utils/1-sync-utils/#async-utils","text":"","title":"Async Utils"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.P","text":"starlite . utils . sync . P = ParamSpec ( 'P' )","title":"P"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.T","text":"starlite . utils . sync . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/utils/1-sync-utils/#starlite.utils.AsyncCallable","text":"Bases: Generic [ P , T ]","title":"AsyncCallable"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncCallable.__init__","text":"__init__ ( fn ) Utility class that wraps a callable and ensures it can be called as an async function. Parameters: Name Type Description Default fn Callable [ P , T ] Callable to wrap - can be any sync or async callable. required","title":"__init__()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncCallable.__call__","text":"__call__ ( * args , ** kwargs ) A proxy to the wrapped function's call method. Parameters: Name Type Description Default *args P . args Args of the wrapped function. () **kwargs P . kwargs Kwargs of the wrapper function. {} Returns: Type Description T The return value of the wrapped function.","title":"__call__()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.as_async_callable_list","text":"starlite . utils . as_async_callable_list ( value ) Helper function to handle wrapping values in AsyncCallables Parameters: Name Type Description Default value Union [ Callable , List [ Callable ]] A callable or list of callables. required Returns: Type Description List [ AsyncCallable ] A list of AsyncCallable instances","title":"as_async_callable_list()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.async_partial","text":"starlite . utils . async_partial ( fn ) This function wraps a given sync function making it async. In difference to the 'asyncio.run_sync' function, it allows for passing kwargs. Parameters: Name Type Description Default fn Callable A sync callable to wrap. required Returns: Type Description Callable A wrapper","title":"async_partial()"},{"location":"reference/utils/2-scope-utils/","text":"Scope Utils starlite.utils.get_serializer_from_scope starlite . utils . get_serializer_from_scope ( scope ) Utility that returns a serializer given a scope object. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Optional [ Serializer ] A serializer function","title":"Scope Utils"},{"location":"reference/utils/2-scope-utils/#scope-utils","text":"","title":"Scope Utils"},{"location":"reference/utils/2-scope-utils/#starlite.utils.get_serializer_from_scope","text":"starlite . utils . get_serializer_from_scope ( scope ) Utility that returns a serializer given a scope object. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Optional [ Serializer ] A serializer function","title":"get_serializer_from_scope()"},{"location":"reference/utils/3-exception-utils/","text":"Exception Utils starlite.utils.get_exception_handler starlite . utils . get_exception_handler ( exception_handlers , exc ) Given a dictionary that maps exceptions and status codes to handler functions, and an exception, returns the appropriate handler if existing. Status codes are given preference over exception type. If no status code match exists, each class in the MRO of the exception type is checked and the first matching handler is returned. Finally, if a 500 handler is registered, it will be returned for any exception that isn't a subclass of HTTPException . Parameters: Name Type Description Default exception_handlers ExceptionHandlersMap Mapping of status codes and exception types to handlers. required exc Exception Exception Instance to be resolved to a handler. required Returns: Type Description Optional [ ExceptionHandler ] Optional exception handler callable. starlite.utils.ExceptionResponseContent Bases: BaseModel starlite.utils.create_exception_response starlite . utils . create_exception_response ( exc ) Constructs a response from an exception. For instances of either starlite.exceptions.HTTPException or starlette.exceptions.HTTPException the response status code is drawn from the exception, otherwise response status is HTTP_500_INTERNAL_SERVER_ERROR . Parameters: Name Type Description Default exc Exception An exception. required Returns: Name Type Description Response Response HTTP response constructed from exception details.","title":"Exception Utils"},{"location":"reference/utils/3-exception-utils/#exception-utils","text":"","title":"Exception Utils"},{"location":"reference/utils/3-exception-utils/#starlite.utils.get_exception_handler","text":"starlite . utils . get_exception_handler ( exception_handlers , exc ) Given a dictionary that maps exceptions and status codes to handler functions, and an exception, returns the appropriate handler if existing. Status codes are given preference over exception type. If no status code match exists, each class in the MRO of the exception type is checked and the first matching handler is returned. Finally, if a 500 handler is registered, it will be returned for any exception that isn't a subclass of HTTPException . Parameters: Name Type Description Default exception_handlers ExceptionHandlersMap Mapping of status codes and exception types to handlers. required exc Exception Exception Instance to be resolved to a handler. required Returns: Type Description Optional [ ExceptionHandler ] Optional exception handler callable.","title":"get_exception_handler()"},{"location":"reference/utils/3-exception-utils/#starlite.utils.ExceptionResponseContent","text":"Bases: BaseModel","title":"ExceptionResponseContent"},{"location":"reference/utils/3-exception-utils/#starlite.utils.create_exception_response","text":"starlite . utils . create_exception_response ( exc ) Constructs a response from an exception. For instances of either starlite.exceptions.HTTPException or starlette.exceptions.HTTPException the response status code is drawn from the exception, otherwise response status is HTTP_500_INTERNAL_SERVER_ERROR . Parameters: Name Type Description Default exc Exception An exception. required Returns: Name Type Description Response Response HTTP response constructed from exception details.","title":"create_exception_response()"},{"location":"reference/utils/4-extractor-utils/","text":"Extraction Utils starlite.utils.extractors.ResponseExtractorField module-attribute starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"method\" , \"headers\" , \"body\" , \"cookies\" ] starlite.utils.extractors.ConnectionDataExtractor __init__ __init__ ( extract_body = True , extract_client = True , extract_content_type = True , extract_cookies = True , extract_headers = True , extract_method = True , extract_path = True , extract_path_params = True , extract_query = True , extract_scheme = True , obfuscate_cookies = None , obfuscate_headers = None , parse_body = False , parse_query = False , ) A utility class that extracts data from an. ASGIConnection , Request or WebSocket instance. Parameters: Name Type Description Default extract_body bool Whether to extract body, (for requests only). True extract_client bool Whether to extract the client (host, port) mapping. True extract_content_type bool Whether to extract the content type and any options. True extract_cookies bool Whether to extract cookies. True extract_headers bool Whether to extract headers. True extract_method bool Whether to extract the HTTP method, (for requests only). True extract_path bool Whether to extract the path. True extract_path_params bool Whether to extract path parameters. True extract_query bool Whether to extract query parameters. True extract_scheme bool Whether to extract the http scheme. True obfuscate_headers Optional [ Set [ str ]] headers keys to obfuscate. Obfuscated values are replaced with ' * '. None obfuscate_cookies Optional [ Set [ str ]] cookie keys to obfuscate. Obfuscated values are replaced with ' * '. None parse_body bool Whether to parse the body value or return the raw byte string, (for requests only). False parse_query bool Whether to parse query parameters or return the raw byte string. False __call__ __call__ ( connection ) Extracts data from the connection, returning a dictionary of values. Notes The value for 'body' - if present - is an unresolved Coroutine and as such should be awaited by the receiver. Parameters: Name Type Description Default connection ASGIConnection[Any, Any, Any] An ASGI connection or its subclasses. required Returns: Type Description ExtractedRequestData A string keyed dictionary of extracted values. starlite.utils.extractors.ExtractedResponseData Bases: TypedDict starlite.utils.extractors.ResponseExtractorField module-attribute starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"method\" , \"headers\" , \"body\" , \"cookies\" ] starlite.utils.extractors.RequestExtractorField module-attribute starlite . utils . extractors . RequestExtractorField = Literal [ \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , \"scheme\" , \"client\" , ] starlite.utils.extractors.ExtractedRequestData Bases: TypedDict starlite.utils.extractors.obfuscate starlite . utils . extractors . obfuscate ( values , fields_to_obfuscate ) Parameters: Name Type Description Default values Dict [ str , Any ] A dictionary of strings required fields_to_obfuscate Set [ str ] keys to obfuscate required Returns: Type Description Dict [ str , Any ] A dictionary with obfuscated strings","title":"Extraction Utils"},{"location":"reference/utils/4-extractor-utils/#extraction-utils","text":"","title":"Extraction Utils"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ResponseExtractorField","text":"starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"method\" , \"headers\" , \"body\" , \"cookies\" ]","title":"ResponseExtractorField"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor","text":"","title":"ConnectionDataExtractor"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor.__init__","text":"__init__ ( extract_body = True , extract_client = True , extract_content_type = True , extract_cookies = True , extract_headers = True , extract_method = True , extract_path = True , extract_path_params = True , extract_query = True , extract_scheme = True , obfuscate_cookies = None , obfuscate_headers = None , parse_body = False , parse_query = False , ) A utility class that extracts data from an. ASGIConnection , Request or WebSocket instance. Parameters: Name Type Description Default extract_body bool Whether to extract body, (for requests only). True extract_client bool Whether to extract the client (host, port) mapping. True extract_content_type bool Whether to extract the content type and any options. True extract_cookies bool Whether to extract cookies. True extract_headers bool Whether to extract headers. True extract_method bool Whether to extract the HTTP method, (for requests only). True extract_path bool Whether to extract the path. True extract_path_params bool Whether to extract path parameters. True extract_query bool Whether to extract query parameters. True extract_scheme bool Whether to extract the http scheme. True obfuscate_headers Optional [ Set [ str ]] headers keys to obfuscate. Obfuscated values are replaced with ' * '. None obfuscate_cookies Optional [ Set [ str ]] cookie keys to obfuscate. Obfuscated values are replaced with ' * '. None parse_body bool Whether to parse the body value or return the raw byte string, (for requests only). False parse_query bool Whether to parse query parameters or return the raw byte string. False","title":"__init__()"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor.__call__","text":"__call__ ( connection ) Extracts data from the connection, returning a dictionary of values. Notes The value for 'body' - if present - is an unresolved Coroutine and as such should be awaited by the receiver. Parameters: Name Type Description Default connection ASGIConnection[Any, Any, Any] An ASGI connection or its subclasses. required Returns: Type Description ExtractedRequestData A string keyed dictionary of extracted values.","title":"__call__()"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ExtractedResponseData","text":"Bases: TypedDict","title":"ExtractedResponseData"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ResponseExtractorField","text":"starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"method\" , \"headers\" , \"body\" , \"cookies\" ]","title":"ResponseExtractorField"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.RequestExtractorField","text":"starlite . utils . extractors . RequestExtractorField = Literal [ \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , \"scheme\" , \"client\" , ]","title":"RequestExtractorField"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ExtractedRequestData","text":"Bases: TypedDict","title":"ExtractedRequestData"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.obfuscate","text":"starlite . utils . extractors . obfuscate ( values , fields_to_obfuscate ) Parameters: Name Type Description Default values Dict [ str , Any ] A dictionary of strings required fields_to_obfuscate Set [ str ] keys to obfuscate required Returns: Type Description Dict [ str , Any ] A dictionary with obfuscated strings","title":"obfuscate()"},{"location":"reference/utils/5-sequence-utils/","text":"Sequence Utils starlite.utils.sequence.T module-attribute starlite . utils . sequence . T = TypeVar ( 'T' ) starlite.utils.find_index starlite . utils . find_index ( target_list , predicate ) Find element in list given a key and value. List elements can be dicts or classes starlite.utils.unique starlite . utils . unique ( value ) Return all unique values in a given sequence or iterator.","title":"Sequence Utils"},{"location":"reference/utils/5-sequence-utils/#sequence-utils","text":"","title":"Sequence Utils"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.sequence.T","text":"starlite . utils . sequence . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.find_index","text":"starlite . utils . find_index ( target_list , predicate ) Find element in list given a key and value. List elements can be dicts or classes","title":"find_index()"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.unique","text":"starlite . utils . unique ( value ) Return all unique values in a given sequence or iterator.","title":"unique()"},{"location":"reference/utils/6-path-utils/","text":"Path Utils starlite.utils.normalize_path starlite . utils . normalize_path ( path ) Normalizes a given path by ensuring it starts with a slash and does not end with a slash. Parameters: Name Type Description Default path str Path string required Returns: Type Description str Path string starlite.utils.join_paths starlite . utils . join_paths ( paths ) Normalizes and joins path fragments. Parameters: Name Type Description Default paths Iterable [ str ] An iterable of path fragments. required Returns: Type Description str A normalized joined path string.","title":"Path Utils"},{"location":"reference/utils/6-path-utils/#path-utils","text":"","title":"Path Utils"},{"location":"reference/utils/6-path-utils/#starlite.utils.normalize_path","text":"starlite . utils . normalize_path ( path ) Normalizes a given path by ensuring it starts with a slash and does not end with a slash. Parameters: Name Type Description Default path str Path string required Returns: Type Description str Path string","title":"normalize_path()"},{"location":"reference/utils/6-path-utils/#starlite.utils.join_paths","text":"starlite . utils . join_paths ( paths ) Normalizes and joins path fragments. Parameters: Name Type Description Default paths Iterable [ str ] An iterable of path fragments. required Returns: Type Description str A normalized joined path string.","title":"join_paths()"},{"location":"reference/utils/7-serialization-utils/","text":"Serialization Utils starlite.utils.default_serializer starlite . utils . default_serializer ( value ) Parameters: Name Type Description Default value Any A value to serialize required Returns: Type Description Any A serialized value Raises: Type Description TypeError if value is not supported","title":"Serialization Utils"},{"location":"reference/utils/7-serialization-utils/#serialization-utils","text":"","title":"Serialization Utils"},{"location":"reference/utils/7-serialization-utils/#starlite.utils.default_serializer","text":"starlite . utils . default_serializer ( value ) Parameters: Name Type Description Default value Any A value to serialize required Returns: Type Description Any A serialized value Raises: Type Description TypeError if value is not supported","title":"default_serializer()"},{"location":"usage/11-data-transfer-objects/","text":"Data Transfer Objects (DTOs) Starlite includes a DTOFactory class that allows you to create DTOs from pydantic models, dataclasses, TypedDict , and any other class supported via plugins. An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields. The created DTO can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model. Important Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as DTO[T] , with T being a generic argument representing the original model used to create the DTO. Note MyPy doesn't support using types defined using Type[] as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment. The DTOFactory class supports plugins , for example, this is how it could be used with an SQLAlchemy declarative class using the SQLAlchemyPlugin : from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) The created CompanyDTO is equal to this pydantic model declaration: from pydantic import BaseModel class CompanyDTO ( BaseModel ): id : int name : str worth : float You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future. Excluding Fields You can exclude any field in the original model class from the DTO : from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , exclude = [ \"first\" ]) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int Remapping Fields You can remap fields in two ways: you can switch change their keys: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" }) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int third : int You can remap name and type. To do this use a tuple instead of a string for the object value: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" , \"second\" : ( \"fourth\" , float )} ) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): third : int fourth : float Add New Fields You add fields that do not exist in the original model by passing in a field_definitions dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper : For required fields use a tuple of type + ellipsis, for example (str, ...) . For optional fields use a tuple of type + None , for example (str, None) To set a default value use a tuple of type + default value, for example (str, \"Hello World\") from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_definitions = { \"third\" : ( str , ... )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): first : int second : int third : str Partial DTOs For PATCH HTTP methods, you may only need to partially modify a resource. In these cases, DTOs can be wrapped with Partial . from pydantic import BaseModel from starlite.types.partial import Partial class CompanyDTO ( BaseModel ): id : int name : str worth : float PartialCompanyDTO = Partial [ CompanyDTO ] The created PartialCompanyDTO is equivalent to the following declaration: from typing import Optional from pydantic import BaseModel class PartialCompanyDTO ( BaseModel ): id : Optional [ int ] name : Optional [ str ] worth : Optional [ float ] Partial can also be used inline when creating routes. from pydantic import UUID4 , BaseModel from starlite.controller import Controller from starlite.handlers import patch from starlite.types.partial import Partial class UserOrder ( BaseModel ): order_id : UUID4 order_item_id : UUID4 notes : str class UserOrderController ( Controller ): path = \"/user\" @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ... DTO Methods DTO.from_model_instance() Once you create a DTO class you can use its class method from_model_instance() to create an instance from an existing instance of the model from which the DTO was generated: from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) company_instance = Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 ) dto_instance = CompanyDTO . from_model_instance ( company_instance ) In the above, dto_instance is a validated pydantic model instance. DTO.to_model_instance() When you have an instance of a DTO model, you can convert it into a model instance using the to_model_instance() method: from starlite import get from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) @get () def create_company ( data : CompanyDTO ) -> Company : return data . to_model_instance () In the above company_instance is an instance of the SQLAlchemy declarative class Company . It is correctly typed as Company because the DTO class uses generic to store this data. Important If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised.","title":"Data Transfer Objects (DTOs)"},{"location":"usage/11-data-transfer-objects/#data-transfer-objects-dtos","text":"Starlite includes a DTOFactory class that allows you to create DTOs from pydantic models, dataclasses, TypedDict , and any other class supported via plugins. An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields. The created DTO can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model. Important Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as DTO[T] , with T being a generic argument representing the original model used to create the DTO. Note MyPy doesn't support using types defined using Type[] as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment. The DTOFactory class supports plugins , for example, this is how it could be used with an SQLAlchemy declarative class using the SQLAlchemyPlugin : from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) The created CompanyDTO is equal to this pydantic model declaration: from pydantic import BaseModel class CompanyDTO ( BaseModel ): id : int name : str worth : float You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future.","title":"Data Transfer Objects (DTOs)"},{"location":"usage/11-data-transfer-objects/#excluding-fields","text":"You can exclude any field in the original model class from the DTO : from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , exclude = [ \"first\" ]) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int","title":"Excluding Fields"},{"location":"usage/11-data-transfer-objects/#remapping-fields","text":"You can remap fields in two ways: you can switch change their keys: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" }) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int third : int You can remap name and type. To do this use a tuple instead of a string for the object value: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" , \"second\" : ( \"fourth\" , float )} ) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): third : int fourth : float","title":"Remapping Fields"},{"location":"usage/11-data-transfer-objects/#add-new-fields","text":"You add fields that do not exist in the original model by passing in a field_definitions dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper : For required fields use a tuple of type + ellipsis, for example (str, ...) . For optional fields use a tuple of type + None , for example (str, None) To set a default value use a tuple of type + default value, for example (str, \"Hello World\") from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_definitions = { \"third\" : ( str , ... )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): first : int second : int third : str","title":"Add New Fields"},{"location":"usage/11-data-transfer-objects/#partial-dtos","text":"For PATCH HTTP methods, you may only need to partially modify a resource. In these cases, DTOs can be wrapped with Partial . from pydantic import BaseModel from starlite.types.partial import Partial class CompanyDTO ( BaseModel ): id : int name : str worth : float PartialCompanyDTO = Partial [ CompanyDTO ] The created PartialCompanyDTO is equivalent to the following declaration: from typing import Optional from pydantic import BaseModel class PartialCompanyDTO ( BaseModel ): id : Optional [ int ] name : Optional [ str ] worth : Optional [ float ] Partial can also be used inline when creating routes. from pydantic import UUID4 , BaseModel from starlite.controller import Controller from starlite.handlers import patch from starlite.types.partial import Partial class UserOrder ( BaseModel ): order_id : UUID4 order_item_id : UUID4 notes : str class UserOrderController ( Controller ): path = \"/user\" @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ...","title":"Partial DTOs"},{"location":"usage/11-data-transfer-objects/#dto-methods","text":"","title":"DTO Methods"},{"location":"usage/11-data-transfer-objects/#dtofrom_model_instance","text":"Once you create a DTO class you can use its class method from_model_instance() to create an instance from an existing instance of the model from which the DTO was generated: from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) company_instance = Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 ) dto_instance = CompanyDTO . from_model_instance ( company_instance ) In the above, dto_instance is a validated pydantic model instance.","title":"DTO.from_model_instance()"},{"location":"usage/11-data-transfer-objects/#dtoto_model_instance","text":"When you have an instance of a DTO model, you can convert it into a model instance using the to_model_instance() method: from starlite import get from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) @get () def create_company ( data : CompanyDTO ) -> Company : return data . to_model_instance () In the above company_instance is an instance of the SQLAlchemy declarative class Company . It is correctly typed as Company because the DTO class uses generic to store this data. Important If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised.","title":"DTO.to_model_instance()"},{"location":"usage/13-lifecycle-hooks/","text":"Life Cycle Hooks Life cycle hooks allows a user to execute a function at a certain point, as indicated by the hook's name, during the request-response cycle. Before Request The before_request hook runs immediately before calling the route handler function. It accepts either a sync or async function that receives the starlite.connection.Request instance as its sole parameter. While the handler function does not need to return a value, if it does return a value other than None , then the route handler will not be called and this value will instead be used for the response. Thus, the before_request handler allows bypassing the route handler selectively. from starlite import Starlite , Request async def my_before_request_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], before_request = my_before_request_handler ) After Request The after_request hook is called after the route handler function returned and the response object has been resolved. It receives either a sync or async function that receives the Response object, which can be either an instance of starlite.response.Response or any subclass of the Starlette Response object. This function must return a Response object - either the one that was passed in, or a different one. The after_response hook allows users to modify responses, e.g. placing cookies or headers on them, or even to completely replace them given certain conditions. from starlite import Starlite , Response async def my_after_request_handler ( response : Response ) -> Response : ... app = Starlite ( route_handlers = [ ... ], after_request = my_after_request_handler ) After Response The after_response hook is called after the response has been awaited, that is - after a response has been sent to the requester. It receives either a sync or async function that receives the Request object. The function should not return any values. This hook is meant for data post-processing, transmission of data to third party services, gathering of metrics etc. from starlite import Starlite , Request async def my_after_response_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], after_response = my_after_response_handler ) Overriding Handlers You can configure life cycle hook handlers on all layers of your application, that is - on the Starlite instance itself, on routers, controllers or individual route handlers. Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level. from starlite import Starlite , Router , Controller , get # this overrides the router and app class MyController ( Controller ): path = \"/my-path\" # this overrides the controller, router and app @get ( after_request =... , before_request =... ) def my_handler ( self ) -> None : ... # this overrides the app, for all routes below the router these functions will be used router = Router ( route_handlers = [ MyController ], after_request =... , before_request =... ) # this is top level app = Starlite ( route_handlers = [ router ], after_request =... , before_request =... )","title":"Life Cycle Hooks"},{"location":"usage/13-lifecycle-hooks/#life-cycle-hooks","text":"Life cycle hooks allows a user to execute a function at a certain point, as indicated by the hook's name, during the request-response cycle.","title":"Life Cycle Hooks"},{"location":"usage/13-lifecycle-hooks/#before-request","text":"The before_request hook runs immediately before calling the route handler function. It accepts either a sync or async function that receives the starlite.connection.Request instance as its sole parameter. While the handler function does not need to return a value, if it does return a value other than None , then the route handler will not be called and this value will instead be used for the response. Thus, the before_request handler allows bypassing the route handler selectively. from starlite import Starlite , Request async def my_before_request_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], before_request = my_before_request_handler )","title":"Before Request"},{"location":"usage/13-lifecycle-hooks/#after-request","text":"The after_request hook is called after the route handler function returned and the response object has been resolved. It receives either a sync or async function that receives the Response object, which can be either an instance of starlite.response.Response or any subclass of the Starlette Response object. This function must return a Response object - either the one that was passed in, or a different one. The after_response hook allows users to modify responses, e.g. placing cookies or headers on them, or even to completely replace them given certain conditions. from starlite import Starlite , Response async def my_after_request_handler ( response : Response ) -> Response : ... app = Starlite ( route_handlers = [ ... ], after_request = my_after_request_handler )","title":"After Request"},{"location":"usage/13-lifecycle-hooks/#after-response","text":"The after_response hook is called after the response has been awaited, that is - after a response has been sent to the requester. It receives either a sync or async function that receives the Request object. The function should not return any values. This hook is meant for data post-processing, transmission of data to third party services, gathering of metrics etc. from starlite import Starlite , Request async def my_after_response_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], after_response = my_after_response_handler )","title":"After Response"},{"location":"usage/13-lifecycle-hooks/#overriding-handlers","text":"You can configure life cycle hook handlers on all layers of your application, that is - on the Starlite instance itself, on routers, controllers or individual route handlers. Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level. from starlite import Starlite , Router , Controller , get # this overrides the router and app class MyController ( Controller ): path = \"/my-path\" # this overrides the controller, router and app @get ( after_request =... , before_request =... ) def my_handler ( self ) -> None : ... # this overrides the app, for all routes below the router these functions will be used router = Router ( route_handlers = [ MyController ], after_request =... , before_request =... ) # this is top level app = Starlite ( route_handlers = [ router ], after_request =... , before_request =... )","title":"Overriding Handlers"},{"location":"usage/14-testing/","text":"Testing Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box. Important Testing utils rely on extra dependencies. So make sure to install them, e.g.: pip install starlite[testing] or poetry install starlite --extras testing Test Client Starlite extends the Starlette testing client, which in turn is built using the httpx library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import TestClient from my_app.main import app def test_health_check (): with TestClient ( app = app ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite.testing import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import TestClient def test_health_check ( test_client : TestClient ): with test_client as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Create Session Cookies If you are using Session Middleware for session persistence across requests then your route handlers may expect preloaded session when mocking the request. To mock request with raw session cookies, you can use TestClient.create_session_cookies . The session middleware will then load the session data from the session cookies that you provide. TestClient.create_session_cookies accepts the following argument: session_data: Dictionary to create raw session cookies from. To use the same session configuration that you have used in your app for session middleware, import SessionCookieConfig instance from your app. tests/test_route_handlers.py import pytest from starlite.testing import TestClient from my_app.main import app , session_cookie_config_instance class TestClass : @pytest . fixture () def test_client ( self ) -> TestClient : with TestClient ( app = app , base_url = \"example.com\" , session_config = session_cookie_config_instance ) as client : yield client def test_something ( self , test_client : TestClient ) -> None : cookies = test_client . create_session_cookies ( session_data = { \"user\" : \"test_user\" }) # Set raw session cookies to the \"cookies\" attribute of test_client instance. test_client . cookies = cookies test_client . get ( url = \"/my_route\" ) Set Cookies With Domain If you have set domain in SessionCookieConfig instance, the domain argument here must take the same parameter. The domain must follow the format specified in RFC 2109, that is, setting a cookie domain without a preceding dot, like, example.com instead of .example.com , is invalid and will not set the cookie. If you have not set domain in SessionCookieConfig , the domain argument here must match with the domain name in the base_url argument of TestClient instance. See the example below. def test_something ( test_client ) -> None : cookies = test_client . create_session_cookies ( session_data = { \"user\" : \"test_user\" }) # Get domain domain = test_client . session . config . domain or test_client . base_url . host # Set cookies for key , value in cookies . items (): test_client . cookies . set ( key = key , value = value , domain = domain ) test_client . get ( url = \"/my_route\" ) Create Session from Raw Cookies If your route handlers modify data in session, you may want to assert session data to confirm the modification. If you are using Session Middleware , the response from the route handlers will include raw session cookies which are a serialized image of the session. To assert data in session, TestClient.get_session_from_cookies method deserializes raw session cookies and creates session from them. tests/test_route_handlers.py import pytest from starlite.testing import TestClient from my_app.main import app , session_cookie_config_instance class TestClass : @pytest . fixture () def test_client ( self ) -> TestClient : with TestClient ( app = app , session_config = session_cookie_config_instance ) as client : yield client def test_something ( self , test_client : TestClient ) -> None : test_client . get ( url = \"/test\" ) session = test_client . get_session_from_cookies () assert \"user\" in session Important The Session Middleware must be enabled in Starlite app provided to the TestClient to use sessions. Important Use the test client as a context manager (i.e. with the with ) keyword if you want to use the Starlite app's on_startup and on_shutdown . Creating a Test App Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Using pydantic-factories Starlite bundles the library pydantic-factories , which offers an easy and powerful way to generate mock data from pydantic models and dataclasses. Let's say we have an API that talks to an external service and retrieves some data: main.py from typing import Protocol , runtime_checkable from pydantic import BaseModel from starlite import get class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get () We could test the /item route like so: tests/conftest.py import pytest from starlette.status import HTTP_200_OK from starlite import Provide , create_test_client from my_app.main import Service , Item , get_item @pytest . fixture () def item (): return Item ( name = \"Chair\" ) def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict () While we can define the test data manually, as is done in the above, this can be quite cumbersome. That's where pydantic-factories library comes in. It generates mock data for pydantic models and dataclasses based on type annotations. With it, we could rewrite the above example like so: main.py from typing import Protocol , runtime_checkable import pytest from pydantic import BaseModel from pydantic_factories import ModelFactory from starlette.status import HTTP_200_OK from starlite import Provide , get from starlite.testing import create_test_client class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get_one ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get_one () class ItemFactory ( ModelFactory [ Item ]): __model__ = Item @pytest . fixture () def item (): return ItemFactory . build () def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict () Creating a Test Request Another helper is the RequestFactory class, which creates instances of starlite.connection.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request , route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException from starlite.testing import RequestFactory from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = RequestFactory () . get ( \"/\" ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) The RequestFactory constructor accepts the following parameters: app : An instance of starlite.app.Starlite . server : The server's domain. Defaults to test.org . port : The server's port. Defaults to 3000 . root_path : Root path for the server. Defaults to / . scheme : Scheme for the server. Defaults to \"http\" . It exposes methods for all supported HTTP methods: RequestFactory().get() RequestFactory().post() RequestFactory().put() RequestFactory().patch() RequestFactory().delete() All of these methods accept the following parameters: path : The request's path. This parameter is required . headers : A dictionary of headers. Defaults to None . cookies : A string representing the cookie header or a list of starlite.datastructures.Cookie instances. This value can include multiple cookies. Defaults to None . session : A dictionary of session data. Defaults to None . user : A value for request.scope[\"user\"] . Defaults to None . auth : A value for request.scope[\"auth\"] . Defaults to None . state : Arbitrary request state. path_params : A string keyed dictionary of path parameter values. http_version : HTTP version. Defaults to \"1.1\". route_handler : A route handler instance or method. If not provided a default handler is set. In addition, the following methods accepts a few more parameters: RequestFactory().get() : query_params : A dictionary of values from which the request's query will be generated. Defaults to None . RequestFactory().post() , RequestFactory().put() , RequestFactory().patch() : request_media_type : The 'Content-Type' header of the request. Defaults to None . data : A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. Defaults to None .","title":"Testing"},{"location":"usage/14-testing/#testing","text":"Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box. Important Testing utils rely on extra dependencies. So make sure to install them, e.g.: pip install starlite[testing] or poetry install starlite --extras testing","title":"Testing"},{"location":"usage/14-testing/#test-client","text":"Starlite extends the Starlette testing client, which in turn is built using the httpx library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import TestClient from my_app.main import app def test_health_check (): with TestClient ( app = app ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite.testing import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import TestClient def test_health_check ( test_client : TestClient ): with test_client as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Test Client"},{"location":"usage/14-testing/#create-session-cookies","text":"If you are using Session Middleware for session persistence across requests then your route handlers may expect preloaded session when mocking the request. To mock request with raw session cookies, you can use TestClient.create_session_cookies . The session middleware will then load the session data from the session cookies that you provide. TestClient.create_session_cookies accepts the following argument: session_data: Dictionary to create raw session cookies from. To use the same session configuration that you have used in your app for session middleware, import SessionCookieConfig instance from your app. tests/test_route_handlers.py import pytest from starlite.testing import TestClient from my_app.main import app , session_cookie_config_instance class TestClass : @pytest . fixture () def test_client ( self ) -> TestClient : with TestClient ( app = app , base_url = \"example.com\" , session_config = session_cookie_config_instance ) as client : yield client def test_something ( self , test_client : TestClient ) -> None : cookies = test_client . create_session_cookies ( session_data = { \"user\" : \"test_user\" }) # Set raw session cookies to the \"cookies\" attribute of test_client instance. test_client . cookies = cookies test_client . get ( url = \"/my_route\" )","title":"Create Session Cookies"},{"location":"usage/14-testing/#set-cookies-with-domain","text":"If you have set domain in SessionCookieConfig instance, the domain argument here must take the same parameter. The domain must follow the format specified in RFC 2109, that is, setting a cookie domain without a preceding dot, like, example.com instead of .example.com , is invalid and will not set the cookie. If you have not set domain in SessionCookieConfig , the domain argument here must match with the domain name in the base_url argument of TestClient instance. See the example below. def test_something ( test_client ) -> None : cookies = test_client . create_session_cookies ( session_data = { \"user\" : \"test_user\" }) # Get domain domain = test_client . session . config . domain or test_client . base_url . host # Set cookies for key , value in cookies . items (): test_client . cookies . set ( key = key , value = value , domain = domain ) test_client . get ( url = \"/my_route\" )","title":"Set Cookies With Domain"},{"location":"usage/14-testing/#create-session-from-raw-cookies","text":"If your route handlers modify data in session, you may want to assert session data to confirm the modification. If you are using Session Middleware , the response from the route handlers will include raw session cookies which are a serialized image of the session. To assert data in session, TestClient.get_session_from_cookies method deserializes raw session cookies and creates session from them. tests/test_route_handlers.py import pytest from starlite.testing import TestClient from my_app.main import app , session_cookie_config_instance class TestClass : @pytest . fixture () def test_client ( self ) -> TestClient : with TestClient ( app = app , session_config = session_cookie_config_instance ) as client : yield client def test_something ( self , test_client : TestClient ) -> None : test_client . get ( url = \"/test\" ) session = test_client . get_session_from_cookies () assert \"user\" in session Important The Session Middleware must be enabled in Starlite app provided to the TestClient to use sessions. Important Use the test client as a context manager (i.e. with the with ) keyword if you want to use the Starlite app's on_startup and on_shutdown .","title":"Create Session from Raw Cookies"},{"location":"usage/14-testing/#creating-a-test-app","text":"Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Creating a Test App"},{"location":"usage/14-testing/#using-pydantic-factories","text":"Starlite bundles the library pydantic-factories , which offers an easy and powerful way to generate mock data from pydantic models and dataclasses. Let's say we have an API that talks to an external service and retrieves some data: main.py from typing import Protocol , runtime_checkable from pydantic import BaseModel from starlite import get class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get () We could test the /item route like so: tests/conftest.py import pytest from starlette.status import HTTP_200_OK from starlite import Provide , create_test_client from my_app.main import Service , Item , get_item @pytest . fixture () def item (): return Item ( name = \"Chair\" ) def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict () While we can define the test data manually, as is done in the above, this can be quite cumbersome. That's where pydantic-factories library comes in. It generates mock data for pydantic models and dataclasses based on type annotations. With it, we could rewrite the above example like so: main.py from typing import Protocol , runtime_checkable import pytest from pydantic import BaseModel from pydantic_factories import ModelFactory from starlette.status import HTTP_200_OK from starlite import Provide , get from starlite.testing import create_test_client class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get_one ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get_one () class ItemFactory ( ModelFactory [ Item ]): __model__ = Item @pytest . fixture () def item (): return ItemFactory . build () def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict ()","title":"Using pydantic-factories"},{"location":"usage/14-testing/#creating-a-test-request","text":"Another helper is the RequestFactory class, which creates instances of starlite.connection.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request , route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException from starlite.testing import RequestFactory from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = RequestFactory () . get ( \"/\" ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) The RequestFactory constructor accepts the following parameters: app : An instance of starlite.app.Starlite . server : The server's domain. Defaults to test.org . port : The server's port. Defaults to 3000 . root_path : Root path for the server. Defaults to / . scheme : Scheme for the server. Defaults to \"http\" . It exposes methods for all supported HTTP methods: RequestFactory().get() RequestFactory().post() RequestFactory().put() RequestFactory().patch() RequestFactory().delete() All of these methods accept the following parameters: path : The request's path. This parameter is required . headers : A dictionary of headers. Defaults to None . cookies : A string representing the cookie header or a list of starlite.datastructures.Cookie instances. This value can include multiple cookies. Defaults to None . session : A dictionary of session data. Defaults to None . user : A value for request.scope[\"user\"] . Defaults to None . auth : A value for request.scope[\"auth\"] . Defaults to None . state : Arbitrary request state. path_params : A string keyed dictionary of path parameter values. http_version : HTTP version. Defaults to \"1.1\". route_handler : A route handler instance or method. If not provided a default handler is set. In addition, the following methods accepts a few more parameters: RequestFactory().get() : query_params : A dictionary of values from which the request's query will be generated. Defaults to None . RequestFactory().post() , RequestFactory().put() , RequestFactory().patch() : request_media_type : The 'Content-Type' header of the request. Defaults to None . data : A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. Defaults to None .","title":"Creating a Test Request"},{"location":"usage/17-exceptions/","text":"Exceptions and Exception Handling Starlite define a base error called StarliteException which serves as a basis to all other exceptions. In general, Starlite will raise two types of exceptions - exceptions that arise during application init, which fall under the broad scope of configurations errors, and exceptions that are raised as part of the normal application flow, i.e. exceptions in route handlers, dependencies and middleware that should be serialized in some fashion. Configuration Exceptions For missing extra dependencies, Starlite will raise either MissingDependencyException . For example, if you try to use the SQLAlchemyPLugin without having SQLAlchemy installed, this will be raised when you start the application. For other configuration issues, Starlite will raise ImproperlyConfiguredException with a message explaining the issue. Application Exceptions For application exceptions, Starlite uses the class HTTPException , which inherits from both StarliteException and starlette.exceptions.HTTPException . See the API Reference for full details on the HTTPException class and the kwargs it accepts. { \"status_code\" : 500 , \"detail\" : \"Internal Server Error\" , \"extra\" : {} } Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use, such as: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503. When a value fails pydantic validation, the result will be a ValidationException with the extra key set to the pydantic validation errors. Thus, this data will be made available for the API consumers by default. See the API Reference section for exceptions for full reference. Exception Handling Starlite handles all errors by default by transforming them into JSON responses . If the errors are instances of either the starlette.exceptions.HTTPException or the starlite.exceptions.HTTPException , the responses will include the appropriate status_code . Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary \u2013 mapping either error status codes , or exception classes , to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, ) The above will define a top level exception handler that will apply the plain_text_exception_handler function to all exceptions that inherit from HTTPException . You could of course be more granular: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import ValidationException , Request , Response , Starlite def first_exception_handler ( request : Request , exc : Exception ) -> Response : ... def second_exception_handler ( request : Request , exc : Exception ) -> Response : ... def third_exception_handler ( request : Request , exc : Exception ) -> Response : ... app = Starlite ( route_handlers = [ ... ], exception_handlers = { ValidationException : first_exception_handler , HTTP_500_INTERNAL_SERVER_ERROR : second_exception_handler , ValueError : third_exception_handler , }, ) The choice whether to use a single function that has switching logic inside it, or multiple functions depends on your specific needs. While it does not make much sense to have different functions with a top-level exception handling, Starlite supports defining exception handlers on all levels of the app, with the lower levels overriding levels above them. Thus, in the following example, the exception handler for the route handler function will handle the ValidationException related to it: from starlite import ( HTTPException , ValidationException , Request , Response , Starlite , get , ) def top_level_handler ( request : Request , exc : Exception ) -> Response : ... def handler_level_handler ( request : Request , exc : Exception ) -> Response : ... @get ( \"/greet\" , exception_handlers = { ValidationException : top_level_handler }) def my_route_handler ( name : str ) -> str : return f \"hello { name } \" app = Starlite ( route_handlers = [ my_route_handler ], exception_handlers = { HTTPException : top_level_handler }, ) Exception Handling Layers Since Starlite allows users to define both exception handlers and middlewares in a layered fashion, i.e. on individual route handlers, controllers, routers or the app layer, multiple layers of exception handlers are required to ensure that exceptions are handled correctly: Exception Handlers Because of the above structure, the exceptions raised by the ASGI Router itself, namely 404 Not Found and 405 Method Not Allowed are handled only by exception handlers defined on the app layer. Thus, if you want to affect these exceptions, you will need to pass the exception handlers for them to the Starlite constructor and cannot use other layers for this purpose. Examples Logging Exception Handler Note The create_exception_response function is used internally to produce default error responses if no handler has been registered to a route. This is available as part of the public API of Starlite so that you can apply it wherever necessary to ensure consistent error responses across your application. import logging from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlette.responses import Response from starlite.utils import create_exception_response from starlite.types import Request from starlite import Starlite logger = logging . getLogger ( __name__ ) def logging_exception_handler ( request : Request , exc : Exception ) -> Response : \"\"\" Logs exception and returns appropriate response. Parameters ---------- request : Request The request that caused the exception. exc : The exception caught by the Starlite exception handling middleware and passed to the callback. Returns ------- Response \"\"\" logger . error ( \"Application Exception\" , exc_info = exc ) return create_exception_response ( exc ) app = Starlite ( ... , exception_handlers = { HTTP_500_INTERNAL_SERVER_ERROR : logging_exception_handler }, )","title":"Exceptions and Exception Handling"},{"location":"usage/17-exceptions/#exceptions-and-exception-handling","text":"Starlite define a base error called StarliteException which serves as a basis to all other exceptions. In general, Starlite will raise two types of exceptions - exceptions that arise during application init, which fall under the broad scope of configurations errors, and exceptions that are raised as part of the normal application flow, i.e. exceptions in route handlers, dependencies and middleware that should be serialized in some fashion.","title":"Exceptions and Exception Handling"},{"location":"usage/17-exceptions/#configuration-exceptions","text":"For missing extra dependencies, Starlite will raise either MissingDependencyException . For example, if you try to use the SQLAlchemyPLugin without having SQLAlchemy installed, this will be raised when you start the application. For other configuration issues, Starlite will raise ImproperlyConfiguredException with a message explaining the issue.","title":"Configuration Exceptions"},{"location":"usage/17-exceptions/#application-exceptions","text":"For application exceptions, Starlite uses the class HTTPException , which inherits from both StarliteException and starlette.exceptions.HTTPException . See the API Reference for full details on the HTTPException class and the kwargs it accepts. { \"status_code\" : 500 , \"detail\" : \"Internal Server Error\" , \"extra\" : {} } Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use, such as: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503. When a value fails pydantic validation, the result will be a ValidationException with the extra key set to the pydantic validation errors. Thus, this data will be made available for the API consumers by default. See the API Reference section for exceptions for full reference.","title":"Application Exceptions"},{"location":"usage/17-exceptions/#exception-handling","text":"Starlite handles all errors by default by transforming them into JSON responses . If the errors are instances of either the starlette.exceptions.HTTPException or the starlite.exceptions.HTTPException , the responses will include the appropriate status_code . Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary \u2013 mapping either error status codes , or exception classes , to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, ) The above will define a top level exception handler that will apply the plain_text_exception_handler function to all exceptions that inherit from HTTPException . You could of course be more granular: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import ValidationException , Request , Response , Starlite def first_exception_handler ( request : Request , exc : Exception ) -> Response : ... def second_exception_handler ( request : Request , exc : Exception ) -> Response : ... def third_exception_handler ( request : Request , exc : Exception ) -> Response : ... app = Starlite ( route_handlers = [ ... ], exception_handlers = { ValidationException : first_exception_handler , HTTP_500_INTERNAL_SERVER_ERROR : second_exception_handler , ValueError : third_exception_handler , }, ) The choice whether to use a single function that has switching logic inside it, or multiple functions depends on your specific needs. While it does not make much sense to have different functions with a top-level exception handling, Starlite supports defining exception handlers on all levels of the app, with the lower levels overriding levels above them. Thus, in the following example, the exception handler for the route handler function will handle the ValidationException related to it: from starlite import ( HTTPException , ValidationException , Request , Response , Starlite , get , ) def top_level_handler ( request : Request , exc : Exception ) -> Response : ... def handler_level_handler ( request : Request , exc : Exception ) -> Response : ... @get ( \"/greet\" , exception_handlers = { ValidationException : top_level_handler }) def my_route_handler ( name : str ) -> str : return f \"hello { name } \" app = Starlite ( route_handlers = [ my_route_handler ], exception_handlers = { HTTPException : top_level_handler }, )","title":"Exception Handling"},{"location":"usage/17-exceptions/#exception-handling-layers","text":"Since Starlite allows users to define both exception handlers and middlewares in a layered fashion, i.e. on individual route handlers, controllers, routers or the app layer, multiple layers of exception handlers are required to ensure that exceptions are handled correctly: Exception Handlers Because of the above structure, the exceptions raised by the ASGI Router itself, namely 404 Not Found and 405 Method Not Allowed are handled only by exception handlers defined on the app layer. Thus, if you want to affect these exceptions, you will need to pass the exception handlers for them to the Starlite constructor and cannot use other layers for this purpose.","title":"Exception Handling Layers"},{"location":"usage/17-exceptions/#examples","text":"","title":"Examples"},{"location":"usage/17-exceptions/#logging-exception-handler","text":"Note The create_exception_response function is used internally to produce default error responses if no handler has been registered to a route. This is available as part of the public API of Starlite so that you can apply it wherever necessary to ensure consistent error responses across your application. import logging from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlette.responses import Response from starlite.utils import create_exception_response from starlite.types import Request from starlite import Starlite logger = logging . getLogger ( __name__ ) def logging_exception_handler ( request : Request , exc : Exception ) -> Response : \"\"\" Logs exception and returns appropriate response. Parameters ---------- request : Request The request that caused the exception. exc : The exception caught by the Starlite exception handling middleware and passed to the callback. Returns ------- Response \"\"\" logger . error ( \"Application Exception\" , exc_info = exc ) return create_exception_response ( exc ) app = Starlite ( ... , exception_handlers = { HTTP_500_INTERNAL_SERVER_ERROR : logging_exception_handler }, )","title":"Logging Exception Handler"},{"location":"usage/9-guards/","text":"Guards Guards are callables that receive two arguments - request , which is the Request instance, and route_handler , which is a copy of the BaseRouteHandler model. Their role is to authorize the request by verifying that the request is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: from pydantic import BaseModel , UUID4 from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers and then add it to a route handler function: from starlite import Request , BaseRouteHandler , NotAuthorizedException from pydantic import BaseModel , UUID4 from starlite import post from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN def admin_user_guard ( request : Request [ User ], _ : BaseRouteHandler ) -> None : if not request . user . is_admin : raise NotAuthorizedException () @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler. Guard Scopes Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import Controller , Router , Starlite , Request , BaseRouteHandler def my_guard ( request : Request , handler : BaseRouteHandler ) -> None : ... # controller class UserController ( Controller ): path = \"/user\" guards = [ my_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ my_guard ]) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ my_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine. The Route Handler \"opt\" Key Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. To this end, all route handler decorators can receive the kwarg opt which adds a dictionary of arbitrary values to the route handler. For example: from starlite import get @get ( path = \"/\" , opt = { \"permissions\" : [ ... ]}) def my_route_handler () -> None : ... To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: from starlite import Request , BaseRouteHandler , NotAuthorizedException , get from os import environ def secret_token_guard ( request : Request , route_handler : BaseRouteHandler ) -> None : if ( route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ] ): raise NotAuthorizedException () @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"Guards"},{"location":"usage/9-guards/#guards","text":"Guards are callables that receive two arguments - request , which is the Request instance, and route_handler , which is a copy of the BaseRouteHandler model. Their role is to authorize the request by verifying that the request is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: from pydantic import BaseModel , UUID4 from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers and then add it to a route handler function: from starlite import Request , BaseRouteHandler , NotAuthorizedException from pydantic import BaseModel , UUID4 from starlite import post from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN def admin_user_guard ( request : Request [ User ], _ : BaseRouteHandler ) -> None : if not request . user . is_admin : raise NotAuthorizedException () @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler.","title":"Guards"},{"location":"usage/9-guards/#guard-scopes","text":"Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import Controller , Router , Starlite , Request , BaseRouteHandler def my_guard ( request : Request , handler : BaseRouteHandler ) -> None : ... # controller class UserController ( Controller ): path = \"/user\" guards = [ my_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ my_guard ]) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ my_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine.","title":"Guard Scopes"},{"location":"usage/9-guards/#the-route-handler-opt-key","text":"Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. To this end, all route handler decorators can receive the kwarg opt which adds a dictionary of arbitrary values to the route handler. For example: from starlite import get @get ( path = \"/\" , opt = { \"permissions\" : [ ... ]}) def my_route_handler () -> None : ... To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: from starlite import Request , BaseRouteHandler , NotAuthorizedException , get from os import environ def secret_token_guard ( request : Request , route_handler : BaseRouteHandler ) -> None : if ( route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ] ): raise NotAuthorizedException () @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"The Route Handler \"opt\" Key"},{"location":"usage/0-the-starlite-app/0-the-starlite-app/","text":"The Starlite App At the root of every Starlite application is an instance of the Starlite class or a subclass of it. Typically, this code will be placed in a file called main.py at the project's root directory . Creating an app is straightforward \u2013 the only required arg is a list of Controllers , Routers or Route Handlers : Important This example requires Python 3.9 or later. Hello World \"\"\"Minimal Starlite application.\"\"\" from starlite import Starlite , get @get ( \"/\" ) def hello_world () -> dict [ str , str ]: \"\"\"Handler function that returns a greeting dictionary.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ hello_world ]) The app instance is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. See registering routes for full details. See the API Reference for full details on the Starlite class and the kwargs it accepts.","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/0-the-starlite-app/#the-starlite-app","text":"At the root of every Starlite application is an instance of the Starlite class or a subclass of it. Typically, this code will be placed in a file called main.py at the project's root directory . Creating an app is straightforward \u2013 the only required arg is a list of Controllers , Routers or Route Handlers : Important This example requires Python 3.9 or later. Hello World \"\"\"Minimal Starlite application.\"\"\" from starlite import Starlite , get @get ( \"/\" ) def hello_world () -> dict [ str , str ]: \"\"\"Handler function that returns a greeting dictionary.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ hello_world ]) The app instance is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. See registering routes for full details. See the API Reference for full details on the Starlite class and the kwargs it accepts.","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/1-startup-and-shutdown/","text":"Startup and Shutdown You can pass a list of callables - either sync or async functions, methods or class instances - using the on_startup / on_shutdown kwargs of the Starlite constructor. The callables will be called in their respective order in the list once the ASGI server (uvicorn, daphne etc.) emits the respective event. Example A classic use case for this is database connectivity. Often, we want to establish a database connection on application startup, and then close it gracefully upon shutdown. For example, lets create a database connection using the async engine from SQLAlchemy . We create two functions, one to get or establish the connection, and another to close it, and then pass them to the Starlite constructor: Startup and Shutdown from typing import cast from pydantic import BaseSettings from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite import Starlite , State class AppSettings ( BaseSettings ): DATABASE_URI : str = \"postgresql+asyncpg://postgres:mysecretpassword@pg.db:5432/db\" settings = AppSettings () def get_db_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the db engine. If it doesn't exist, creates it and saves it in on the application state object \"\"\" if not getattr ( state , \"engine\" , None ): state . engine = create_async_engine ( settings . DATABASE_URI ) return cast ( \"AsyncEngine\" , state . engine ) async def close_db_connection ( state : State ) -> None : \"\"\"Closes the db connection stored in the application State object.\"\"\" if getattr ( state , \"engine\" , None ): await cast ( \"AsyncEngine\" , state . engine ) . dispose () app = Starlite ( route_handlers = [], on_startup = [ get_db_connection ], on_shutdown = [ close_db_connection ])","title":"Startup and Shutdown"},{"location":"usage/0-the-starlite-app/1-startup-and-shutdown/#startup-and-shutdown","text":"You can pass a list of callables - either sync or async functions, methods or class instances - using the on_startup / on_shutdown kwargs of the Starlite constructor. The callables will be called in their respective order in the list once the ASGI server (uvicorn, daphne etc.) emits the respective event.","title":"Startup and Shutdown"},{"location":"usage/0-the-starlite-app/1-startup-and-shutdown/#example","text":"A classic use case for this is database connectivity. Often, we want to establish a database connection on application startup, and then close it gracefully upon shutdown. For example, lets create a database connection using the async engine from SQLAlchemy . We create two functions, one to get or establish the connection, and another to close it, and then pass them to the Starlite constructor: Startup and Shutdown from typing import cast from pydantic import BaseSettings from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite import Starlite , State class AppSettings ( BaseSettings ): DATABASE_URI : str = \"postgresql+asyncpg://postgres:mysecretpassword@pg.db:5432/db\" settings = AppSettings () def get_db_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the db engine. If it doesn't exist, creates it and saves it in on the application state object \"\"\" if not getattr ( state , \"engine\" , None ): state . engine = create_async_engine ( settings . DATABASE_URI ) return cast ( \"AsyncEngine\" , state . engine ) async def close_db_connection ( state : State ) -> None : \"\"\"Closes the db connection stored in the application State object.\"\"\" if getattr ( state , \"engine\" , None ): await cast ( \"AsyncEngine\" , state . engine ) . dispose () app = Starlite ( route_handlers = [], on_startup = [ get_db_connection ], on_shutdown = [ close_db_connection ])","title":"Example"},{"location":"usage/0-the-starlite-app/2-using-application-state/","text":"Using Application State As seen in the examples for the on_startup / on_shutdown hooks , callables passed to these hooks can receive an optional kwarg called state , which is the application's state object. The advantage of using application state , is that it can be accessed during multiple stages of the connection, and it can be injected into dependencies and route handlers. The Application State is an instance of starlite.datastructures.State which inherits from starlette.datastructures.State . It is accessible via Starlite.state and it can be accessed via any application reference, such as: starlite.connection.ASGIConnection.app.state (accessible inside middleware - see the example below). ASGIConnection.app Request.app Websocket.app The following complete example demonstrates different patterns of accessing Application State: Using Application State import logging from typing import TYPE_CHECKING , Any from starlite import Provide , Request , Starlite , State , get if TYPE_CHECKING : from starlite.types import ASGIApp , Receive , Scope , Send logger = logging . getLogger ( __name__ ) def set_state_on_startup ( state : State ) -> None : \"\"\"Startup and shutdown hooks can receive `State` as a keyword arg.\"\"\" state . value = \"abc123\" def middleware_factory ( * , app : \"ASGIApp\" ) -> \"ASGIApp\" : \"\"\"A middleware can access application state via `scope`.\"\"\" async def my_middleware ( scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : state = scope [ \"app\" ] . state logger . info ( \"state value in middleware: %s \" , state . value ) await app ( scope , receive , send ) return my_middleware def my_dependency ( state : State ) -> Any : \"\"\"Dependencies can receive state via injection.\"\"\" logger . info ( \"state value in dependency: %s \" , state . value ) @get ( \"/\" , dependencies = { \"dep\" : Provide ( my_dependency )}, middleware = [ middleware_factory ]) def get_handler ( state : State , request : Request , dep : Any ) -> None : # pylint: disable=unused-argument \"\"\"Handlers can receive state via injection.\"\"\" logger . info ( \"state value in handler from `State`: %s \" , state . value ) logger . info ( \"state value in handler from `Request`: %s \" , request . app . state . value ) starlite = Starlite ( route_handlers = [ get_handler ], on_startup = [ set_state_on_startup ], debug = True ) Also, see handler function kwargs .","title":"Using Application State"},{"location":"usage/0-the-starlite-app/2-using-application-state/#using-application-state","text":"As seen in the examples for the on_startup / on_shutdown hooks , callables passed to these hooks can receive an optional kwarg called state , which is the application's state object. The advantage of using application state , is that it can be accessed during multiple stages of the connection, and it can be injected into dependencies and route handlers. The Application State is an instance of starlite.datastructures.State which inherits from starlette.datastructures.State . It is accessible via Starlite.state and it can be accessed via any application reference, such as: starlite.connection.ASGIConnection.app.state (accessible inside middleware - see the example below). ASGIConnection.app Request.app Websocket.app The following complete example demonstrates different patterns of accessing Application State: Using Application State import logging from typing import TYPE_CHECKING , Any from starlite import Provide , Request , Starlite , State , get if TYPE_CHECKING : from starlite.types import ASGIApp , Receive , Scope , Send logger = logging . getLogger ( __name__ ) def set_state_on_startup ( state : State ) -> None : \"\"\"Startup and shutdown hooks can receive `State` as a keyword arg.\"\"\" state . value = \"abc123\" def middleware_factory ( * , app : \"ASGIApp\" ) -> \"ASGIApp\" : \"\"\"A middleware can access application state via `scope`.\"\"\" async def my_middleware ( scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : state = scope [ \"app\" ] . state logger . info ( \"state value in middleware: %s \" , state . value ) await app ( scope , receive , send ) return my_middleware def my_dependency ( state : State ) -> Any : \"\"\"Dependencies can receive state via injection.\"\"\" logger . info ( \"state value in dependency: %s \" , state . value ) @get ( \"/\" , dependencies = { \"dep\" : Provide ( my_dependency )}, middleware = [ middleware_factory ]) def get_handler ( state : State , request : Request , dep : Any ) -> None : # pylint: disable=unused-argument \"\"\"Handlers can receive state via injection.\"\"\" logger . info ( \"state value in handler from `State`: %s \" , state . value ) logger . info ( \"state value in handler from `Request`: %s \" , request . app . state . value ) starlite = Starlite ( route_handlers = [ get_handler ], on_startup = [ set_state_on_startup ], debug = True ) Also, see handler function kwargs .","title":"Using Application State"},{"location":"usage/0-the-starlite-app/3-static-files/","text":"Static Files Static files are served by the app from predefined locations. To configure static file serving, either pass an instance of starlite.config.StaticFilesConfig or a list thereof to the Starlite constructor using the static_files_config kwarg. For example, lets say our Starlite app is going to serve regular files from the my_app/static folder and html documents from the my_app/html folder, and we would like to serve the static files on the /files path, and the html files on the /html path: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/files\" ), StaticFilesConfig ( directories = [ \"html\" ], path = \"/html\" , html_mode = True ), ], ) Matching is done based on filename: Assumed we have a request that is trying to retrieve the path /files/file.txt , the directory for the base path /files will be searched for the file file.txt . If it is found, the file will be sent over, otherwise a 404 response will be sent. If html_mode is enabled and no specific file is requested, the application will fall back to serving index.html . If no file is found the application will look for a 404.html file in order to render a response, otherwise a 404 NotFoundException will be returned. You can provide name parameter to StaticFilesConfig to identify given config and generate links to files in folders belonging to that config. name should be a unique string across all static configs and route handlers from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/some_folder/static/path\" , name = \"static\" ), ], ) url_path = app . url_for_static_asset ( \"static\" , \"file.pdf\" ) # /some_folder/static/path/file.pdf","title":"Static Files"},{"location":"usage/0-the-starlite-app/3-static-files/#static-files","text":"Static files are served by the app from predefined locations. To configure static file serving, either pass an instance of starlite.config.StaticFilesConfig or a list thereof to the Starlite constructor using the static_files_config kwarg. For example, lets say our Starlite app is going to serve regular files from the my_app/static folder and html documents from the my_app/html folder, and we would like to serve the static files on the /files path, and the html files on the /html path: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/files\" ), StaticFilesConfig ( directories = [ \"html\" ], path = \"/html\" , html_mode = True ), ], ) Matching is done based on filename: Assumed we have a request that is trying to retrieve the path /files/file.txt , the directory for the base path /files will be searched for the file file.txt . If it is found, the file will be sent over, otherwise a 404 response will be sent. If html_mode is enabled and no specific file is requested, the application will fall back to serving index.html . If no file is found the application will look for a 404.html file in order to render a response, otherwise a 404 NotFoundException will be returned. You can provide name parameter to StaticFilesConfig to identify given config and generate links to files in folders belonging to that config. name should be a unique string across all static configs and route handlers from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/some_folder/static/path\" , name = \"static\" ), ], ) url_path = app . url_for_static_asset ( \"static\" , \"file.pdf\" ) # /some_folder/static/path/file.pdf","title":"Static Files"},{"location":"usage/0-the-starlite-app/4-logging/","text":"Logging Starlite has builtin pydantic based logging configuration that allows users to easily define logging: from starlite import Starlite , LoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . log ( \"inside a request\" ) return None logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], } } ) app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config ) Important Starlite configures a non-blocking QueueListenerHandler which is keyed as queue_listener in the logging configuration. The above example is using this handler, which is optimal for async applications. Make sure to use it in your own loggers as in the above example. Using Picologging Picologging is a high performance logging library that is developed by Microsoft. Starlite will default to using this library automatically if its installed - requiring zero configuration on the part of the user. That is, if picologging is present the previous example will work with it automatically. Using StructLog StructLog is a powerful structured-logging library. Starlite ships with a dedicated logging config for using it: from starlite import Starlite , StructLoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . log ( \"inside a request\" ) return None logging_config = StructLoggingConfig () app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config ) Subclass Logging Configs You can easily create you own LoggingConfig class by subclassing starlite.config.logging.BaseLoggingConfig and implementing the configure method.","title":"Logging"},{"location":"usage/0-the-starlite-app/4-logging/#logging","text":"Starlite has builtin pydantic based logging configuration that allows users to easily define logging: from starlite import Starlite , LoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . log ( \"inside a request\" ) return None logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], } } ) app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config ) Important Starlite configures a non-blocking QueueListenerHandler which is keyed as queue_listener in the logging configuration. The above example is using this handler, which is optimal for async applications. Make sure to use it in your own loggers as in the above example.","title":"Logging"},{"location":"usage/0-the-starlite-app/4-logging/#using-picologging","text":"Picologging is a high performance logging library that is developed by Microsoft. Starlite will default to using this library automatically if its installed - requiring zero configuration on the part of the user. That is, if picologging is present the previous example will work with it automatically.","title":"Using Picologging"},{"location":"usage/0-the-starlite-app/4-logging/#using-structlog","text":"StructLog is a powerful structured-logging library. Starlite ships with a dedicated logging config for using it: from starlite import Starlite , StructLoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . log ( \"inside a request\" ) return None logging_config = StructLoggingConfig () app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config )","title":"Using StructLog"},{"location":"usage/0-the-starlite-app/4-logging/#subclass-logging-configs","text":"You can easily create you own LoggingConfig class by subclassing starlite.config.logging.BaseLoggingConfig and implementing the configure method.","title":"Subclass Logging Configs"},{"location":"usage/0-the-starlite-app/5-application-hooks/","text":"Application Hooks Starlite includes several application level hooks that allow users to run their own sync or async callables. While you are free to use these hooks as you see fit, the design intention behind them is to allow for easy instrumentation for observability (monitoring, tracing, logging etc.). Note All application hook kwargs detailed below receive either a single callable or a list of callables. If a list is provided, it is called in the order it is given. Hooks: Before / After Startup The before_startup and after_startup hooks take a sync or async callable that receives the Starlite application as an argument and run during the ASGI startup event. The callable is invoked respectively before or after the list of callables defined in the on_startup list of callables. Before and After Startup Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def startup_callable () -> None : \"\"\"Function called during 'on_startup'.\"\"\" await sleep ( 0.5 ) def before_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_startup'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"startup sequence begin at %s \" , start_time . isoformat ()) def after_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_startup'.\"\"\" logger . info ( \"startup sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_startup = [ startup_callable ], before_startup = before_startup_handler , after_startup = after_startup_handler , ) Before / After Shutdown The before_shutdown and after_shutdown are basically identical, with the difference being that the callable they receive in callable is invoked respectively before or after the list of callables defined in the on_shutdown list of callables. Before and After Shutdown Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def shutdown_callable () -> None : \"\"\"Function called during 'on_shutdown'.\"\"\" await sleep ( 0.5 ) def before_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_shutdown'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"shutdown sequence begin at %s \" , start_time . isoformat ()) def after_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_shutdown'.\"\"\" logger . info ( \"shutdown sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_shutdown = [ shutdown_callable ], before_shutdown = before_shutdown_handler , after_shutdown = after_shutdown_handler , ) After Exception The after_exception hook takes a sync or async callable that is called with three arguments: the exception that occurred, the ASGI scope of the request or websocket connection and the application state . After Exception Hook import logging from typing import TYPE_CHECKING from starlette.status import HTTP_400_BAD_REQUEST from starlite import HTTPException , Starlite , get logger = logging . getLogger () if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Scope @get ( \"/some-path\" ) def my_handler () -> None : \"\"\"Route handler that raises an exception.\"\"\" raise HTTPException ( detail = \"bad request\" , status_code = HTTP_400_BAD_REQUEST ) async def after_exception_handler ( exc : Exception , scope : \"Scope\" , state : \"State\" ) -> None : \"\"\"Hook function that will be invoked after each exception.\"\"\" if not hasattr ( state , \"error_count\" ): state . error_count = 1 else : state . error_count += 1 logger . info ( \"an exception of type %s has occurred for requested path %s and the application error count is %d .\" , type ( exc ) . __name__ , scope [ \"path\" ], state . error_count , ) app = Starlite ([ my_handler ], after_exception = after_exception_handler ) Important This hook is not meant to handle exceptions - it just receives them to allow for side effects. To handle exceptions you should define exception handlers . Before Send The before_send hook takes a sync or async callable that is called when an ASGI message is sent. The hook receives the message instance and the application state. Before Send Hook from typing import TYPE_CHECKING , Dict from starlette.datastructures import MutableHeaders from starlite import Starlite , get if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Message @get ( \"/test\" ) def handler () -> Dict [ str , str ]: \"\"\"Example Handler function.\"\"\" return { \"key\" : \"value\" } async def before_send_hook_handler ( message : \"Message\" , state : \"State\" ) -> None : \"\"\"The function will be called on each ASGI message. We therefore ensure it runs only on the message start event. \"\"\" if message [ \"type\" ] == \"http.response.start\" : headers = MutableHeaders ( scope = message ) headers . append ( \"My Header\" , state . message ) def on_startup ( state : \"State\" ) -> None : \"\"\"A function that will populate the app state before any requests are received.\"\"\" state . message = \"value injected during send\" app = Starlite ( route_handlers = [ handler ], on_startup = [ on_startup ], before_send = before_send_hook_handler )","title":"Application Hooks"},{"location":"usage/0-the-starlite-app/5-application-hooks/#application-hooks","text":"Starlite includes several application level hooks that allow users to run their own sync or async callables. While you are free to use these hooks as you see fit, the design intention behind them is to allow for easy instrumentation for observability (monitoring, tracing, logging etc.). Note All application hook kwargs detailed below receive either a single callable or a list of callables. If a list is provided, it is called in the order it is given. Hooks:","title":"Application Hooks"},{"location":"usage/0-the-starlite-app/5-application-hooks/#before-after-startup","text":"The before_startup and after_startup hooks take a sync or async callable that receives the Starlite application as an argument and run during the ASGI startup event. The callable is invoked respectively before or after the list of callables defined in the on_startup list of callables. Before and After Startup Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def startup_callable () -> None : \"\"\"Function called during 'on_startup'.\"\"\" await sleep ( 0.5 ) def before_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_startup'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"startup sequence begin at %s \" , start_time . isoformat ()) def after_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_startup'.\"\"\" logger . info ( \"startup sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_startup = [ startup_callable ], before_startup = before_startup_handler , after_startup = after_startup_handler , )","title":"Before / After Startup"},{"location":"usage/0-the-starlite-app/5-application-hooks/#before-after-shutdown","text":"The before_shutdown and after_shutdown are basically identical, with the difference being that the callable they receive in callable is invoked respectively before or after the list of callables defined in the on_shutdown list of callables. Before and After Shutdown Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def shutdown_callable () -> None : \"\"\"Function called during 'on_shutdown'.\"\"\" await sleep ( 0.5 ) def before_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_shutdown'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"shutdown sequence begin at %s \" , start_time . isoformat ()) def after_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_shutdown'.\"\"\" logger . info ( \"shutdown sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_shutdown = [ shutdown_callable ], before_shutdown = before_shutdown_handler , after_shutdown = after_shutdown_handler , )","title":"Before / After Shutdown"},{"location":"usage/0-the-starlite-app/5-application-hooks/#after-exception","text":"The after_exception hook takes a sync or async callable that is called with three arguments: the exception that occurred, the ASGI scope of the request or websocket connection and the application state . After Exception Hook import logging from typing import TYPE_CHECKING from starlette.status import HTTP_400_BAD_REQUEST from starlite import HTTPException , Starlite , get logger = logging . getLogger () if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Scope @get ( \"/some-path\" ) def my_handler () -> None : \"\"\"Route handler that raises an exception.\"\"\" raise HTTPException ( detail = \"bad request\" , status_code = HTTP_400_BAD_REQUEST ) async def after_exception_handler ( exc : Exception , scope : \"Scope\" , state : \"State\" ) -> None : \"\"\"Hook function that will be invoked after each exception.\"\"\" if not hasattr ( state , \"error_count\" ): state . error_count = 1 else : state . error_count += 1 logger . info ( \"an exception of type %s has occurred for requested path %s and the application error count is %d .\" , type ( exc ) . __name__ , scope [ \"path\" ], state . error_count , ) app = Starlite ([ my_handler ], after_exception = after_exception_handler ) Important This hook is not meant to handle exceptions - it just receives them to allow for side effects. To handle exceptions you should define exception handlers .","title":"After Exception"},{"location":"usage/0-the-starlite-app/5-application-hooks/#before-send","text":"The before_send hook takes a sync or async callable that is called when an ASGI message is sent. The hook receives the message instance and the application state. Before Send Hook from typing import TYPE_CHECKING , Dict from starlette.datastructures import MutableHeaders from starlite import Starlite , get if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Message @get ( \"/test\" ) def handler () -> Dict [ str , str ]: \"\"\"Example Handler function.\"\"\" return { \"key\" : \"value\" } async def before_send_hook_handler ( message : \"Message\" , state : \"State\" ) -> None : \"\"\"The function will be called on each ASGI message. We therefore ensure it runs only on the message start event. \"\"\" if message [ \"type\" ] == \"http.response.start\" : headers = MutableHeaders ( scope = message ) headers . append ( \"My Header\" , state . message ) def on_startup ( state : \"State\" ) -> None : \"\"\"A function that will populate the app state before any requests are received.\"\"\" state . message = \"value injected during send\" app = Starlite ( route_handlers = [ handler ], on_startup = [ on_startup ], before_send = before_send_hook_handler )","title":"Before Send"},{"location":"usage/0-the-starlite-app/6-application-init-hook/","text":"Application Init Hook Starlite includes a hook for intercepting the arguments passed to the Starlite constructor, before they are used to instantiate the application. Handlers can be passed to the on_app_init parameter on construction of the application, and in turn, each will receive an instance of AppConfig and must return an instance of same. This hook is useful for applying common configuration between applications, and for use by developers who may wish to develop third-party application configuration systems. Note on_app_init handlers cannot be async def functions, as they are called within Starlite.__init__() , outside of an async context. After Exception Hook from typing import TYPE_CHECKING from starlite import Starlite if TYPE_CHECKING : from starlite.config import AppConfig async def close_db_connection () -> None : \"\"\"Closes the database connection on application shutdown.\"\"\" def receive_app_config ( app_config : \"AppConfig\" ) -> \"AppConfig\" : \"\"\"Receives parameters from the application. In reality, this would be a library of boilerplate that is carried from one application to another, or a third-party developed application configuration tool. \"\"\" app_config . on_shutdown . append ( close_db_connection ) return app_config app = Starlite ([], on_app_init = [ receive_app_config ])","title":"Application Init Hook"},{"location":"usage/0-the-starlite-app/6-application-init-hook/#application-init-hook","text":"Starlite includes a hook for intercepting the arguments passed to the Starlite constructor, before they are used to instantiate the application. Handlers can be passed to the on_app_init parameter on construction of the application, and in turn, each will receive an instance of AppConfig and must return an instance of same. This hook is useful for applying common configuration between applications, and for use by developers who may wish to develop third-party application configuration systems. Note on_app_init handlers cannot be async def functions, as they are called within Starlite.__init__() , outside of an async context. After Exception Hook from typing import TYPE_CHECKING from starlite import Starlite if TYPE_CHECKING : from starlite.config import AppConfig async def close_db_connection () -> None : \"\"\"Closes the database connection on application shutdown.\"\"\" def receive_app_config ( app_config : \"AppConfig\" ) -> \"AppConfig\" : \"\"\"Receives parameters from the application. In reality, this would be a library of boilerplate that is carried from one application to another, or a third-party developed application configuration tool. \"\"\" app_config . on_shutdown . append ( close_db_connection ) return app_config app = Starlite ([], on_app_init = [ receive_app_config ])","title":"Application Init Hook"},{"location":"usage/1-routing/0-routing/","text":"Routing Although Starlite builds on the Starlette ASGI toolkit as a basis, it does not use the Starlette routing system, which uses regex matching, and instead it implements its own solution that is based on the concept of a radix tree or trie . Why Radix Based Routing? The regex matching used by Starlette (and FastAPI etc.) is very good at resolving path parameters fast, giving it an advantage when a URL has a lot of path parameters - what we can think of as vertical scaling. On the other hand, it is not good at scaling horizontally - the more routes, the less performant it becomes. Thus, there is an inverse relation between performance and application size with this approach that strongly favors very small microservices. The trie based approach used by Starlite is agnostic to the number of routes of the application giving it better horizontal scaling characteristics at the expense of somewhat slower resolution of path parameters. Tip If you are interested in the technical aspects of the implementation, refer to this GitHub issue - it includes an indepth discussion of the pertinent code.","title":"Routing"},{"location":"usage/1-routing/0-routing/#routing","text":"Although Starlite builds on the Starlette ASGI toolkit as a basis, it does not use the Starlette routing system, which uses regex matching, and instead it implements its own solution that is based on the concept of a radix tree or trie .","title":"Routing"},{"location":"usage/1-routing/0-routing/#why-radix-based-routing","text":"The regex matching used by Starlette (and FastAPI etc.) is very good at resolving path parameters fast, giving it an advantage when a URL has a lot of path parameters - what we can think of as vertical scaling. On the other hand, it is not good at scaling horizontally - the more routes, the less performant it becomes. Thus, there is an inverse relation between performance and application size with this approach that strongly favors very small microservices. The trie based approach used by Starlite is agnostic to the number of routes of the application giving it better horizontal scaling characteristics at the expense of somewhat slower resolution of path parameters. Tip If you are interested in the technical aspects of the implementation, refer to this GitHub issue - it includes an indepth discussion of the pertinent code.","title":"Why Radix Based Routing?"},{"location":"usage/1-routing/1-registering-routes/","text":"Registering Routes At the root of every Starlite application there is an instance of the class starlite.app.Starlite , on which the root level controllers, routers and route handler functions are registered using the route_handlers kwarg: from starlite import Starlite , get @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler , sub_path_handler ]) Components registered on the app are appended to the root path. Thus, the root_handler function will be called for the path \"/\", whereas the sub_path_handler will be called for \"/sub-path\". You can also declare a function to handle multiple paths, e.g.: from starlite import get , Starlite @get ([ \"/\" , \"/sub-path\" ]) def handler () -> None : ... app = Starlite ( route_handlers = [ handler ]) To handle more complex path schemas you should use routers and controller Dynamic Route Registration Occasionally there is a need for dynamic route registration. Starlite supports this via the .register method exposed by the Starlite app instance: from starlite import Starlite , get @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler ]) @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... app . register ( sub_path_handler ) Since the app instance is attached to all instances of ASGIConnection , Request and WebSocket objects, you can in effect call the .register method inside route handler functions, middlewares and even injected dependencies. For example: from typing import Any from starlite import Starlite , Request , get @get ( \"/some-path\" ) def route_handler ( request : Request [ Any , Any ]) -> None : @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... request . app . register ( sub_path_handler ) app = Starlite ( route_handlers = [ route_handler ]) In the above we dynamically created the sub-path_handler and registered it inside the route_handler function. Warning Although Starlite exposes the .register method, it should not be abused. Dynamic route registration increases the application complexity and makes it harder to reason about the code. It should therefore be used only when absolutely required.","title":"Registering Routes"},{"location":"usage/1-routing/1-registering-routes/#registering-routes","text":"At the root of every Starlite application there is an instance of the class starlite.app.Starlite , on which the root level controllers, routers and route handler functions are registered using the route_handlers kwarg: from starlite import Starlite , get @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler , sub_path_handler ]) Components registered on the app are appended to the root path. Thus, the root_handler function will be called for the path \"/\", whereas the sub_path_handler will be called for \"/sub-path\". You can also declare a function to handle multiple paths, e.g.: from starlite import get , Starlite @get ([ \"/\" , \"/sub-path\" ]) def handler () -> None : ... app = Starlite ( route_handlers = [ handler ]) To handle more complex path schemas you should use routers and controller","title":"Registering Routes"},{"location":"usage/1-routing/1-registering-routes/#dynamic-route-registration","text":"Occasionally there is a need for dynamic route registration. Starlite supports this via the .register method exposed by the Starlite app instance: from starlite import Starlite , get @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler ]) @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... app . register ( sub_path_handler ) Since the app instance is attached to all instances of ASGIConnection , Request and WebSocket objects, you can in effect call the .register method inside route handler functions, middlewares and even injected dependencies. For example: from typing import Any from starlite import Starlite , Request , get @get ( \"/some-path\" ) def route_handler ( request : Request [ Any , Any ]) -> None : @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... request . app . register ( sub_path_handler ) app = Starlite ( route_handlers = [ route_handler ]) In the above we dynamically created the sub-path_handler and registered it inside the route_handler function. Warning Although Starlite exposes the .register method, it should not be abused. Dynamic route registration increases the application complexity and makes it harder to reason about the code. It should therefore be used only when absolutely required.","title":"Dynamic Route Registration"},{"location":"usage/1-routing/2-routers/","text":"Routers Routers are instances of starlite.router.Router , which is the base class for the Starlite app itself. A router can register Controllers, route handler functions and other routers, similarly to the Starlite constructor: from starlite import Starlite , Router , get @get ( \"/{order_id:int}\" ) def order_handler ( order_id : int ) -> None : ... order_router = Router ( path = \"/orders\" , route_handlers = [ order_handler ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) app = Starlite ( route_handlers = [ base_router ]) Once order_router is registered on base_router , the handler function registered on order_router will become available on /base/orders/{order_id} . See the API Reference for full details on the Router class and the kwargs it accepts.","title":"Routers"},{"location":"usage/1-routing/2-routers/#routers","text":"Routers are instances of starlite.router.Router , which is the base class for the Starlite app itself. A router can register Controllers, route handler functions and other routers, similarly to the Starlite constructor: from starlite import Starlite , Router , get @get ( \"/{order_id:int}\" ) def order_handler ( order_id : int ) -> None : ... order_router = Router ( path = \"/orders\" , route_handlers = [ order_handler ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) app = Starlite ( route_handlers = [ base_router ]) Once order_router is registered on base_router , the handler function registered on order_router will become available on /base/orders/{order_id} . See the API Reference for full details on the Router class and the kwargs it accepts.","title":"Routers"},{"location":"usage/1-routing/3-controllers/","text":"Controllers Controllers are subclasses of the class starlite.controller.Controller . They are used to organize endpoints under a specific sub-path, which is the controller's path. Their purpose is to allow users to utilize python OOP for better code organization and organize code by logical concerns. from pydantic import BaseModel , UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial class UserOrder ( BaseModel ): user_id : int order : str class UserOrderController ( Controller ): path = \"/user-order\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> None : ... The above is a simple example of a \"CRUD\" controller for a model called UserOrder . You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller - /user-order/ , while retrieve_user_order has the path /user-order/{order_id:uuid}\" . Note If you do not declare a path class variable on the controller, it will default to the root path of \"/\". See the API Reference for full details on the Controller class and the kwargs it accepts.","title":"Controllers"},{"location":"usage/1-routing/3-controllers/#controllers","text":"Controllers are subclasses of the class starlite.controller.Controller . They are used to organize endpoints under a specific sub-path, which is the controller's path. Their purpose is to allow users to utilize python OOP for better code organization and organize code by logical concerns. from pydantic import BaseModel , UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial class UserOrder ( BaseModel ): user_id : int order : str class UserOrderController ( Controller ): path = \"/user-order\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> None : ... The above is a simple example of a \"CRUD\" controller for a model called UserOrder . You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller - /user-order/ , while retrieve_user_order has the path /user-order/{order_id:uuid}\" . Note If you do not declare a path class variable on the controller, it will default to the root path of \"/\". See the API Reference for full details on the Controller class and the kwargs it accepts.","title":"Controllers"},{"location":"usage/1-routing/4-registering-components-multiple-times/","text":"Registering Components Multiple Times You can register both standalone route handler functions and controllers multiple times. Registering Controllers Multiple Times from starlite import Router , Controller , get class MyController ( Controller ): path = \"/controller\" @get () def handler ( self ) -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ MyController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ MyController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ MyController ]) In the above, the same MyController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore, in the above example, three different instances of MyController will be created, each mounted on a different sub-path, e.g. /internal/controller , /partner/controller and /consumer/controller . Registering Standalone Route Handlers Multiple Times You can also register standalone route handlers multiple times: from starlite import Starlite , Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) Starlite ( route_handlers = [ internal_router , partner_router , consumer_router ]) When the handler function is registered, it's actually copied. Thus, each router has its own unique instance of the route handler. Path behaviour is identical to that of controllers above, namely, the route handler function will be accessible in the following paths: /internal/handler , /partner/handler and /consumer/handler . Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.","title":"Registering Components Multiple Times"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-components-multiple-times","text":"You can register both standalone route handler functions and controllers multiple times.","title":"Registering Components Multiple Times"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-controllers-multiple-times","text":"from starlite import Router , Controller , get class MyController ( Controller ): path = \"/controller\" @get () def handler ( self ) -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ MyController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ MyController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ MyController ]) In the above, the same MyController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore, in the above example, three different instances of MyController will be created, each mounted on a different sub-path, e.g. /internal/controller , /partner/controller and /consumer/controller .","title":"Registering Controllers Multiple Times"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-standalone-route-handlers-multiple-times","text":"You can also register standalone route handlers multiple times: from starlite import Starlite , Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) Starlite ( route_handlers = [ internal_router , partner_router , consumer_router ]) When the handler function is registered, it's actually copied. Thus, each router has its own unique instance of the route handler. Path behaviour is identical to that of controllers above, namely, the route handler function will be accessible in the following paths: /internal/handler , /partner/handler and /consumer/handler . Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.","title":"Registering Standalone Route Handlers Multiple Times"},{"location":"usage/10-plugins/0-plugins-intro/","text":"Plugins Starlite supports extension through plugins, which allow for the following: Updating the Starlite application instance during the init process. Serialization and deserialization of non-pydantic based 3rd party classes. Automatic OpenAPI schema creation for 3rd party classes. Thus, plugins allow for a wide range of actions - from registering middleware to the parsing and validation of incoming data using non-pydantic classes. Additionally, they allow for seamless serialization and schema generation. Creating Plugins A plugin is a class that implements the starlite.plugins.base.PluginProtocol . If you wish to support the serialization and deserialization of none-pydantic classes, you need to implement the following methods specified by the: from typing import Type , Any , Dict from starlite import PluginProtocol from pydantic import BaseModel class MyClass : ... class MyPlugin ( PluginProtocol [ MyClass ]): \"\"\" The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc. \"\"\" ... def to_pydantic_model_class ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> Type [ BaseModel ]: \"\"\" Given a model_class, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : Type [ MyClass ], pydantic_model_instance : BaseModel ) -> MyClass : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : MyClass ) -> Dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> MyClass : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ... If you wish to register middlewares, guards, dependencies and so forth on the application init, you need to implement the on_app_init method: from typing import Any from starlite import PluginProtocol , Starlite , get @get ( \"/some-path\" ) def my_handler () -> None : ... class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # register a route handler app . register ( my_handler ) # update attributes of the application before init is finished. app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... )","title":"Plugins"},{"location":"usage/10-plugins/0-plugins-intro/#plugins","text":"Starlite supports extension through plugins, which allow for the following: Updating the Starlite application instance during the init process. Serialization and deserialization of non-pydantic based 3rd party classes. Automatic OpenAPI schema creation for 3rd party classes. Thus, plugins allow for a wide range of actions - from registering middleware to the parsing and validation of incoming data using non-pydantic classes. Additionally, they allow for seamless serialization and schema generation.","title":"Plugins"},{"location":"usage/10-plugins/0-plugins-intro/#creating-plugins","text":"A plugin is a class that implements the starlite.plugins.base.PluginProtocol . If you wish to support the serialization and deserialization of none-pydantic classes, you need to implement the following methods specified by the: from typing import Type , Any , Dict from starlite import PluginProtocol from pydantic import BaseModel class MyClass : ... class MyPlugin ( PluginProtocol [ MyClass ]): \"\"\" The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc. \"\"\" ... def to_pydantic_model_class ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> Type [ BaseModel ]: \"\"\" Given a model_class, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : Type [ MyClass ], pydantic_model_instance : BaseModel ) -> MyClass : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : MyClass ) -> Dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> MyClass : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ... If you wish to register middlewares, guards, dependencies and so forth on the application init, you need to implement the on_app_init method: from typing import Any from starlite import PluginProtocol , Starlite , get @get ( \"/some-path\" ) def my_handler () -> None : ... class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # register a route handler app . register ( my_handler ) # update attributes of the application before init is finished. app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... )","title":"Creating Plugins"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/","text":"SQL-Alchemy Plugin Starlite offers extensive support for SQLAlchemy using with the SQLAlchemyPlugin . This plugin offers support for SQLAlchemy declarative models, which can be used as if they were pydantic models. Additionally, you can pass optional configuration to the plugin to create a DB engine / connection and setup DB sessions dependency injection. Basic Use You can simply pass an instance of SQLAlchemyPlugin without passing config to the Starlite constructor. This will extend support for serialization, deserialization and DTO creation for SQLAlchemy declarative models: from starlite import Starlite from starlite.plugins.sql_alchemy import SQLAlchemyPlugin from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import post , get Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) @post ( path = \"/companies\" ) def create_company ( data : Company ) -> Company : ... @get ( path = \"/companies\" ) def get_companies () -> list [ Company ]: ... app = Starlite ( route_handlers = [ create_company , get_companies ], plugins = [ SQLAlchemyPlugin ()] ) Important The SQLAlchemyPlugin supports only declarative style classes, it does not support the older imperative style because this style does not use classes, and is very hard to convert to pydantic correctly. Handling of Relationships The SQLAlchemy plugin handles relationships by traversing and recursively converting the related tables into pydantic models. This approach, while powerful, poses some difficulties. For example, consider these two tables: from sqlalchemy import Column , Float , ForeignKey , Integer , String from sqlalchemy.orm import relationship , declarative_base Base = declarative_base () class Pet ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) age = Column ( Float ) owner_id = Column ( Integer , ForeignKey ( \"user.id\" )) owner = relationship ( \"User\" , back_populates = \"pets\" ) class User ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String , default = \"moishe\" ) pets = relationship ( \"Pet\" , back_populates = \"owner\" , ) The User table references the Pet table, which back references the User table. Hence, the resulting pydantic model will include a circular reference. To avoid this, the plugin sets relationships of this kind in the pydantic model type Any with a default of None . This means you can provide any value for them - or none at all, and validation will not break. Additionally, all relationships are defined as Optional in the pydantic model, following the assumption you might not send complete data structures using the API. SQLAlchemy Config You can also pass an instance of SQLAlchemyConfig to the plugin constructor: from starlite import Starlite from starlite.plugins.sql_alchemy import SQLAlchemyPlugin , SQLAlchemyConfig from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from sqlalchemy.ext.asyncio import AsyncSession from starlite import post Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) @post ( path = \"/companies\" ) async def create_company ( data : Company , async_session : AsyncSession ) -> Company : ... app = Starlite ( route_handlers = [], plugins = [ SQLAlchemyPlugin ( config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite://\" , dependency_key = \"async_session\" ) ), ], ) In the above, the SQLAlchemyPlugin will establish a db connection using the given connection string, and add a dependency injection under the async_session key on the application level. See the API Reference for a full reference of the SQLAlchemyConfig kwargs.","title":"SQL-Alchemy Plugin"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#sql-alchemy-plugin","text":"Starlite offers extensive support for SQLAlchemy using with the SQLAlchemyPlugin . This plugin offers support for SQLAlchemy declarative models, which can be used as if they were pydantic models. Additionally, you can pass optional configuration to the plugin to create a DB engine / connection and setup DB sessions dependency injection.","title":"SQL-Alchemy Plugin"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#basic-use","text":"You can simply pass an instance of SQLAlchemyPlugin without passing config to the Starlite constructor. This will extend support for serialization, deserialization and DTO creation for SQLAlchemy declarative models: from starlite import Starlite from starlite.plugins.sql_alchemy import SQLAlchemyPlugin from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import post , get Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) @post ( path = \"/companies\" ) def create_company ( data : Company ) -> Company : ... @get ( path = \"/companies\" ) def get_companies () -> list [ Company ]: ... app = Starlite ( route_handlers = [ create_company , get_companies ], plugins = [ SQLAlchemyPlugin ()] ) Important The SQLAlchemyPlugin supports only declarative style classes, it does not support the older imperative style because this style does not use classes, and is very hard to convert to pydantic correctly.","title":"Basic Use"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#handling-of-relationships","text":"The SQLAlchemy plugin handles relationships by traversing and recursively converting the related tables into pydantic models. This approach, while powerful, poses some difficulties. For example, consider these two tables: from sqlalchemy import Column , Float , ForeignKey , Integer , String from sqlalchemy.orm import relationship , declarative_base Base = declarative_base () class Pet ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) age = Column ( Float ) owner_id = Column ( Integer , ForeignKey ( \"user.id\" )) owner = relationship ( \"User\" , back_populates = \"pets\" ) class User ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String , default = \"moishe\" ) pets = relationship ( \"Pet\" , back_populates = \"owner\" , ) The User table references the Pet table, which back references the User table. Hence, the resulting pydantic model will include a circular reference. To avoid this, the plugin sets relationships of this kind in the pydantic model type Any with a default of None . This means you can provide any value for them - or none at all, and validation will not break. Additionally, all relationships are defined as Optional in the pydantic model, following the assumption you might not send complete data structures using the API.","title":"Handling of Relationships"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#sqlalchemy-config","text":"You can also pass an instance of SQLAlchemyConfig to the plugin constructor: from starlite import Starlite from starlite.plugins.sql_alchemy import SQLAlchemyPlugin , SQLAlchemyConfig from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from sqlalchemy.ext.asyncio import AsyncSession from starlite import post Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) @post ( path = \"/companies\" ) async def create_company ( data : Company , async_session : AsyncSession ) -> Company : ... app = Starlite ( route_handlers = [], plugins = [ SQLAlchemyPlugin ( config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite://\" , dependency_key = \"async_session\" ) ), ], ) In the above, the SQLAlchemyPlugin will establish a db connection using the given connection string, and add a dependency injection under the async_session key on the application level. See the API Reference for a full reference of the SQLAlchemyConfig kwargs.","title":"SQLAlchemy Config"},{"location":"usage/10-plugins/2-tortoise-orm-plugin/","text":"Tortoise ORM Plugin To use the starlite.plugins.tortoise_orm.TortoiseORMPlugin import it and pass it to the Starlite constructor: from typing import cast from tortoise import Model , Tortoise , fields from tortoise.connection import connections from starlite import Starlite , get , post from starlite.plugins.tortoise_orm import TortoiseORMPlugin class Tournament ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) optional = fields . TextField ( null = True ) events : fields . ReverseRelation [ \"Event\" ] class Meta : ordering = [ \"name\" ] class Event ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) tournament : fields . ForeignKeyNullableRelation [ Tournament ] = fields . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" , null = True ) participants : fields . ManyToManyRelation [ \"Team\" ] = fields . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) address : fields . OneToOneNullableRelation [ \"Address\" ] class Meta : ordering = [ \"name\" ] class Address ( Model ): city = fields . CharField ( max_length = 64 ) street = fields . CharField ( max_length = 128 ) created_at = fields . DatetimeField ( auto_now_add = True ) event : fields . OneToOneRelation [ Event ] = fields . OneToOneField ( \"models.Event\" , related_name = \"address\" , pk = True ) class Meta : ordering = [ \"city\" ] class Team ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) events : fields . ManyToManyRelation [ Event ] class Meta : ordering = [ \"name\" ] async def init_tortoise () -> None : await Tortoise . init ( db_url = \"sqlite://:memory:\" , modules = { \"models\" : [ __name__ ]}) await Tortoise . generate_schemas () async def shutdown_tortoise () -> None : await connections . close_all () @get ( \"/tournaments\" ) async def get_tournaments () -> list [ Tournament ]: tournaments = await Tournament . all () return cast ( \"list[Tournament]\" , tournaments ) @get ( \"/tournaments/{tournament_id:int}\" ) async def get_tournament ( tournament_id : int ) -> Tournament : tournament = await Tournament . filter ( id = tournament_id ) . first () return cast ( \"Tournament\" , tournament ) @post ( \"/tournaments\" ) async def create_tournament ( data : Tournament ) -> Tournament : assert isinstance ( data , Tournament ) await data . save () await data . refresh_from_db () return data app = Starlite ( route_handlers = [ get_tournament , get_tournaments , create_tournament ], on_startup = [ init_tortoise ], on_shutdown = [ shutdown_tortoise ], plugins = [ TortoiseORMPlugin ()], ) With the plugin in place, you can use any Tortoise model as a type in route handlers.","title":"Tortoise ORM Plugin"},{"location":"usage/10-plugins/2-tortoise-orm-plugin/#tortoise-orm-plugin","text":"To use the starlite.plugins.tortoise_orm.TortoiseORMPlugin import it and pass it to the Starlite constructor: from typing import cast from tortoise import Model , Tortoise , fields from tortoise.connection import connections from starlite import Starlite , get , post from starlite.plugins.tortoise_orm import TortoiseORMPlugin class Tournament ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) optional = fields . TextField ( null = True ) events : fields . ReverseRelation [ \"Event\" ] class Meta : ordering = [ \"name\" ] class Event ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) tournament : fields . ForeignKeyNullableRelation [ Tournament ] = fields . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" , null = True ) participants : fields . ManyToManyRelation [ \"Team\" ] = fields . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) address : fields . OneToOneNullableRelation [ \"Address\" ] class Meta : ordering = [ \"name\" ] class Address ( Model ): city = fields . CharField ( max_length = 64 ) street = fields . CharField ( max_length = 128 ) created_at = fields . DatetimeField ( auto_now_add = True ) event : fields . OneToOneRelation [ Event ] = fields . OneToOneField ( \"models.Event\" , related_name = \"address\" , pk = True ) class Meta : ordering = [ \"city\" ] class Team ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) events : fields . ManyToManyRelation [ Event ] class Meta : ordering = [ \"name\" ] async def init_tortoise () -> None : await Tortoise . init ( db_url = \"sqlite://:memory:\" , modules = { \"models\" : [ __name__ ]}) await Tortoise . generate_schemas () async def shutdown_tortoise () -> None : await connections . close_all () @get ( \"/tournaments\" ) async def get_tournaments () -> list [ Tournament ]: tournaments = await Tournament . all () return cast ( \"list[Tournament]\" , tournaments ) @get ( \"/tournaments/{tournament_id:int}\" ) async def get_tournament ( tournament_id : int ) -> Tournament : tournament = await Tournament . filter ( id = tournament_id ) . first () return cast ( \"Tournament\" , tournament ) @post ( \"/tournaments\" ) async def create_tournament ( data : Tournament ) -> Tournament : assert isinstance ( data , Tournament ) await data . save () await data . refresh_from_db () return data app = Starlite ( route_handlers = [ get_tournament , get_tournaments , create_tournament ], on_startup = [ init_tortoise ], on_shutdown = [ shutdown_tortoise ], plugins = [ TortoiseORMPlugin ()], ) With the plugin in place, you can use any Tortoise model as a type in route handlers.","title":"Tortoise ORM Plugin"},{"location":"usage/10-plugins/3-piccolo-orm-plugin/","text":"Piccolo ORM Plugin To use the starlite.plugins.piccolo_orm.PiccoloORMPlugin import it and pass it to the Starlite constructor: from starlite import Starlite , post , get from starlite.plugins.piccolo_orm import PiccoloORMPlugin from piccolo.columns.column_types import ( JSON , JSONB , ForeignKey , Integer , Varchar , ) from piccolo.table import Table class RecordingStudio ( Table ): facilities = JSON () facilities_b = JSONB () class Manager ( Table ): name = Varchar ( length = 50 ) class Band ( Table ): name = Varchar ( length = 50 ) manager = ForeignKey ( Manager ) popularity = Integer () class Venue ( Table ): name = Varchar ( length = 100 ) capacity = Integer ( secret = True ) class Concert ( Table ): band_1 = ForeignKey ( Band ) band_2 = ForeignKey ( Band ) venue = ForeignKey ( Venue ) @post ( \"/concert\" ) async def create_concert ( data : Concert ) -> Concert : await data . save () await data . refresh () return data @get ( \"/studio/{studio_id:int}\" ) async def retrieve_studio ( studio_id : int ) -> RecordingStudio : return await RecordingStudio . select () . where ( RecordingStudio . id == studio_id ) @get ( \"/venues\" ) async def retrieve_venues () -> list [ Venue ]: return await Venue . select () app = Starlite ( route_handlers = [ create_concert , retrieve_studio , retrieve_venues ], plugins = [ PiccoloORMPlugin ()], ) With the plugin in place, you can use any Piccolo tables as a type in route handlers.","title":"Piccolo ORM Plugin"},{"location":"usage/10-plugins/3-piccolo-orm-plugin/#piccolo-orm-plugin","text":"To use the starlite.plugins.piccolo_orm.PiccoloORMPlugin import it and pass it to the Starlite constructor: from starlite import Starlite , post , get from starlite.plugins.piccolo_orm import PiccoloORMPlugin from piccolo.columns.column_types import ( JSON , JSONB , ForeignKey , Integer , Varchar , ) from piccolo.table import Table class RecordingStudio ( Table ): facilities = JSON () facilities_b = JSONB () class Manager ( Table ): name = Varchar ( length = 50 ) class Band ( Table ): name = Varchar ( length = 50 ) manager = ForeignKey ( Manager ) popularity = Integer () class Venue ( Table ): name = Varchar ( length = 100 ) capacity = Integer ( secret = True ) class Concert ( Table ): band_1 = ForeignKey ( Band ) band_2 = ForeignKey ( Band ) venue = ForeignKey ( Venue ) @post ( \"/concert\" ) async def create_concert ( data : Concert ) -> Concert : await data . save () await data . refresh () return data @get ( \"/studio/{studio_id:int}\" ) async def retrieve_studio ( studio_id : int ) -> RecordingStudio : return await RecordingStudio . select () . where ( RecordingStudio . id == studio_id ) @get ( \"/venues\" ) async def retrieve_venues () -> list [ Venue ]: return await Venue . select () app = Starlite ( route_handlers = [ create_concert , retrieve_studio , retrieve_venues ], plugins = [ PiccoloORMPlugin ()], ) With the plugin in place, you can use any Piccolo tables as a type in route handlers.","title":"Piccolo ORM Plugin"},{"location":"usage/12-openapi/0-openapi-intro/","text":"OpenAPI Integration Starlite has first class OpenAPI support offering the following features: Automatic OpenAPI 3.1.0 Schema generation, which is available as both YAML and JSON. Builtin support for static documentation site generation using several different libraries. Simple configuration using pydantic based classes. Pydantic-OpenAPI-Schema Starlite generates the latest version of the OpenAPI specification using the pydantic-openapi-schema library, which is bundled as part of Starlite and is also maintained by the starlite-api GitHub organization. This library offers a full implementation of the OpenAPI specification as pydantic models, and is as such a powerful and type correct foundation for schema generation using python. Tip You can refer to the pydantic-openapi-schema doc for a full reference regarding the library's API.","title":"OpenAPI Integration"},{"location":"usage/12-openapi/0-openapi-intro/#openapi-integration","text":"Starlite has first class OpenAPI support offering the following features: Automatic OpenAPI 3.1.0 Schema generation, which is available as both YAML and JSON. Builtin support for static documentation site generation using several different libraries. Simple configuration using pydantic based classes.","title":"OpenAPI Integration"},{"location":"usage/12-openapi/0-openapi-intro/#pydantic-openapi-schema","text":"Starlite generates the latest version of the OpenAPI specification using the pydantic-openapi-schema library, which is bundled as part of Starlite and is also maintained by the starlite-api GitHub organization. This library offers a full implementation of the OpenAPI specification as pydantic models, and is as such a powerful and type correct foundation for schema generation using python. Tip You can refer to the pydantic-openapi-schema doc for a full reference regarding the library's API.","title":"Pydantic-OpenAPI-Schema"},{"location":"usage/12-openapi/1-schema-generation/","text":"OpenAPI Schema Generation Config OpenAPI schema generation is enabled by default. To configure it you can pass an instance of OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required , you can pass the following optional kwargs: components : An instance of Components or list of instances. If a list is provided, its members will be merged recursively into a single instance. contact : An instance of the Contact . create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . description : Description text. external_docs : An instance of the ExternalDocumentation . license : An instance of the License . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . security : An instance of the SecurityRequirement servers : A list of Server instances. Defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag instances. terms_of_service : A url to a page containing the terms of service. use_handler_docstrings : Boolean flag dictating whether to use route handler docstring to generate descriptions. webhooks : A string keyed dictionary of PathItem instances. # root_schema_site : Dictates which schema site is served by default. The value should be one of redoc , swagger , elements , with the default be redoc . enabled_endpoints : Dictates which schema site endpoints are enabled. It may have the following values redoc , swagger , elements , openapi.json , openapi.yaml . By default, it enables all endpoints. Disabling Schema Generation If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : from starlite import Starlite app = Starlite ( route_handlers = [ ... ], openapi_config = None )","title":"OpenAPI Schema Generation Config"},{"location":"usage/12-openapi/1-schema-generation/#openapi-schema-generation-config","text":"OpenAPI schema generation is enabled by default. To configure it you can pass an instance of OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required , you can pass the following optional kwargs: components : An instance of Components or list of instances. If a list is provided, its members will be merged recursively into a single instance. contact : An instance of the Contact . create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . description : Description text. external_docs : An instance of the ExternalDocumentation . license : An instance of the License . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . security : An instance of the SecurityRequirement servers : A list of Server instances. Defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag instances. terms_of_service : A url to a page containing the terms of service. use_handler_docstrings : Boolean flag dictating whether to use route handler docstring to generate descriptions. webhooks : A string keyed dictionary of PathItem instances. # root_schema_site : Dictates which schema site is served by default. The value should be one of redoc , swagger , elements , with the default be redoc . enabled_endpoints : Dictates which schema site endpoints are enabled. It may have the following values redoc , swagger , elements , openapi.json , openapi.yaml . By default, it enables all endpoints.","title":"OpenAPI Schema Generation Config"},{"location":"usage/12-openapi/1-schema-generation/#disabling-schema-generation","text":"If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : from starlite import Starlite app = Starlite ( route_handlers = [ ... ], openapi_config = None )","title":"Disabling Schema Generation"},{"location":"usage/12-openapi/2-route-handler-configuration/","text":"Route Handler OpenAPI Configuration By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema=False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also modify the generated schema for the route handler using the following kwargs: tags : A list of strings that correlate to the tag specification . security : A list of dictionaries that correlate to the security requirements specification . The values for this key are string keyed dictionaries with the values being a list of objects. summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function). responses : A dictionary of additional status codes and a description of their expected content. The expected content should be based on a Pydantic model describing its structure. It can also include a description and the expected media type. For example: from datetime import datetime from typing import Optional from pydantic import BaseModel from starlite import ResponseSpec , get class Item ( BaseModel ): ... class ItemNotFound ( BaseModel ): was_removed : bool removed_at : Optional [ datetime ] @get ( path = \"/items/{pk:int}\" , responses = { 404 : ResponseSpec ( model = ItemNotFound , description = \"Item was removed or not found\" ) }, ) def retrieve_item ( pk : int ) -> Item : ... You can also specify security and tags on higher level of the application, e.g. on a controller, router or the app instance itself. For example: from starlite import Starlite , OpenAPIConfig , get from pydantic_openapi_schema.v3_1_0 import Components , SecurityScheme , Tag @get ( \"/public\" , tags = [ \"public\" ], security = [{}], # this endpoint is marked as having optional security ) def public_path_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } @get ( \"/other\" , tags = [ \"internal\" ], security = [{ \"apiKey\" : []}]) def internal_path_handler () -> None : ... app = Starlite ( route_handlers = [ public_path_handler , internal_path_handler ], openapi_config = OpenAPIConfig ( title = \"my api\" , version = \"1.0.0\" , tags = [ Tag ( name = \"public\" , description = \"This endpoint is for external users\" ), Tag ( name = \"internal\" , description = \"This endpoint is for internal users\" ), ], ), security = [{ \"BearerToken\" : []}], components = Components ( securitySchemes = { \"BearerToken\" : SecurityScheme ( type = \"http\" , scheme = \"bearer\" , ) }, ), )","title":"Route Handler OpenAPI Configuration"},{"location":"usage/12-openapi/2-route-handler-configuration/#route-handler-openapi-configuration","text":"By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema=False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also modify the generated schema for the route handler using the following kwargs: tags : A list of strings that correlate to the tag specification . security : A list of dictionaries that correlate to the security requirements specification . The values for this key are string keyed dictionaries with the values being a list of objects. summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function). responses : A dictionary of additional status codes and a description of their expected content. The expected content should be based on a Pydantic model describing its structure. It can also include a description and the expected media type. For example: from datetime import datetime from typing import Optional from pydantic import BaseModel from starlite import ResponseSpec , get class Item ( BaseModel ): ... class ItemNotFound ( BaseModel ): was_removed : bool removed_at : Optional [ datetime ] @get ( path = \"/items/{pk:int}\" , responses = { 404 : ResponseSpec ( model = ItemNotFound , description = \"Item was removed or not found\" ) }, ) def retrieve_item ( pk : int ) -> Item : ... You can also specify security and tags on higher level of the application, e.g. on a controller, router or the app instance itself. For example: from starlite import Starlite , OpenAPIConfig , get from pydantic_openapi_schema.v3_1_0 import Components , SecurityScheme , Tag @get ( \"/public\" , tags = [ \"public\" ], security = [{}], # this endpoint is marked as having optional security ) def public_path_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } @get ( \"/other\" , tags = [ \"internal\" ], security = [{ \"apiKey\" : []}]) def internal_path_handler () -> None : ... app = Starlite ( route_handlers = [ public_path_handler , internal_path_handler ], openapi_config = OpenAPIConfig ( title = \"my api\" , version = \"1.0.0\" , tags = [ Tag ( name = \"public\" , description = \"This endpoint is for external users\" ), Tag ( name = \"internal\" , description = \"This endpoint is for internal users\" ), ], ), security = [{ \"BearerToken\" : []}], components = Components ( securitySchemes = { \"BearerToken\" : SecurityScheme ( type = \"http\" , scheme = \"bearer\" , ) }, ), )","title":"Route Handler OpenAPI Configuration"},{"location":"usage/12-openapi/3-openapi-controller/","text":"The OpenAPIController Starlite includes an OpenAPIController class that is used as the default controller in the OpenAPIConfig . This controller exposes the following endpoints: /schema/openapi.yaml : allowing for download of the OpenAPI schema as YAML. /schema/openapi.json : allowing for download of the OpenAPI schema as JSON. /schema/redoc : which serve the docs using Redoc . /schema/swagger : which serves the docs using Swagger-UI . /schema/elements : which serves the docs using Stoplight Elements . Additionally, the root /schema/ path is accessible, serving the site that is configured as the default in the OpenAPIConfig . Subclassing OpenAPIController You can use your own subclass of OpenAPIController by setting it as then controller to use in the OpenAPIConfig openapi_controller kwarg. For example, lets say we wanted to change the base path of the OpenAPI related endpoints from /schema to /api-docs , in this case we'd the following: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), ) See the API Reference for full details on the OpenAPIController class and the kwargs it accepts. CDN and offline file support You can change the default download paths for JS and CSS bundles as well as google fonts by subclassing OpenAPIController and setting any of the following class variables: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" redoc_google_fonts = False redoc_js_url = \"https://offline_location/redoc.standalone.js\" swagger_css_url = \"https://offline_location/swagger-ui-css\" swagger_ui_bundle_js_url = \"https://offline_location/swagger-ui-bundle.js\" swagger_ui_standalone_preset_js_url = ( \"https://offline_location/swagger-ui-standalone-preset.js\" ) stoplight_elements_css_url = \"https://offline_location/spotlight-styles.mins.css\" stoplight_elements_js_url = ( \"https://offline_location/spotlight-web-components.min.js\" ) app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), )","title":"The OpenAPIController"},{"location":"usage/12-openapi/3-openapi-controller/#the-openapicontroller","text":"Starlite includes an OpenAPIController class that is used as the default controller in the OpenAPIConfig . This controller exposes the following endpoints: /schema/openapi.yaml : allowing for download of the OpenAPI schema as YAML. /schema/openapi.json : allowing for download of the OpenAPI schema as JSON. /schema/redoc : which serve the docs using Redoc . /schema/swagger : which serves the docs using Swagger-UI . /schema/elements : which serves the docs using Stoplight Elements . Additionally, the root /schema/ path is accessible, serving the site that is configured as the default in the OpenAPIConfig .","title":"The OpenAPIController"},{"location":"usage/12-openapi/3-openapi-controller/#subclassing-openapicontroller","text":"You can use your own subclass of OpenAPIController by setting it as then controller to use in the OpenAPIConfig openapi_controller kwarg. For example, lets say we wanted to change the base path of the OpenAPI related endpoints from /schema to /api-docs , in this case we'd the following: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), ) See the API Reference for full details on the OpenAPIController class and the kwargs it accepts.","title":"Subclassing OpenAPIController"},{"location":"usage/12-openapi/3-openapi-controller/#cdn-and-offline-file-support","text":"You can change the default download paths for JS and CSS bundles as well as google fonts by subclassing OpenAPIController and setting any of the following class variables: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" redoc_google_fonts = False redoc_js_url = \"https://offline_location/redoc.standalone.js\" swagger_css_url = \"https://offline_location/swagger-ui-css\" swagger_ui_bundle_js_url = \"https://offline_location/swagger-ui-bundle.js\" swagger_ui_standalone_preset_js_url = ( \"https://offline_location/swagger-ui-standalone-preset.js\" ) stoplight_elements_css_url = \"https://offline_location/spotlight-styles.mins.css\" stoplight_elements_js_url = ( \"https://offline_location/spotlight-web-components.min.js\" ) app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), )","title":"CDN and offline file support"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/","text":"Viewing and Accessing Schema Starlite comes with multiple integrations for documentation site generators. You can view and download your schema using the endpoints exposed by the OpenAPIController . For example, if you are running your app locally on 0.0.0.0:8000 , you would be able to: view your documentation in a Redoc site under http://0.0.0.0:8000/schema/redoc . view your documentation in a SwaggerUI site under http://0.0.0.0:8000/schema/swagger . view your documentation in a StopLight Elements site under http://0.0.0.0:8000/schema/elements . download your documentation as YAML using http://0.0.0.0:8000/schema/openapi.yaml . download your documentation as JSON using http://0.0.0.0:8000/schema/openapi.json . Accessing the OpenAPI Schema in Code The OpenAPI schema is generated during the Starlite app's init method. Once init is finished, its accessible as app.openapi_schema . As such you can always access it inside route handlers, dependencies etc. by access the request instance: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> dict : schema = request . app . openapi_schema return schema . dict ()","title":"Viewing and Accessing Schema"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/#viewing-and-accessing-schema","text":"Starlite comes with multiple integrations for documentation site generators. You can view and download your schema using the endpoints exposed by the OpenAPIController . For example, if you are running your app locally on 0.0.0.0:8000 , you would be able to: view your documentation in a Redoc site under http://0.0.0.0:8000/schema/redoc . view your documentation in a SwaggerUI site under http://0.0.0.0:8000/schema/swagger . view your documentation in a StopLight Elements site under http://0.0.0.0:8000/schema/elements . download your documentation as YAML using http://0.0.0.0:8000/schema/openapi.yaml . download your documentation as JSON using http://0.0.0.0:8000/schema/openapi.json .","title":"Viewing and Accessing Schema"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/#accessing-the-openapi-schema-in-code","text":"The OpenAPI schema is generated during the Starlite app's init method. Once init is finished, its accessible as app.openapi_schema . As such you can always access it inside route handlers, dependencies etc. by access the request instance: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> dict : schema = request . app . openapi_schema return schema . dict ()","title":"Accessing the OpenAPI Schema in Code"},{"location":"usage/12-openapi/5-customizing-pydantic-model-schemas/","text":"Customizing Pydantic Model Schemas You can customize the OpenAPI schemas generated for pydantic models by following the guidelines in the pydantic docs . Additionally, you can affect how pydantic models are translated into OpenAPI components by settings a special dunder attribute on the model called __schema_name__ : Customize Components Example from uuid import UUID , uuid4 from pydantic import BaseModel from starlite import Starlite , get class IdModel ( BaseModel ): __schema_name__ = \"IdContainer\" id : UUID @get ( \"/id\" ) def retrieve_id_handler () -> IdModel : \"\"\" Returns: An IdModel \"\"\" return IdModel ( id = uuid4 ()) app = Starlite ( route_handlers = [ retrieve_id_handler ]) The above will result in an OpenAPI schema object that looks like this: { \"openapi\" : \"3.1.0\" , \"info\" : { \"title\" : \"Starlite API\" , \"version\" : \"1.0.0\" }, \"servers\" : [{ \"url\" : \"/\" }], \"paths\" : { \"/id\" : { \"get\" : { \"operationId\" : \"Retrieve Id Handler\" , \"responses\" : { \"200\" : { \"description\" : \"Request fulfilled, document follows\" , \"headers\" : {}, \"content\" : { \"application/json\" : { \"media_type_schema\" : { \"ref\" : \"#/components/schemas/IdContainer\" } } }, } }, \"deprecated\" : False , } } }, \"components\" : { \"schemas\" : { \"IdContainer\" : { \"properties\" : { \"id\" : { \"type\" : \"string\" , \"schema_format\" : \"uuid\" , \"title\" : \"Id\" } }, \"type\" : \"object\" , \"required\" : [ \"id\" ], \"title\" : \"IdContainer\" , } } }, } Important If you use multiple pydantic models that use the same name in the schema, you will need to use the __schema_name__ dunder to ensure each has a unique name in the schema, otherwise the schema components will be ambivalent.","title":"Customizing Pydantic Model Schemas"},{"location":"usage/12-openapi/5-customizing-pydantic-model-schemas/#customizing-pydantic-model-schemas","text":"You can customize the OpenAPI schemas generated for pydantic models by following the guidelines in the pydantic docs . Additionally, you can affect how pydantic models are translated into OpenAPI components by settings a special dunder attribute on the model called __schema_name__ : Customize Components Example from uuid import UUID , uuid4 from pydantic import BaseModel from starlite import Starlite , get class IdModel ( BaseModel ): __schema_name__ = \"IdContainer\" id : UUID @get ( \"/id\" ) def retrieve_id_handler () -> IdModel : \"\"\" Returns: An IdModel \"\"\" return IdModel ( id = uuid4 ()) app = Starlite ( route_handlers = [ retrieve_id_handler ]) The above will result in an OpenAPI schema object that looks like this: { \"openapi\" : \"3.1.0\" , \"info\" : { \"title\" : \"Starlite API\" , \"version\" : \"1.0.0\" }, \"servers\" : [{ \"url\" : \"/\" }], \"paths\" : { \"/id\" : { \"get\" : { \"operationId\" : \"Retrieve Id Handler\" , \"responses\" : { \"200\" : { \"description\" : \"Request fulfilled, document follows\" , \"headers\" : {}, \"content\" : { \"application/json\" : { \"media_type_schema\" : { \"ref\" : \"#/components/schemas/IdContainer\" } } }, } }, \"deprecated\" : False , } } }, \"components\" : { \"schemas\" : { \"IdContainer\" : { \"properties\" : { \"id\" : { \"type\" : \"string\" , \"schema_format\" : \"uuid\" , \"title\" : \"Id\" } }, \"type\" : \"object\" , \"required\" : [ \"id\" ], \"title\" : \"IdContainer\" , } } }, } Important If you use multiple pydantic models that use the same name in the schema, you will need to use the __schema_name__ dunder to ensure each has a unique name in the schema, otherwise the schema components will be ambivalent.","title":"Customizing Pydantic Model Schemas"},{"location":"usage/15-caching/0-cache-backends/","text":"Cache Backends Starlite includes a builtin Cache that offers a uniform interface to interact with different \"Cache Backends\". A Cache Backend is a class that either implements or fulfills the interface specified by CacheBackendProtocol to provide cache services. Builtin Cache Backends Starlite comes with the following builtin cache backends: By default, Starlite uses the SimpleCacheBackend , which stores values in local memory with the added security of async locks. This is fine for local development, but it's not a good solution for production environments. Starlite also ships with two other ready to use cache backends: RedisCacheBackend , which uses Redis as the caching database. Under the hood it uses redis-py asyncio to make sure requests are not blocked and hiredis to boost performance. Note redis is a required dependency when using this backend. You can install it as an extra with pip install starlite[redis] or independently. MemcachedCacheBackend , which uses memcached as the caching database. Under the hood it uses aiomcache to make sure requests are not blocked. Note memcached is a required dependency when using this backend. You can install it as an extra with pip install starlite[memcached] or independently. Configuring Caching You can configure caching behaviour on the application level by passing an instance of CacheConfig to the Starlite constructor. See the API Reference for full details on the CacheConfig class and the kwargs it accepts. Here is an example of how to configure Redis as the cache backend: from starlite import CacheConfig from starlite.cache.redis_cache_backend import ( RedisCacheBackendConfig , RedisCacheBackend , ) config = RedisCacheBackendConfig ( url = \"redis://localhost/\" , port = 6379 , db = 0 ) redis_backend = RedisCacheBackend ( config = config ) cache_config = CacheConfig ( backend = redis_backend ) Or using Memcached: from starlite import CacheConfig from starlite.cache.memcached_cache_backend import ( MemcachedCacheBackendConfig , MemcachedCacheBackend , ) config = MemcachedCacheBackendConfig ( url = \"127.0.0.1\" , port = 11211 ) memcached_backend = MemcachedCacheBackend ( config = config ) cache_config = CacheConfig ( backend = memcached_backend ) Creating a Custom Cache Backend Since Starlite relies on the CacheBackendProtocol to define cache, creating a custom cache backend is very simple - all that is required is to create a class that inherits from the protocol and implements all its methods, or even a class that simply implements these methods without inheriting from the protocol. Once this is done, you can use the backend in the cache config.","title":"Cache Backends"},{"location":"usage/15-caching/0-cache-backends/#cache-backends","text":"Starlite includes a builtin Cache that offers a uniform interface to interact with different \"Cache Backends\". A Cache Backend is a class that either implements or fulfills the interface specified by CacheBackendProtocol to provide cache services.","title":"Cache Backends"},{"location":"usage/15-caching/0-cache-backends/#builtin-cache-backends","text":"Starlite comes with the following builtin cache backends: By default, Starlite uses the SimpleCacheBackend , which stores values in local memory with the added security of async locks. This is fine for local development, but it's not a good solution for production environments. Starlite also ships with two other ready to use cache backends: RedisCacheBackend , which uses Redis as the caching database. Under the hood it uses redis-py asyncio to make sure requests are not blocked and hiredis to boost performance. Note redis is a required dependency when using this backend. You can install it as an extra with pip install starlite[redis] or independently. MemcachedCacheBackend , which uses memcached as the caching database. Under the hood it uses aiomcache to make sure requests are not blocked. Note memcached is a required dependency when using this backend. You can install it as an extra with pip install starlite[memcached] or independently.","title":"Builtin Cache Backends"},{"location":"usage/15-caching/0-cache-backends/#configuring-caching","text":"You can configure caching behaviour on the application level by passing an instance of CacheConfig to the Starlite constructor. See the API Reference for full details on the CacheConfig class and the kwargs it accepts. Here is an example of how to configure Redis as the cache backend: from starlite import CacheConfig from starlite.cache.redis_cache_backend import ( RedisCacheBackendConfig , RedisCacheBackend , ) config = RedisCacheBackendConfig ( url = \"redis://localhost/\" , port = 6379 , db = 0 ) redis_backend = RedisCacheBackend ( config = config ) cache_config = CacheConfig ( backend = redis_backend ) Or using Memcached: from starlite import CacheConfig from starlite.cache.memcached_cache_backend import ( MemcachedCacheBackendConfig , MemcachedCacheBackend , ) config = MemcachedCacheBackendConfig ( url = \"127.0.0.1\" , port = 11211 ) memcached_backend = MemcachedCacheBackend ( config = config ) cache_config = CacheConfig ( backend = memcached_backend )","title":"Configuring Caching"},{"location":"usage/15-caching/0-cache-backends/#creating-a-custom-cache-backend","text":"Since Starlite relies on the CacheBackendProtocol to define cache, creating a custom cache backend is very simple - all that is required is to create a class that inherits from the protocol and implements all its methods, or even a class that simply implements these methods without inheriting from the protocol. Once this is done, you can use the backend in the cache config.","title":"Creating a Custom Cache Backend"},{"location":"usage/15-caching/1-response-caching/","text":"Response Caching Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching: from starlite import get @get ( \"/cached-path\" , cache = True ) def my_cached_handler () -> str : ... By setting cache=True in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified. Alternatively you can specify the number of seconds to cache the responses from the given handler like so: from starlite import get @get ( \"/cached-path\" , cache = 120 ) # seconds def my_cached_handler () -> str : ... Specifying a Cache Key Builder Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys: from starlite import Request , get def my_custom_key_builder ( request : Request ) -> str : return request . url . path + request . headers . get ( \"my-header\" , \"\" ) @get ( \"/cached-path\" , cache = True , cache_key_builder = my_custom_key_builder ) def my_cached_handler () -> str : ... You can also specify the default cache key builder to use for the entire application (see below).","title":"Response Caching"},{"location":"usage/15-caching/1-response-caching/#response-caching","text":"Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching: from starlite import get @get ( \"/cached-path\" , cache = True ) def my_cached_handler () -> str : ... By setting cache=True in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified. Alternatively you can specify the number of seconds to cache the responses from the given handler like so: from starlite import get @get ( \"/cached-path\" , cache = 120 ) # seconds def my_cached_handler () -> str : ...","title":"Response Caching"},{"location":"usage/15-caching/1-response-caching/#specifying-a-cache-key-builder","text":"Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys: from starlite import Request , get def my_custom_key_builder ( request : Request ) -> str : return request . url . path + request . headers . get ( \"my-header\" , \"\" ) @get ( \"/cached-path\" , cache = True , cache_key_builder = my_custom_key_builder ) def my_cached_handler () -> str : ... You can also specify the default cache key builder to use for the entire application (see below).","title":"Specifying a Cache Key Builder"},{"location":"usage/15-caching/2-interacting-with-cache/","text":"Interacting with the Cache The Starlite app's cache is exposed as app.cache , which makes it accessible via the scope object. For example, you can access the cache in a custom middleware thus: from starlite import MiddlewareProtocol from starlite.types import Scope , Receive , Send , ASGIApp class MyMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : cached_value = await scope [ \"app\" ] . cache . get ( \"my-key\" ) if cached_value : ... The cache is also exposed as a property on the ASGIConnection and the Request and WebSocket classes that inherit from it. You can thus interact with the cache inside a route handler easily, for example by doing this: from starlite import Request , get @get ( \"/\" ) async def my_handler ( request : Request ) -> None : cached_value = await request . cache . get ( \"my-key\" ) if cached_value : ... Important Cache based operations are async because async locking is used to protect against race conditions. If you need to use caching - use an async route handler.","title":"Interacting with the Cache"},{"location":"usage/15-caching/2-interacting-with-cache/#interacting-with-the-cache","text":"The Starlite app's cache is exposed as app.cache , which makes it accessible via the scope object. For example, you can access the cache in a custom middleware thus: from starlite import MiddlewareProtocol from starlite.types import Scope , Receive , Send , ASGIApp class MyMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : cached_value = await scope [ \"app\" ] . cache . get ( \"my-key\" ) if cached_value : ... The cache is also exposed as a property on the ASGIConnection and the Request and WebSocket classes that inherit from it. You can thus interact with the cache inside a route handler easily, for example by doing this: from starlite import Request , get @get ( \"/\" ) async def my_handler ( request : Request ) -> None : cached_value = await request . cache . get ( \"my-key\" ) if cached_value : ... Important Cache based operations are async because async locking is used to protect against race conditions. If you need to use caching - use an async route handler.","title":"Interacting with the Cache"},{"location":"usage/16-templating/0-template-engines/","text":"Template Engines Starlite has built-in support for both Jinja2 and Mako as template engines, and it also offers a simple way to add additional template engines. Registering a Template Engine To register one of the built-in template engines you simply need to pass it to the Starlite constructor: from starlite import TemplateConfig , Starlite from starlite.template.jinja import JinjaTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Or from starlite import TemplateConfig , Starlite from starlite.template.mako import MakoTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ), ) The kwarg directory passed to TemplateConfig is either a directory or list of directories to use for loading templates. Template Responses Once you have a template engine registered you can use it in route handlers: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) The name kwarg passed to the Template class is the filename for the given template. Starlite will search all the directories specifies for this file until it finds it or an exception will be raised. The context kwarg is a dictionary specifying context data that is passed to the engine. Defining a Custom Template Engine If you wish to use another templating engine, you can easily do so by implementing starlite.template.TemplateEngineProtocol . This class accepts a generic argument T which should be the template class, and it specifies two methods: from typing import Protocol , Union , List from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : Union [ DirectoryPath , List [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... Once you have your custom engine you can register it as you would the built-in engines. Modifying the Template Engine Instance TemplateConfig accepts the engine_callback keyword arg which provides a way to modify the instantiated template engine instance. For example: from starlite import TemplateConfig from starlite.template.jinja import JinjaTemplateEngine def engine_callback ( jinja_engine : JinjaTemplateEngine ) -> JinjaTemplateEngine : jinja_engine . engine . globals [ \"key\" ] = \"value\" return jinja_engine template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine , engine_callback = engine_callback ) The callback should receive a single argument which will be the instantiated engine, and must return the instantiated engine.","title":"Template Engines"},{"location":"usage/16-templating/0-template-engines/#template-engines","text":"Starlite has built-in support for both Jinja2 and Mako as template engines, and it also offers a simple way to add additional template engines.","title":"Template Engines"},{"location":"usage/16-templating/0-template-engines/#registering-a-template-engine","text":"To register one of the built-in template engines you simply need to pass it to the Starlite constructor: from starlite import TemplateConfig , Starlite from starlite.template.jinja import JinjaTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Or from starlite import TemplateConfig , Starlite from starlite.template.mako import MakoTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ), ) The kwarg directory passed to TemplateConfig is either a directory or list of directories to use for loading templates.","title":"Registering a Template Engine"},{"location":"usage/16-templating/0-template-engines/#template-responses","text":"Once you have a template engine registered you can use it in route handlers: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) The name kwarg passed to the Template class is the filename for the given template. Starlite will search all the directories specifies for this file until it finds it or an exception will be raised. The context kwarg is a dictionary specifying context data that is passed to the engine.","title":"Template Responses"},{"location":"usage/16-templating/0-template-engines/#defining-a-custom-template-engine","text":"If you wish to use another templating engine, you can easily do so by implementing starlite.template.TemplateEngineProtocol . This class accepts a generic argument T which should be the template class, and it specifies two methods: from typing import Protocol , Union , List from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : Union [ DirectoryPath , List [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... Once you have your custom engine you can register it as you would the built-in engines.","title":"Defining a Custom Template Engine"},{"location":"usage/16-templating/0-template-engines/#modifying-the-template-engine-instance","text":"TemplateConfig accepts the engine_callback keyword arg which provides a way to modify the instantiated template engine instance. For example: from starlite import TemplateConfig from starlite.template.jinja import JinjaTemplateEngine def engine_callback ( jinja_engine : JinjaTemplateEngine ) -> JinjaTemplateEngine : jinja_engine . engine . globals [ \"key\" ] = \"value\" return jinja_engine template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine , engine_callback = engine_callback ) The callback should receive a single argument which will be the instantiated engine, and must return the instantiated engine.","title":"Modifying the Template Engine Instance"},{"location":"usage/16-templating/1-template-context/","text":"Template Context Both Jinja and Mako support passing a context object to the template as well as defining callables that will be available inside the template. Access the request instance through context Starlite injects the current request instance into the template context under request key, which enables accessing the request and through it the app etc. For example, lets assume there is some value stored on the app.state.some_key , we could thus inject it into a Jinja template by doing something like this: < html > < body > < div > < span > My state value: {{request.app.state.some_key}} </ span > </ div > </ body > </ html > Or using a Mako: < html > < body > < div > < span > My state value: ${request.app.state.some_key} </ span > </ div > </ body > </ html > Adding CSRF Inputs Similar to other frameworks such as Django or Laravel, Starlite offers an easy way to add a hidden <input> element to an html form that contains a CSRF token. To use this functionality, you should first configure CSRF protection for the application. With that in place, you can now insert the CSRF input field inside an HTML form: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > {{csrf_input}} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > Or using the Mako syntax: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > ${csrf_input} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > The input is hidden so users cannot see and interact with it. It will though be sent back to the server when submitted, and the CSRF middleware will check that the token is valid. Passing Template Context Passing context to the template is very simple - its one of the kwargs expected by the Template container, so simply pass a string keyed dictionary of values: from starlite import Template , get @get ( path = \"/info\" ) def info () -> Template : return Template ( name = \"info.html\" , context = { \"numbers\" : \"1234567890\" })","title":"Template Context"},{"location":"usage/16-templating/1-template-context/#template-context","text":"Both Jinja and Mako support passing a context object to the template as well as defining callables that will be available inside the template.","title":"Template Context"},{"location":"usage/16-templating/1-template-context/#access-the-request-instance-through-context","text":"Starlite injects the current request instance into the template context under request key, which enables accessing the request and through it the app etc. For example, lets assume there is some value stored on the app.state.some_key , we could thus inject it into a Jinja template by doing something like this: < html > < body > < div > < span > My state value: {{request.app.state.some_key}} </ span > </ div > </ body > </ html > Or using a Mako: < html > < body > < div > < span > My state value: ${request.app.state.some_key} </ span > </ div > </ body > </ html >","title":"Access the request instance through context"},{"location":"usage/16-templating/1-template-context/#adding-csrf-inputs","text":"Similar to other frameworks such as Django or Laravel, Starlite offers an easy way to add a hidden <input> element to an html form that contains a CSRF token. To use this functionality, you should first configure CSRF protection for the application. With that in place, you can now insert the CSRF input field inside an HTML form: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > {{csrf_input}} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > Or using the Mako syntax: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > ${csrf_input} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > The input is hidden so users cannot see and interact with it. It will though be sent back to the server when submitted, and the CSRF middleware will check that the token is valid.","title":"Adding CSRF Inputs"},{"location":"usage/16-templating/1-template-context/#passing-template-context","text":"Passing context to the template is very simple - its one of the kwargs expected by the Template container, so simply pass a string keyed dictionary of values: from starlite import Template , get @get ( path = \"/info\" ) def info () -> Template : return Template ( name = \"info.html\" , context = { \"numbers\" : \"1234567890\" })","title":"Passing Template Context"},{"location":"usage/16-templating/2-template-functions/","text":"Template Callables Both Jinja and Mako allow users to define custom callables that are ran inside the template. Starlite builds on this and offers some functions out of the box. The url_for Callable To access urls for route handlers you can use the url_for function. Its signature and behaviour matches route_reverse behaviour. More details about route handler indexing can be found here The csrf_token Callable This function returns the request's unique csrf_token . You can use this if you wish to insert the csrf_token into non-HTML based templates, or insert it into HTML templates not using a hidden input field but by some other means, for example inside a special <meta> tag. The url_for_static_asset Callable URLs for static files can be created using the url_for_static_asset function. It's signature and behaviour are identical to app.url_for_static_asset . Registering Template Callables The Starlite TemplateEngineProtocol specifies the method register_template_callable that allows defining a custom callable on a template engine. This method is implemented for the two built in engine and it can be used to register callables that will be inject on the template. The callable should expect one argument - the context dictionary. It can be any callable - a function, method or class that defines the call method. For example: from starlite import TemplateConfig , Starlite from starlite.template.mako import MakoTemplateEngine template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ) def my_template_function ( ctx : dict ) -> str : return ctx . get ( \"my_context_key\" , \"nope\" ) template_config . engine . register_template_callable ( \"check_context_key\" , my_template_function ) app = Starlite ( route_handlers = [ ... ], template_config = template_config , ) The above example defined the function my_template_function as a callable inside the template that can be called using the key check_context_key . Using the Jinja syntax this will be: {{check_context_key}} And using Mako ${check_context_key}","title":"Template Callables"},{"location":"usage/16-templating/2-template-functions/#template-callables","text":"Both Jinja and Mako allow users to define custom callables that are ran inside the template. Starlite builds on this and offers some functions out of the box.","title":"Template Callables"},{"location":"usage/16-templating/2-template-functions/#the-url_for-callable","text":"To access urls for route handlers you can use the url_for function. Its signature and behaviour matches route_reverse behaviour. More details about route handler indexing can be found here","title":"The url_for Callable"},{"location":"usage/16-templating/2-template-functions/#the-csrf_token-callable","text":"This function returns the request's unique csrf_token . You can use this if you wish to insert the csrf_token into non-HTML based templates, or insert it into HTML templates not using a hidden input field but by some other means, for example inside a special <meta> tag.","title":"The csrf_token Callable"},{"location":"usage/16-templating/2-template-functions/#the-url_for_static_asset-callable","text":"URLs for static files can be created using the url_for_static_asset function. It's signature and behaviour are identical to app.url_for_static_asset .","title":"The url_for_static_asset Callable"},{"location":"usage/16-templating/2-template-functions/#registering-template-callables","text":"The Starlite TemplateEngineProtocol specifies the method register_template_callable that allows defining a custom callable on a template engine. This method is implemented for the two built in engine and it can be used to register callables that will be inject on the template. The callable should expect one argument - the context dictionary. It can be any callable - a function, method or class that defines the call method. For example: from starlite import TemplateConfig , Starlite from starlite.template.mako import MakoTemplateEngine template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ) def my_template_function ( ctx : dict ) -> str : return ctx . get ( \"my_context_key\" , \"nope\" ) template_config . engine . register_template_callable ( \"check_context_key\" , my_template_function ) app = Starlite ( route_handlers = [ ... ], template_config = template_config , ) The above example defined the function my_template_function as a callable inside the template that can be called using the key check_context_key . Using the Jinja syntax this will be: {{check_context_key}} And using Mako ${check_context_key}","title":"Registering Template Callables"},{"location":"usage/2-route-handlers/0-route-handlers-concept/","text":"Route Handlers Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite. For example: from starlite import MediaType , get @get ( \"/\" , media_type = MediaType . TEXT ) def greet () -> str : return \"hello world\" In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path \"/\" and the http verb GET . In this case it will be a http response with a \"Content-Type\" header of text/plain . What the decorator does, is wrap the function or method within a class instance that inherits from starlite.handlers.base.BaseRouteHandler . These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation. Declaring Path(s) All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the path key word: from starlite import get @get ( path = \"/some-path\" ) def my_route_handler () -> None : ... It can also be passed as an argument without the key-word: from starlite import get @get ( \"/some-path\" ) def my_route_handler () -> None : ... And the value for this argument can be either a string path, as in the above examples, or a list of string paths: from starlite import get @get ([ \"/some-path\" , \"/some-other-path\" ]) def my_route_handler () -> None : ... This is particularly useful when you want to have optional path parameters : from starlite import get @get ( [ \"/some-path\" , \"/some-path/{some_id:int}\" ], ) def my_route_handler ( some_id : int = 1 ) -> None : ... Handler Function Kwargs Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters request data dependencies Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally: cookies : injects the request cookies as a parsed dictionary. headers : injects the request headers as an instance of starlette.datastructures.Headers - which is a case-insensitive mapping. query : injects the request query_params as a parsed dictionary. request : injects the starlite.connection.Request instance. Available only for http route handlers scope : injects the ASGI scope dictionary. socket : injects the starlite.connection.WebSocket instance. Available only for websocket handlers state : injects a copy of the application state . For example: from typing import Any , Dict from starlite import State , Request , get from starlette.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ... Tip You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite Handler Function Type Annotations Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an ImproperlyConfiguredException will be raised during the application boot-up process. There are several reasons for why this limitation is enforced: to ensure best practices to ensure consistent OpenAPI schema generation to allow Starlite to compute during the application bootstrap all the kwargs required by a function","title":"Route Handlers"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#route-handlers","text":"Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite. For example: from starlite import MediaType , get @get ( \"/\" , media_type = MediaType . TEXT ) def greet () -> str : return \"hello world\" In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path \"/\" and the http verb GET . In this case it will be a http response with a \"Content-Type\" header of text/plain . What the decorator does, is wrap the function or method within a class instance that inherits from starlite.handlers.base.BaseRouteHandler . These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation.","title":"Route Handlers"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#declaring-paths","text":"All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the path key word: from starlite import get @get ( path = \"/some-path\" ) def my_route_handler () -> None : ... It can also be passed as an argument without the key-word: from starlite import get @get ( \"/some-path\" ) def my_route_handler () -> None : ... And the value for this argument can be either a string path, as in the above examples, or a list of string paths: from starlite import get @get ([ \"/some-path\" , \"/some-other-path\" ]) def my_route_handler () -> None : ... This is particularly useful when you want to have optional path parameters : from starlite import get @get ( [ \"/some-path\" , \"/some-path/{some_id:int}\" ], ) def my_route_handler ( some_id : int = 1 ) -> None : ...","title":"Declaring Path(s)"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#handler-function-kwargs","text":"Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters request data dependencies Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally: cookies : injects the request cookies as a parsed dictionary. headers : injects the request headers as an instance of starlette.datastructures.Headers - which is a case-insensitive mapping. query : injects the request query_params as a parsed dictionary. request : injects the starlite.connection.Request instance. Available only for http route handlers scope : injects the ASGI scope dictionary. socket : injects the starlite.connection.WebSocket instance. Available only for websocket handlers state : injects a copy of the application state . For example: from typing import Any , Dict from starlite import State , Request , get from starlette.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ... Tip You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite","title":"Handler Function Kwargs"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#handler-function-type-annotations","text":"Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an ImproperlyConfiguredException will be raised during the application boot-up process. There are several reasons for why this limitation is enforced: to ensure best practices to ensure consistent OpenAPI schema generation to allow Starlite to compute during the application bootstrap all the kwargs required by a function","title":"Handler Function Type Annotations"},{"location":"usage/2-route-handlers/1-http-route-handlers/","text":"HTTP Route Handlers The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class starlite.handlers.http.HTTPRouteHandler , which is aliased as the decorator called route : from starlite import HttpMethod , route @route ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... As mentioned above, route does is merely an alias for HTTPRouteHandler , thus the below code is equivalent to the one above: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... HTTP Route Handlers Kwargs The route decorator requires an http_method kwarg, which is a member of the enum starlite.enums.HttpMethod or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . See the API Reference for full details on the route decorator and the kwargs it accepts. Semantic Handler Decorators Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from starlite import Partial , delete , get , patch , post , put from pydantic import BaseModel class Resource ( BaseModel ): ... @get ( path = \"/resources\" ) def list_resources () -> list [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of starlite.handlers.http.HTTPRouteHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions. Using Sync Handler Functions You can use both sync and async functions as the base for route handler functions, but which should you use? and when? If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), he most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose. The reason for this is that async code, if written correctly, is non-blocking . That is, async code can be paused and resumed, and it therefore does not interrupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking , and if you use such code in your function it can create performance issues. In this case you should use the sync_to_thread option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution. The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the sync_to_thread option.","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/1-http-route-handlers/#http-route-handlers","text":"The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class starlite.handlers.http.HTTPRouteHandler , which is aliased as the decorator called route : from starlite import HttpMethod , route @route ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... As mentioned above, route does is merely an alias for HTTPRouteHandler , thus the below code is equivalent to the one above: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ...","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/1-http-route-handlers/#http-route-handlers-kwargs","text":"The route decorator requires an http_method kwarg, which is a member of the enum starlite.enums.HttpMethod or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . See the API Reference for full details on the route decorator and the kwargs it accepts.","title":"HTTP Route Handlers Kwargs"},{"location":"usage/2-route-handlers/1-http-route-handlers/#semantic-handler-decorators","text":"Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from starlite import Partial , delete , get , patch , post , put from pydantic import BaseModel class Resource ( BaseModel ): ... @get ( path = \"/resources\" ) def list_resources () -> list [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of starlite.handlers.http.HTTPRouteHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions.","title":"Semantic Handler Decorators"},{"location":"usage/2-route-handlers/1-http-route-handlers/#using-sync-handler-functions","text":"You can use both sync and async functions as the base for route handler functions, but which should you use? and when? If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), he most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose. The reason for this is that async code, if written correctly, is non-blocking . That is, async code can be paused and resumed, and it therefore does not interrupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking , and if you use such code in your function it can create performance issues. In this case you should use the sync_to_thread option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution. The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the sync_to_thread option.","title":"Using Sync Handler Functions"},{"location":"usage/2-route-handlers/2-websocket-route-handlers/","text":"Websocket Route Handlers Starlite supports Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is an alias of the class starlite.handlers.websocket.WebsocketRouteHandler . Thus, the below code is equivalent to the one above: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. they must have a return annotation of None . they must be async functions. These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised. Note OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers. See the API Reference for full details on the websocket decorator and the kwargs it accepts.","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/2-websocket-route-handlers/#websocket-route-handlers","text":"Starlite supports Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is an alias of the class starlite.handlers.websocket.WebsocketRouteHandler . Thus, the below code is equivalent to the one above: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. they must have a return annotation of None . they must be async functions. These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised. Note OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers. See the API Reference for full details on the websocket decorator and the kwargs it accepts.","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/","text":"ASGI Route Handlers If you need to write your own ASGI application, you can do so using the asgi decorator: from starlite.types import Scope , Receive , Send from starlite.enums import MediaType from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import Response , asgi @asgi ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ( { \"hello\" : \"world\" }, status_code = HTTP_200_OK , media_type = MediaType . JSON ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST , media_type = MediaType . JSON , ) await response ( scope = scope , receive = receive , send = send ) Like other route handlers, the asgi decorator is an alias of the class starlite.handlers.asgi.ASGIRouteHandler . Thus, the code below is equivalent to the one above: from starlite.types import Scope , Receive , Send from starlite.enums import MediaType from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import ASGIRouteHandler , Response @ASGIRouteHandler ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ( { \"hello\" : \"world\" }, status_code = HTTP_200_OK , media_type = MediaType . JSON ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST , media_type = MediaType . JSON , ) await response ( scope = scope , receive = receive , send = send ) Limitations of ASGI route handlers In difference to the other route handlers, the asgi route handler accepts only 3 kwargs that must be defined: scope , a mapping of values describing the ASGI connection. It always includes a type key, with the values being either http or websocket , and a path key. If the type is http , the scope dictionary will also include a method key with the value being one of DELETE, GET, POST, PATCH, PUT, HEAD . receive , an injected function by which the ASGI application receives messages. send , an injected function by which the ASGI application sends messages. You can read more about these in the ASGI specification . Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised. See the API Reference for full details on the asgi decorator and the kwargs it accepts.","title":"ASGI Route Handlers"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/#asgi-route-handlers","text":"If you need to write your own ASGI application, you can do so using the asgi decorator: from starlite.types import Scope , Receive , Send from starlite.enums import MediaType from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import Response , asgi @asgi ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ( { \"hello\" : \"world\" }, status_code = HTTP_200_OK , media_type = MediaType . JSON ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST , media_type = MediaType . JSON , ) await response ( scope = scope , receive = receive , send = send ) Like other route handlers, the asgi decorator is an alias of the class starlite.handlers.asgi.ASGIRouteHandler . Thus, the code below is equivalent to the one above: from starlite.types import Scope , Receive , Send from starlite.enums import MediaType from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import ASGIRouteHandler , Response @ASGIRouteHandler ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ( { \"hello\" : \"world\" }, status_code = HTTP_200_OK , media_type = MediaType . JSON ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST , media_type = MediaType . JSON , ) await response ( scope = scope , receive = receive , send = send )","title":"ASGI Route Handlers"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/#limitations-of-asgi-route-handlers","text":"In difference to the other route handlers, the asgi route handler accepts only 3 kwargs that must be defined: scope , a mapping of values describing the ASGI connection. It always includes a type key, with the values being either http or websocket , and a path key. If the type is http , the scope dictionary will also include a method key with the value being one of DELETE, GET, POST, PATCH, PUT, HEAD . receive , an injected function by which the ASGI application receives messages. send , an injected function by which the ASGI application sends messages. You can read more about these in the ASGI specification . Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised. See the API Reference for full details on the asgi decorator and the kwargs it accepts.","title":"Limitations of ASGI route handlers"},{"location":"usage/2-route-handlers/4-route-handler-indexing/","text":"Route Handler Indexing You can provide in all route handler decorators a name kwarg. The value for this kwarg must be unique , otherwise ImproperlyConfiguredException exception will be raised. Default value for name is value returned by handler.__str__ which should be the full dotted path to the handler (e.g. app.controllers.projects.list for list function residing in app/controllers/projects.py file). name can be used to dynamically retrieve (i.e. during runtime) a mapping containing the route handler instance and paths, also it can be used to build a URL path for that handler: from starlite import Starlite , Request , Redirect , NotFoundException , get @get ( \"/abc\" , name = \"one\" ) def handler_one () -> None : pass @get ( \"/xyz\" , name = \"two\" ) def handler_two () -> None : pass @get ( \"/def/{param:int}\" , name = \"three\" ) def handler_three ( param : int ) -> None : pass @get ( \"/{handler_name:str}\" , name = \"four\" ) def handler_four ( request : Request , name : str ) -> Redirect : handler_index = request . app . get_handler_index_by_name ( name ) if not handler_index : raise NotFoundException ( f \"no handler matching the name { name } was found\" ) # handler_index == { \"paths\": [\"/\"], \"handler\": ..., \"qualname\": ... } # do something with the handler index below, e.g. send a redirect response to the handler, or access # handler.opt and some values stored there etc. return Redirect ( path = handler_index [ \"paths\" ][ 0 ]) @get ( \"/redirect/{param_value:int}\" , name = \"five\" ) def handler_five ( request : Request , param_value : int ) -> Redirect : path = request . app . route_reverse ( \"three\" , param = param_value ) return Redirect ( path = path ) app = Starlite ( route_handlers = [ handler_one , handler_two , handler_three ]) route_reverse will raise NoMatchRouteFoundException if route with given name was not found or if any of path parameters is missing or if any of passed path parameters types do not match types in the respective route declaration. However, str is accepted in place of datetime , date , time , timedelta , float , and Path parameters, so you can apply custom formatting and pass the result to route_reverse . If handler has multiple paths attached to it route_reverse will return the path that consumes the most number of keywords arguments passed to the function. from starlite import get , Request @get ( [ \"/some-path\" , \"/some-path/{id:int}\" , \"/some-path/{id:int}/{val:str}\" ], name = \"handler_name\" , ) def handler ( id : int = 1 , val : str = \"default\" ) -> None : ... @get ( \"/path-info\" ) def path_info ( request : Request ) -> str : path_optional = request . app . route_reverse ( \"handler_name\" ) # /some-path` path_partial = request . app . route_reverse ( \"handler_name\" , id = 100 ) # /some-path/100 path_full = request . app . route_reverse ( \"handler_name\" , id = 100 , val = \"value\" ) # /some-path/100/value` return f \" { path_optional } { path_partial } { path_full } \" If there are multiple paths attached to a handler that have the same path parameters (for example indexed handler has been registered on multiple routers) the result of route_reverse is not defined. The function will return a formatted path, but it might be picked randomly so reversing urls in such cases is highly discouraged. If you have access to request instance you can make reverse lookups using url_for function which is similar to route_reverse but returns absolute URL.","title":"Route Handler Indexing"},{"location":"usage/2-route-handlers/4-route-handler-indexing/#route-handler-indexing","text":"You can provide in all route handler decorators a name kwarg. The value for this kwarg must be unique , otherwise ImproperlyConfiguredException exception will be raised. Default value for name is value returned by handler.__str__ which should be the full dotted path to the handler (e.g. app.controllers.projects.list for list function residing in app/controllers/projects.py file). name can be used to dynamically retrieve (i.e. during runtime) a mapping containing the route handler instance and paths, also it can be used to build a URL path for that handler: from starlite import Starlite , Request , Redirect , NotFoundException , get @get ( \"/abc\" , name = \"one\" ) def handler_one () -> None : pass @get ( \"/xyz\" , name = \"two\" ) def handler_two () -> None : pass @get ( \"/def/{param:int}\" , name = \"three\" ) def handler_three ( param : int ) -> None : pass @get ( \"/{handler_name:str}\" , name = \"four\" ) def handler_four ( request : Request , name : str ) -> Redirect : handler_index = request . app . get_handler_index_by_name ( name ) if not handler_index : raise NotFoundException ( f \"no handler matching the name { name } was found\" ) # handler_index == { \"paths\": [\"/\"], \"handler\": ..., \"qualname\": ... } # do something with the handler index below, e.g. send a redirect response to the handler, or access # handler.opt and some values stored there etc. return Redirect ( path = handler_index [ \"paths\" ][ 0 ]) @get ( \"/redirect/{param_value:int}\" , name = \"five\" ) def handler_five ( request : Request , param_value : int ) -> Redirect : path = request . app . route_reverse ( \"three\" , param = param_value ) return Redirect ( path = path ) app = Starlite ( route_handlers = [ handler_one , handler_two , handler_three ]) route_reverse will raise NoMatchRouteFoundException if route with given name was not found or if any of path parameters is missing or if any of passed path parameters types do not match types in the respective route declaration. However, str is accepted in place of datetime , date , time , timedelta , float , and Path parameters, so you can apply custom formatting and pass the result to route_reverse . If handler has multiple paths attached to it route_reverse will return the path that consumes the most number of keywords arguments passed to the function. from starlite import get , Request @get ( [ \"/some-path\" , \"/some-path/{id:int}\" , \"/some-path/{id:int}/{val:str}\" ], name = \"handler_name\" , ) def handler ( id : int = 1 , val : str = \"default\" ) -> None : ... @get ( \"/path-info\" ) def path_info ( request : Request ) -> str : path_optional = request . app . route_reverse ( \"handler_name\" ) # /some-path` path_partial = request . app . route_reverse ( \"handler_name\" , id = 100 ) # /some-path/100 path_full = request . app . route_reverse ( \"handler_name\" , id = 100 , val = \"value\" ) # /some-path/100/value` return f \" { path_optional } { path_partial } { path_full } \" If there are multiple paths attached to a handler that have the same path parameters (for example indexed handler has been registered on multiple routers) the result of route_reverse is not defined. The function will return a formatted path, but it might be picked randomly so reversing urls in such cases is highly discouraged. If you have access to request instance you can make reverse lookups using url_for function which is similar to route_reverse but returns absolute URL.","title":"Route Handler Indexing"},{"location":"usage/2-route-handlers/5-handler-opts/","text":"Handler 'opts' All route handler decorators accept a key called opt which accepts a dictionary of arbitrary values, e.g. from starlite import get @get ( \"/\" , opt = { \"my_key\" : \"some-value\" }) def handler () -> None : ... This dictionary can be accessed by route guard , or by accessing the route_handler property on a request ( request.route_handler.opt ), or using the ASGI scope object directly ( scope[\"route_handler\"].opt ). Passing **kwargs to handlers Building on opts , you can pass any arbitrary kwarg to the route handler decorator, and it will be automatically set as a key in the opt dictionary: from starlite import get @get ( \"/\" , my_key = \"some-value\" ) def handler () -> None : ... assert handler . opt [ \"my_key\" ] == \"some-value\"","title":"Handler 'opts'"},{"location":"usage/2-route-handlers/5-handler-opts/#handler-opts","text":"All route handler decorators accept a key called opt which accepts a dictionary of arbitrary values, e.g. from starlite import get @get ( \"/\" , opt = { \"my_key\" : \"some-value\" }) def handler () -> None : ... This dictionary can be accessed by route guard , or by accessing the route_handler property on a request ( request.route_handler.opt ), or using the ASGI scope object directly ( scope[\"route_handler\"].opt ).","title":"Handler 'opts'"},{"location":"usage/2-route-handlers/5-handler-opts/#passing-kwargs-to-handlers","text":"Building on opts , you can pass any arbitrary kwarg to the route handler decorator, and it will be automatically set as a key in the opt dictionary: from starlite import get @get ( \"/\" , my_key = \"some-value\" ) def handler () -> None : ... assert handler . opt [ \"my_key\" ] == \"some-value\"","title":"Passing **kwargs to handlers"},{"location":"usage/3-parameters/0-path-parameters/","text":"Path Parameters Path parameters are parameters declared as part of the path component of the URL. They are declared using a simple syntax {param_name:param_type} : from starlite import get from pydantic import BaseModel class User ( BaseModel ): ... @get ( \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : ... In the above there are two components: The path parameter is defined in the @get decorator, which declares both the parameter's name ( user_id ) and type ( int ). The decorated function get_user defines a parameter with the same name as the parameter defined in the path kwarg. The correlation of parameter name ensures that the value of the path parameter will be injected into the function when it's called. Supported Path Parameter Types Currently, the following types are supported: date : Accepts date strings and time stamps. datetime : Accepts date-time strings and time stamps. decimal : Accepts decimal values and floats. float : Accepts ints and floats. int : Accepts ints and floats. path : Accepts valid POSIX paths. str : Accepts all string values. time : Accepts time strings with optional timezone compatible with pydantic formats. timedelta : Accepts duration strings compatible with the pydantic formats. uuid : Accepts all uuid values. The types declared in the path parameter and the function do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: from datetime import datetime from starlite import get from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> list [ Order ]: ... The parameter defined inside the path kwarg is typed as int , because the value passed as part of the request will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, it's fine to omit it. It will still be validated and added to the openapi schema correctly. Extra Validation and Documentation for Path Params If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from pydantic_openapi_schema.v3_1_0.example import Example from pydantic_openapi_schema.v3_1_0.external_documentation import ( ExternalDocumentation , ) from starlite import get , Parameter from pydantic import BaseModel , conint , Json class Version ( BaseModel ): id : conint ( ge = 1 , le = 10 ) specs : Json @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = ExternalDocumentation ( url = \"https://mywebsite.com/documentation/product#versions\" ), ) ) -> Version : ... In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema.","title":"Path Parameters"},{"location":"usage/3-parameters/0-path-parameters/#path-parameters","text":"Path parameters are parameters declared as part of the path component of the URL. They are declared using a simple syntax {param_name:param_type} : from starlite import get from pydantic import BaseModel class User ( BaseModel ): ... @get ( \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : ... In the above there are two components: The path parameter is defined in the @get decorator, which declares both the parameter's name ( user_id ) and type ( int ). The decorated function get_user defines a parameter with the same name as the parameter defined in the path kwarg. The correlation of parameter name ensures that the value of the path parameter will be injected into the function when it's called.","title":"Path Parameters"},{"location":"usage/3-parameters/0-path-parameters/#supported-path-parameter-types","text":"Currently, the following types are supported: date : Accepts date strings and time stamps. datetime : Accepts date-time strings and time stamps. decimal : Accepts decimal values and floats. float : Accepts ints and floats. int : Accepts ints and floats. path : Accepts valid POSIX paths. str : Accepts all string values. time : Accepts time strings with optional timezone compatible with pydantic formats. timedelta : Accepts duration strings compatible with the pydantic formats. uuid : Accepts all uuid values. The types declared in the path parameter and the function do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: from datetime import datetime from starlite import get from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> list [ Order ]: ... The parameter defined inside the path kwarg is typed as int , because the value passed as part of the request will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, it's fine to omit it. It will still be validated and added to the openapi schema correctly.","title":"Supported Path Parameter Types"},{"location":"usage/3-parameters/0-path-parameters/#extra-validation-and-documentation-for-path-params","text":"If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from pydantic_openapi_schema.v3_1_0.example import Example from pydantic_openapi_schema.v3_1_0.external_documentation import ( ExternalDocumentation , ) from starlite import get , Parameter from pydantic import BaseModel , conint , Json class Version ( BaseModel ): id : conint ( ge = 1 , le = 10 ) specs : Json @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = ExternalDocumentation ( url = \"https://mywebsite.com/documentation/product#versions\" ), ) ) -> Version : ... In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema.","title":"Extra Validation and Documentation for Path Params"},{"location":"usage/3-parameters/1-query-parameters/","text":"Query Parameters To define query parameters simply define them as kwargs in your function declaration: from datetime import datetime from typing import Optional from starlite import get from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders\" ) def get_orders ( page : int , brands : list [ str ], page_size : int = 10 , from_date : Optional [ datetime ] = None , to_date : Optional [ datetime ] = None , ) -> list [ Order ]: ... The above is a rather classic example of a paginated \"GET\" request: page is a required query parameter of type int . It has no default value and as such has to be provided or a ValidationException will be raised. page_size is a required query parameter of type int as well, but it has a default value - so it can be omitted in the request. brands is an optional list of strings with a default None value. from_date and to_date are optional date-time values that have a default None value. These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. This works great, but what happens when the request is sent with a non-python naming scheme, such as camelCase ? You could of course simply rename your variables accordingly: from datetime import datetime from typing import Optional from starlite import get from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders\" ) def get_orders ( page : int , brands : list [ str ], pageSize : int = 10 , fromDate : Optional [ datetime ] = None , toDate : Optional [ datetime ] = None , ) -> list [ Order ]: ... This doesn't look so good, and tools such as PyLint will complain. The solution here is to use the Parameter function : from datetime import datetime from typing import Optional from starlite import get , Parameter from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders\" ) def get_orders ( page : int , page_size : int = Parameter ( query = \"pageSize\" , gt = 0 , le = 100 ), brands : list [ str ] = Parameter ( min_items = 2 , max_items = 5 ), from_Date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), to_date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), ) -> list [ Order ]: ... As you can see, specifying the \"query\" kwarg allows us to remap from one key to another. Furthermore, we can use Parameter for extended validation and documentation, as is done for page_size .","title":"Query Parameters"},{"location":"usage/3-parameters/1-query-parameters/#query-parameters","text":"To define query parameters simply define them as kwargs in your function declaration: from datetime import datetime from typing import Optional from starlite import get from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders\" ) def get_orders ( page : int , brands : list [ str ], page_size : int = 10 , from_date : Optional [ datetime ] = None , to_date : Optional [ datetime ] = None , ) -> list [ Order ]: ... The above is a rather classic example of a paginated \"GET\" request: page is a required query parameter of type int . It has no default value and as such has to be provided or a ValidationException will be raised. page_size is a required query parameter of type int as well, but it has a default value - so it can be omitted in the request. brands is an optional list of strings with a default None value. from_date and to_date are optional date-time values that have a default None value. These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. This works great, but what happens when the request is sent with a non-python naming scheme, such as camelCase ? You could of course simply rename your variables accordingly: from datetime import datetime from typing import Optional from starlite import get from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders\" ) def get_orders ( page : int , brands : list [ str ], pageSize : int = 10 , fromDate : Optional [ datetime ] = None , toDate : Optional [ datetime ] = None , ) -> list [ Order ]: ... This doesn't look so good, and tools such as PyLint will complain. The solution here is to use the Parameter function : from datetime import datetime from typing import Optional from starlite import get , Parameter from pydantic import BaseModel class Order ( BaseModel ): ... @get ( path = \"/orders\" ) def get_orders ( page : int , page_size : int = Parameter ( query = \"pageSize\" , gt = 0 , le = 100 ), brands : list [ str ] = Parameter ( min_items = 2 , max_items = 5 ), from_Date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), to_date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), ) -> list [ Order ]: ... As you can see, specifying the \"query\" kwarg allows us to remap from one key to another. Furthermore, we can use Parameter for extended validation and documentation, as is done for page_size .","title":"Query Parameters"},{"location":"usage/3-parameters/2-header-and-cookie-parameters/","text":"Header and Cookie Parameters Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import UUID4 from starlite import get , Parameter from pydantic import BaseModel class User ( BaseModel ): ... @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , token : str = Parameter ( header = \"X-API-KEY\" ), cookie : str = Parameter ( cookie = \"my-cookie-param\" ), ) -> User : ... As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters.","title":"Header and Cookie Parameters"},{"location":"usage/3-parameters/2-header-and-cookie-parameters/#header-and-cookie-parameters","text":"Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import UUID4 from starlite import get , Parameter from pydantic import BaseModel class User ( BaseModel ): ... @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , token : str = Parameter ( header = \"X-API-KEY\" ), cookie : str = Parameter ( cookie = \"my-cookie-param\" ), ) -> User : ... As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters.","title":"Header and Cookie Parameters"},{"location":"usage/3-parameters/3-the-parameter-function/","text":"The Parameter Function Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. See the API Reference for full details on the Parameter function and the kwargs it accepts.","title":"The Parameter Function"},{"location":"usage/3-parameters/3-the-parameter-function/#the-parameter-function","text":"Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. See the API Reference for full details on the Parameter function and the kwargs it accepts.","title":"The Parameter Function"},{"location":"usage/3-parameters/4-layered-parameters/","text":"Layered Parameters As part of Starlite's \"layered\" architecture, you can declare parameters not only as part of individual route handler functions, but also on other layers of the application: from starlite import Starlite , Controller , Router , Parameter , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> dict : ... router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) In the above we declare parameters on the app, router and controller levels in addition to those declared in the route handler. Let's look at these closer. app_param is a cookie param with the key special-cookie . We type it as str by passing this as an arg to the Parameter function. This is required for us to get typing in the OpenAPI docs. Additionally, this parameter is assumed to be required because it is not explicitly declared as required=False . This is important because the route handler function does not declare a parameter called app_param at all, but it will still require this param to be sent as part of the request of validation will fail. router_param is a header param with the key MyHeader . Because its declared as required=False , it will not fail validation if not present unless explicitly declared by a route handler - and in this case it is. Thus, it is actually required for the router handler function that declares it as an str and not an Optional[str] . If a string value is provided, it will be tested against the provided regex. controller_param is a query param with the key controller_param . It has an lt=100 defined on the controller, which means the provided value must be less than 100. Yet the route handler re-declares it with an lt=50 , which means for the route handler this value must be less than 50. Finally local_param is a route handler local query parameter, and path_param is a path parameter. Note You cannot declare path parameters in different application layers. The reason for this is to ensure simplicity - otherwise parameter resolution becomes very difficult to do correctly.","title":"Layered Parameters"},{"location":"usage/3-parameters/4-layered-parameters/#layered-parameters","text":"As part of Starlite's \"layered\" architecture, you can declare parameters not only as part of individual route handler functions, but also on other layers of the application: from starlite import Starlite , Controller , Router , Parameter , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> dict : ... router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) In the above we declare parameters on the app, router and controller levels in addition to those declared in the route handler. Let's look at these closer. app_param is a cookie param with the key special-cookie . We type it as str by passing this as an arg to the Parameter function. This is required for us to get typing in the OpenAPI docs. Additionally, this parameter is assumed to be required because it is not explicitly declared as required=False . This is important because the route handler function does not declare a parameter called app_param at all, but it will still require this param to be sent as part of the request of validation will fail. router_param is a header param with the key MyHeader . Because its declared as required=False , it will not fail validation if not present unless explicitly declared by a route handler - and in this case it is. Thus, it is actually required for the router handler function that declares it as an str and not an Optional[str] . If a string value is provided, it will be tested against the provided regex. controller_param is a query param with the key controller_param . It has an lt=100 defined on the controller, which means the provided value must be less than 100. Yet the route handler re-declares it with an lt=50 , which means for the route handler this value must be less than 50. Finally local_param is a route handler local query parameter, and path_param is a path parameter. Note You cannot declare path parameters in different application layers. The reason for this is to ensure simplicity - otherwise parameter resolution becomes very difficult to do correctly.","title":"Layered Parameters"},{"location":"usage/4-request-data/0-request-data/","text":"Request Data For http requests except GET requests, you can access the request body by specifying the data kwarg in your handler function or method: from starlite import post from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... The type of data does not need to be a pydantic model - it can be any supported type, e.g. a dataclass, or a TypedDict : from starlite import post from dataclasses import dataclass @dataclass () class User : ... @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... It can also be simple types such as str , dict etc. or classes supported by plugins .","title":"Request Data"},{"location":"usage/4-request-data/0-request-data/#request-data","text":"For http requests except GET requests, you can access the request body by specifying the data kwarg in your handler function or method: from starlite import post from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... The type of data does not need to be a pydantic model - it can be any supported type, e.g. a dataclass, or a TypedDict : from starlite import post from dataclasses import dataclass @dataclass () class User : ... @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... It can also be simple types such as str , dict etc. or classes supported by plugins .","title":"Request Data"},{"location":"usage/4-request-data/1-the-body-function/","text":"The Body Function You can use the Body function to customize the OpenAPI documentation for the request body schema or to control its validation: from starlite import Body , post from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ) ) -> User : ... See the API Reference for full details on the Body function and the kwargs it accepts.","title":"The Body Function"},{"location":"usage/4-request-data/1-the-body-function/#the-body-function","text":"You can use the Body function to customize the OpenAPI documentation for the request body schema or to control its validation: from starlite import Body , post from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ) ) -> User : ... See the API Reference for full details on the Body function and the kwargs it accepts.","title":"The Body Function"},{"location":"usage/4-request-data/2-url-encoded-form-data/","text":"URL Encoded Form Data To access data sent as url-encoded form data , i.e. application/x-www-form-urlencoded Content-Type header, use Body and specify RequestEncodingType.URL_ENCODED as the media_type : from starlite import Body , post , RequestEncodingType from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : ... The above ensures that Starlite will inject data using the request.form() method rather than request.json() and set the correct media-type in the OpenAPI schema. Important url encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures.","title":"URL Encoded Form Data"},{"location":"usage/4-request-data/2-url-encoded-form-data/#url-encoded-form-data","text":"To access data sent as url-encoded form data , i.e. application/x-www-form-urlencoded Content-Type header, use Body and specify RequestEncodingType.URL_ENCODED as the media_type : from starlite import Body , post , RequestEncodingType from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : ... The above ensures that Starlite will inject data using the request.form() method rather than request.json() and set the correct media-type in the OpenAPI schema. Important url encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures.","title":"URL Encoded Form Data"},{"location":"usage/4-request-data/3-multipart-form-data/","text":"MultiPart Form Data Multipart formdata supports complex data including file uploads and nested dictionaries. Note Starlite uses a dedicated library for parsing multipart data - starlite-multipart , which offers strong performance and supports large file uploads. You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from starlite import Body , RequestEncodingType , post from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : ... Accessing Files In case of files uploaded, Starlette transforms the results into an instance of starlette.datastructures.UploadFile , which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : from starlite import Body , UploadFile , RequestEncodingType , post @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... To access multiple files with known filenames, you can use a pydantic model: from pydantic import BaseModel , BaseConfig from starlite import Body , RequestEncodingType , UploadFile , post class FormData ( BaseModel ): cv : UploadFile image : UploadFile class Config ( BaseConfig ): arbitrary_types_allowed = True @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... If you do not care about parsing and validation and only want to access the form data as a dictionary, you can use a dict instead: from starlite import Body , RequestEncodingType , UploadFile , post @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ) ) -> None : ... Finally, you can also access the files as a list without the filenames: from starlite import Body , RequestEncodingType , UploadFile , post @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : list [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ...","title":"MultiPart Form Data"},{"location":"usage/4-request-data/3-multipart-form-data/#multipart-form-data","text":"Multipart formdata supports complex data including file uploads and nested dictionaries. Note Starlite uses a dedicated library for parsing multipart data - starlite-multipart , which offers strong performance and supports large file uploads. You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from starlite import Body , RequestEncodingType , post from pydantic import BaseModel class User ( BaseModel ): ... @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : ...","title":"MultiPart Form Data"},{"location":"usage/4-request-data/3-multipart-form-data/#accessing-files","text":"In case of files uploaded, Starlette transforms the results into an instance of starlette.datastructures.UploadFile , which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : from starlite import Body , UploadFile , RequestEncodingType , post @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... To access multiple files with known filenames, you can use a pydantic model: from pydantic import BaseModel , BaseConfig from starlite import Body , RequestEncodingType , UploadFile , post class FormData ( BaseModel ): cv : UploadFile image : UploadFile class Config ( BaseConfig ): arbitrary_types_allowed = True @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... If you do not care about parsing and validation and only want to access the form data as a dictionary, you can use a dict instead: from starlite import Body , RequestEncodingType , UploadFile , post @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ) ) -> None : ... Finally, you can also access the files as a list without the filenames: from starlite import Body , RequestEncodingType , UploadFile , post @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : list [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ...","title":"Accessing Files"},{"location":"usage/5-responses/0-responses-intro/","text":"HTTP Responses Starlite allows for several ways in which HTTP responses can be specified and handled, each fitting a different use case. The base pattern though is straightforward - simply return a value from a route handler function and let Starlite take care of the rest: from pydantic import BaseModel from starlite import get class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) In the example above, the route handler function returns an instance of the Resource pydantic class. This value will then be used by Starlite to construct an instance of the starlite.response.Response class using defaults values: the response status code will be set to 200 and it's Content-Type header will be set to application/json . The Resource instance will be serialized into JSON and set as the response body.","title":"HTTP Responses"},{"location":"usage/5-responses/0-responses-intro/#http-responses","text":"Starlite allows for several ways in which HTTP responses can be specified and handled, each fitting a different use case. The base pattern though is straightforward - simply return a value from a route handler function and let Starlite take care of the rest: from pydantic import BaseModel from starlite import get class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) In the example above, the route handler function returns an instance of the Resource pydantic class. This value will then be used by Starlite to construct an instance of the starlite.response.Response class using defaults values: the response status code will be set to 200 and it's Content-Type header will be set to application/json . The Resource instance will be serialized into JSON and set as the response body.","title":"HTTP Responses"},{"location":"usage/5-responses/1-media-type/","text":"Media Type You do not have to specify the media_type kwarg in the route handler function if the response should be JSON. But if you wish to return a response other than JSON, you should specify this value. You can use the starlite.enums.MediaType enum for this purpose: from starlite import MediaType , get @get ( \"/resources\" , media_type = MediaType . TEXT ) def retrieve_resource () -> str : return \"The rumbling rabbit ran around the rock\" The value of the media_type kwarg affects both the serialization of response data and the generation of OpenAPI docs. The above example will cause Starlite to serialize the response as a simple bytes string with a Content-Type header value of text/plain . It will also set the corresponding values in the OpenAPI documentation. MediaType has the following members: MediaType.JSON: application/json MediaType.TEXT: text/plain MediaType.HTML: text/html You can also set any IANA referenced media type string as the media_type . While this will still affect the OpenAPI generation as expected, you might need to handle serialization using either a custom response with serializer or by serializing the value in the route handler function. JSON Responses As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models numpy ndarray lists containing any of the above elements Since Starlite uses the excellent (and super fast!) orjson library to handle JSON (also in requests), you can use the following values as part of your responses without issue: all UUIDs datetime classes numpy primitives and objects (see orjson docs ) If you need to return other values and would like to extend serialization you can do this using Custom Responses . Text Responses For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" HTML Responses For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.","title":"Media Type"},{"location":"usage/5-responses/1-media-type/#media-type","text":"You do not have to specify the media_type kwarg in the route handler function if the response should be JSON. But if you wish to return a response other than JSON, you should specify this value. You can use the starlite.enums.MediaType enum for this purpose: from starlite import MediaType , get @get ( \"/resources\" , media_type = MediaType . TEXT ) def retrieve_resource () -> str : return \"The rumbling rabbit ran around the rock\" The value of the media_type kwarg affects both the serialization of response data and the generation of OpenAPI docs. The above example will cause Starlite to serialize the response as a simple bytes string with a Content-Type header value of text/plain . It will also set the corresponding values in the OpenAPI documentation. MediaType has the following members: MediaType.JSON: application/json MediaType.TEXT: text/plain MediaType.HTML: text/html You can also set any IANA referenced media type string as the media_type . While this will still affect the OpenAPI generation as expected, you might need to handle serialization using either a custom response with serializer or by serializing the value in the route handler function.","title":"Media Type"},{"location":"usage/5-responses/1-media-type/#json-responses","text":"As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models numpy ndarray lists containing any of the above elements Since Starlite uses the excellent (and super fast!) orjson library to handle JSON (also in requests), you can use the following values as part of your responses without issue: all UUIDs datetime classes numpy primitives and objects (see orjson docs ) If you need to return other values and would like to extend serialization you can do this using Custom Responses .","title":"JSON Responses"},{"location":"usage/5-responses/1-media-type/#text-responses","text":"For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\"","title":"Text Responses"},{"location":"usage/5-responses/1-media-type/#html-responses","text":"For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.","title":"HTML Responses"},{"location":"usage/5-responses/10-custom-responses/","text":"Custom Responses You can use a subclass of starlite.responses.Response and specify it as the response class using the response_class kwarg. For example, lets say we want to handle subclasses of Document from the elasticsearch_dsl package as shown below: from elasticsearch_dsl import Document , Integer , Keyword class MyDocument ( Document ): name = Keyword () level = Integer () type = Keyword () The Document class is not JSON serializable on its own, and as such we cannot simply return it from a route handler function and expect it to be serialized. We could of course convert it to a dictionary of values in the route handler, and then use it. But if we return Document subclasses in many route handlers, it makes sense to create a custom response to handle the serialization. We will therefore create a subclass of starlite.response.Response that implements a serializer method that is capable of handling Document subclasses: from typing import Any , Dict from elasticsearch_dsl import Document from starlite import Response class DocumentResponse ( Response ): def serializer ( self , value : Any ) -> Dict [ str , Any ]: if isinstance ( value , Document ): return value . to_dict () return super () . serializer ( value ) We can now use this in our route handler: from elasticsearch_dsl import Document from starlite import get from my_app.responses import DocumentResponse @get ( path = \"/document\" , response_class = DocumentResponse ) def get_document () -> Document : ... You can specify the response class to use at all levels of your application. On specific route handlers, on a controller, a router even on the app instance itself: from starlite import Controller , Starlite , Router from my_app.responses import DocumentResponse # controller class MyController ( Controller ): path = \"...\" response_class = DocumentResponse # router my_router = Router ( path = \"...\" , route_handlers = [ ... ], response_class = DocumentResponse ) # app my_app = Starlite ( route_handlers = [ ... ], response_class = DocumentResponse ) When you specify a response_class in multiple places, the closest layer to the response handler will take precedence. That is, the response_class specified on the route handler takes precedence over the one specified on the controller or router, which will in turn take precedence over the one specified on the app level. You can therefore easily override response classes as needed.","title":"Custom Responses"},{"location":"usage/5-responses/10-custom-responses/#custom-responses","text":"You can use a subclass of starlite.responses.Response and specify it as the response class using the response_class kwarg. For example, lets say we want to handle subclasses of Document from the elasticsearch_dsl package as shown below: from elasticsearch_dsl import Document , Integer , Keyword class MyDocument ( Document ): name = Keyword () level = Integer () type = Keyword () The Document class is not JSON serializable on its own, and as such we cannot simply return it from a route handler function and expect it to be serialized. We could of course convert it to a dictionary of values in the route handler, and then use it. But if we return Document subclasses in many route handlers, it makes sense to create a custom response to handle the serialization. We will therefore create a subclass of starlite.response.Response that implements a serializer method that is capable of handling Document subclasses: from typing import Any , Dict from elasticsearch_dsl import Document from starlite import Response class DocumentResponse ( Response ): def serializer ( self , value : Any ) -> Dict [ str , Any ]: if isinstance ( value , Document ): return value . to_dict () return super () . serializer ( value ) We can now use this in our route handler: from elasticsearch_dsl import Document from starlite import get from my_app.responses import DocumentResponse @get ( path = \"/document\" , response_class = DocumentResponse ) def get_document () -> Document : ... You can specify the response class to use at all levels of your application. On specific route handlers, on a controller, a router even on the app instance itself: from starlite import Controller , Starlite , Router from my_app.responses import DocumentResponse # controller class MyController ( Controller ): path = \"...\" response_class = DocumentResponse # router my_router = Router ( path = \"...\" , route_handlers = [ ... ], response_class = DocumentResponse ) # app my_app = Starlite ( route_handlers = [ ... ], response_class = DocumentResponse ) When you specify a response_class in multiple places, the closest layer to the response handler will take precedence. That is, the response_class specified on the route handler takes precedence over the one specified on the controller or router, which will in turn take precedence over the one specified on the app level. You can therefore easily override response classes as needed.","title":"Custom Responses"},{"location":"usage/5-responses/2-status-codes/","text":"Status Codes You can control the response status_code by setting the corresponding kwarg to the desired value: from pydantic import BaseModel from starlite import get from starlette.status import HTTP_202_ACCEPTED class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , status_code = HTTP_202_ACCEPTED ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) If status_code is not set by the user, the following defaults are used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Important For status codes < 100 or 204, 304 statuses, no response body is allowed. If you specify a return annotation other than None , an ImproperlyConfiguredException will be raised. Note When using the route decorator with multiple http methods, the default status code is 200 . Note The default for delete is 204 because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can write integers as the value for status_code , e.g. 200 , it's best practice to use constants (also in tests). Starlette includes easy to use statuses that are exported from starlette.status , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the standard library documentation .","title":"Status Codes"},{"location":"usage/5-responses/2-status-codes/#status-codes","text":"You can control the response status_code by setting the corresponding kwarg to the desired value: from pydantic import BaseModel from starlite import get from starlette.status import HTTP_202_ACCEPTED class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , status_code = HTTP_202_ACCEPTED ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) If status_code is not set by the user, the following defaults are used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Important For status codes < 100 or 204, 304 statuses, no response body is allowed. If you specify a return annotation other than None , an ImproperlyConfiguredException will be raised. Note When using the route decorator with multiple http methods, the default status code is 200 . Note The default for delete is 204 because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can write integers as the value for status_code , e.g. 200 , it's best practice to use constants (also in tests). Starlette includes easy to use statuses that are exported from starlette.status , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the standard library documentation .","title":"Status Codes"},{"location":"usage/5-responses/3-returning-responses/","text":"Returning Responses While the default response handling fits most use cases, in some cases you need to be able to return a response instance directly. Starlite allows you to return any class inheriting from the starlette.responses.Response class. Thus, the below example will work perfectly fine: from pydantic import BaseModel from starlite import Response , get from starlite.datastructures import Cookie from starlite.enums import MediaType from starlette.status import HTTP_200_OK class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"MY-HEADER\" : \"xyz\" }, cookies = [ Cookie ( key = \"my-cookie\" , value = \"abc\" )], media_type = MediaType . JSON , status_code = HTTP_200_OK , ) The caveat of using a Starlette response though is that Starlite will not be able to infer the OpenAPI documentation. Annotated Responses To solve this issue, use you can use the starlite.response.Response class which supports type annotations: from pydantic import BaseModel from starlite import Response , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , headers = { \"MY-HEADER\" : \"xyz\" }, cookies = [ Cookie ( \"my-cookie\" , value = \"abc\" )], ) ) As you can see above, the starlite.response.Response class accepts a generic argument - in this case the pydantic model Resource . This allows Starlite to infer from the Response type the correct typing for OpenAPI generation.","title":"Returning Responses"},{"location":"usage/5-responses/3-returning-responses/#returning-responses","text":"While the default response handling fits most use cases, in some cases you need to be able to return a response instance directly. Starlite allows you to return any class inheriting from the starlette.responses.Response class. Thus, the below example will work perfectly fine: from pydantic import BaseModel from starlite import Response , get from starlite.datastructures import Cookie from starlite.enums import MediaType from starlette.status import HTTP_200_OK class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"MY-HEADER\" : \"xyz\" }, cookies = [ Cookie ( key = \"my-cookie\" , value = \"abc\" )], media_type = MediaType . JSON , status_code = HTTP_200_OK , ) The caveat of using a Starlette response though is that Starlite will not be able to infer the OpenAPI documentation.","title":"Returning Responses"},{"location":"usage/5-responses/3-returning-responses/#annotated-responses","text":"To solve this issue, use you can use the starlite.response.Response class which supports type annotations: from pydantic import BaseModel from starlite import Response , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , headers = { \"MY-HEADER\" : \"xyz\" }, cookies = [ Cookie ( \"my-cookie\" , value = \"abc\" )], ) ) As you can see above, the starlite.response.Response class accepts a generic argument - in this case the pydantic model Resource . This allows Starlite to infer from the Response type the correct typing for OpenAPI generation.","title":"Annotated Responses"},{"location":"usage/5-responses/4-response-headers/","text":"Response Headers Starlite allows you to define response headers by using the response_headers kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Starlite , Router , Controller , MediaType , get from starlite.datastructures import ResponseHeader class MyController ( Controller ): path = \"/controller-path\" response_headers = { \"controller-level-header\" : ResponseHeader ( value = \"controller header\" , description = \"controller level header\" ) } @get ( path = \"/\" , response_headers = { \"my-local-header\" : ResponseHeader ( value = \"local header\" , description = \"local level header\" ) }, media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_headers = { \"router-level-header\" : ResponseHeader ( value = \"router header\" , description = \"router level header\" ) }, ) app = Starlite ( route_handlers = [ router ], response_headers = { \"app-level-header\" : ResponseHeader ( value = \"app header\" , description = \"app level header\" ) }, ) In the above example the response returned from my_route_handler will have headers set from each layer of the application using the given key+value combinations. I.e. it will be a dictionary equal to this: { \"my-local-header\" : \"local header\" , \"controller-level-header\" : \"controller header\" , \"router-level-header\" : \"router header\" , \"app-level-header\" : \"app header\" } The respective descriptions will be used for the OpenAPI documentation. Dynamic Headers The above detailed scheme works great for statically configured headers, but how would you go about handling dynamically setting headers? Starlite allows you to set headers dynamically in several ways and below we will detail the two primary patterns. Setting Response Headers Using Annotated Responses We can simply return a response instance directly from the route handler and set the headers dictionary manually as you see fit, e.g.: from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , get from starlite.datastructures import ResponseHeader from starlite.enums import MediaType from random import randint class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 1 , 100 ))}, media_type = MediaType . JSON , status_code = HTTP_200_OK , ) In the above we use the response_headers kwarg to pass the name and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True . Setting Response Headers Using the After Request Hook An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the headers on the corresponding layer: from random import randint from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , Router , get from starlite.datastructures import ResponseHeader from starlite.enums import MediaType class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 100 , 1000 ))}, media_type = MediaType . JSON , status_code = HTTP_200_OK , ) def after_request_handler ( response : Response ) -> Response : response . headers . update ({ \"Random-Header\" : str ( randint ( 1 , 100 ))}) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) In the above we set the response header using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding header specification as required. For example, lets say we have a router level header being set and a local header with the same key but a different value range: from pydantic import BaseModel from starlite import Router , Response , get from starlite.datastructures import ResponseHeader from random import randint class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 100 , 1000 ))}, ) def after_request_handler ( response : Response ) -> Response : response . headers . update ({ \"Random-Header\" : str ( randint ( 1 , 100 ))}) return response router = Router ( route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) # ... Specific Headers Implementation Starlite has a dedicated implementation for a few headers that are commonly used. These headers can be set separately from response_headers in dedicated kwargs available on all layers of the app (individual route handlers, controllers, routers and the app itself). Cache Control Starlite has a dedicated CacheControlHeader class for Cache-Control which allows easy creation and parsing of the header value and provides accessors to its directives. Here is a simple example that shows how to use it: Cache Control Header import time from starlite import Controller , Starlite , get from starlite.datastructures import CacheControlHeader class MyController ( Controller ): cache_control = CacheControlHeader ( max_age = 86_400 , public = True ) @get ( \"/chance_of_rain\" ) def get_chance_of_rain ( self ) -> float : \"\"\"This endpoint uses the cache control value defined in the controller which overrides the app value.\"\"\" return 0.5 @get ( \"/timestamp\" , cache_control = CacheControlHeader ( no_store = True )) def get_server_time ( self ) -> float : \"\"\"This endpoint overrides the cache control value defined in the controller.\"\"\" return time . time () @get ( \"/population\" ) def get_population_count () -> int : \"\"\"This endpoint will use the cache control defined in the app.\"\"\" return 100000 app = Starlite ( route_handlers = [ MyController , get_population_count ], cache_control = CacheControlHeader ( max_age = 2_628_288 , public = True ), ) In this example we have a cache-control with max-age of 1 month for the whole app, a max-age of 1 day for all routes within MyController and no-store for one specific route get_server_time . Here are the cache control values that will be returned from each endpoint: When calling /population the response will have cache-control with max-age=2628288 (1 month). When calling /chance_of_rain the response will have cache-control with max-age=86400 (1 day). When calling /timestamp the response will have cache-control with no-store which means don't store the result in any cache.","title":"Response Headers"},{"location":"usage/5-responses/4-response-headers/#response-headers","text":"Starlite allows you to define response headers by using the response_headers kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Starlite , Router , Controller , MediaType , get from starlite.datastructures import ResponseHeader class MyController ( Controller ): path = \"/controller-path\" response_headers = { \"controller-level-header\" : ResponseHeader ( value = \"controller header\" , description = \"controller level header\" ) } @get ( path = \"/\" , response_headers = { \"my-local-header\" : ResponseHeader ( value = \"local header\" , description = \"local level header\" ) }, media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_headers = { \"router-level-header\" : ResponseHeader ( value = \"router header\" , description = \"router level header\" ) }, ) app = Starlite ( route_handlers = [ router ], response_headers = { \"app-level-header\" : ResponseHeader ( value = \"app header\" , description = \"app level header\" ) }, ) In the above example the response returned from my_route_handler will have headers set from each layer of the application using the given key+value combinations. I.e. it will be a dictionary equal to this: { \"my-local-header\" : \"local header\" , \"controller-level-header\" : \"controller header\" , \"router-level-header\" : \"router header\" , \"app-level-header\" : \"app header\" } The respective descriptions will be used for the OpenAPI documentation.","title":"Response Headers"},{"location":"usage/5-responses/4-response-headers/#dynamic-headers","text":"The above detailed scheme works great for statically configured headers, but how would you go about handling dynamically setting headers? Starlite allows you to set headers dynamically in several ways and below we will detail the two primary patterns.","title":"Dynamic Headers"},{"location":"usage/5-responses/4-response-headers/#setting-response-headers-using-annotated-responses","text":"We can simply return a response instance directly from the route handler and set the headers dictionary manually as you see fit, e.g.: from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , get from starlite.datastructures import ResponseHeader from starlite.enums import MediaType from random import randint class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 1 , 100 ))}, media_type = MediaType . JSON , status_code = HTTP_200_OK , ) In the above we use the response_headers kwarg to pass the name and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True .","title":"Setting Response Headers Using Annotated Responses"},{"location":"usage/5-responses/4-response-headers/#setting-response-headers-using-the-after-request-hook","text":"An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the headers on the corresponding layer: from random import randint from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , Router , get from starlite.datastructures import ResponseHeader from starlite.enums import MediaType class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 100 , 1000 ))}, media_type = MediaType . JSON , status_code = HTTP_200_OK , ) def after_request_handler ( response : Response ) -> Response : response . headers . update ({ \"Random-Header\" : str ( randint ( 1 , 100 ))}) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) In the above we set the response header using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding header specification as required. For example, lets say we have a router level header being set and a local header with the same key but a different value range: from pydantic import BaseModel from starlite import Router , Response , get from starlite.datastructures import ResponseHeader from random import randint class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 100 , 1000 ))}, ) def after_request_handler ( response : Response ) -> Response : response . headers . update ({ \"Random-Header\" : str ( randint ( 1 , 100 ))}) return response router = Router ( route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) # ...","title":"Setting Response Headers Using the After Request Hook"},{"location":"usage/5-responses/4-response-headers/#specific-headers-implementation","text":"Starlite has a dedicated implementation for a few headers that are commonly used. These headers can be set separately from response_headers in dedicated kwargs available on all layers of the app (individual route handlers, controllers, routers and the app itself).","title":"Specific Headers Implementation"},{"location":"usage/5-responses/4-response-headers/#cache-control","text":"Starlite has a dedicated CacheControlHeader class for Cache-Control which allows easy creation and parsing of the header value and provides accessors to its directives. Here is a simple example that shows how to use it: Cache Control Header import time from starlite import Controller , Starlite , get from starlite.datastructures import CacheControlHeader class MyController ( Controller ): cache_control = CacheControlHeader ( max_age = 86_400 , public = True ) @get ( \"/chance_of_rain\" ) def get_chance_of_rain ( self ) -> float : \"\"\"This endpoint uses the cache control value defined in the controller which overrides the app value.\"\"\" return 0.5 @get ( \"/timestamp\" , cache_control = CacheControlHeader ( no_store = True )) def get_server_time ( self ) -> float : \"\"\"This endpoint overrides the cache control value defined in the controller.\"\"\" return time . time () @get ( \"/population\" ) def get_population_count () -> int : \"\"\"This endpoint will use the cache control defined in the app.\"\"\" return 100000 app = Starlite ( route_handlers = [ MyController , get_population_count ], cache_control = CacheControlHeader ( max_age = 2_628_288 , public = True ), ) In this example we have a cache-control with max-age of 1 month for the whole app, a max-age of 1 day for all routes within MyController and no-store for one specific route get_server_time . Here are the cache control values that will be returned from each endpoint: When calling /population the response will have cache-control with max-age=2628288 (1 month). When calling /chance_of_rain the response will have cache-control with max-age=86400 (1 day). When calling /timestamp the response will have cache-control with no-store which means don't store the result in any cache.","title":"Cache Control"},{"location":"usage/5-responses/5-response-cookies/","text":"Response Cookies Starlite allows you to define response cookies by using the response_cookies kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Starlite , Router , Controller , MediaType , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"controller-cookie\" , value = \"controller value\" , description = \"controller level cookie\" , ) ] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"local-cookie\" , value = \"local value\" , description = \"route handler level cookie\" , ) ], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_cookies = [ Cookie ( key = \"router-cookie\" , value = \"router value\" , description = \"router level cookie\" ) ], ) app = Starlite ( route_handlers = [ router ], response_cookies = [ Cookie ( key = \"app-cookie\" , value = \"app value\" , description = \"app level cookie\" ) ], ) In the above example, the response returned by my_route_handler will have cookies set by each layer of the application. Cookies are set using the Set-Cookie header and with above resulting in: Set-Cookie: local-cookie=local value; Path=/; SameSite=lax Set-Cookie: controller-cookie=controller value; Path=/; SameSite=lax Set-Cookie: router-cookie=router value; Path=/; SameSite=lax Set-Cookie: app-cookie=app value; Path=/; SameSite=lax You can easily override cookies declared in higher levels by re-declaring a cookie with the same key in a lower level, e.g.: from starlite import Controller , MediaType , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"123\" )] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"456\" )], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" Of the two declarations of my-cookie only the route handler one will be used, because its lower level: Set-Cookie: my-cookie=456; Path=/; SameSite=lax The Cookie Class Starlite exports the class starlite.datastructures.Cookie . This is a pydantic model that allows you to define a cookie. See the API Reference for full details on the Cookie class and the kwargs it accepts. Dynamic Cookies While the above scheme works great for static cookie values, it doesn't allow for dynamic cookies. Because cookies are fundamentally a type of response header, we can utilize the same patterns we use for setting dynamic headers also here. Setting Response Headers Using Annotated Responses We can simply return a response instance directly from the route handler and set the cookies list manually as you see fit, e.g.: from random import randint from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , get from starlite.datastructures import Cookie from starlite.enums import MediaType class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 )))], media_type = MediaType . JSON , status_code = HTTP_200_OK , ) In the above we use the response_cookies kwarg to pass the key and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True . Setting Response Headers Using the After Request Hook An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the cookies on the corresponding layer: from random import randint from pydantic import BaseModel from starlite import Response , Router , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" , ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( ** Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) . dict ( exclude_none = True , exclude = { \"documentation_only\" , \"description\" } ) ) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) In the above we set the cookie using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding cookie specification as required. For example, lets say we have a router level cookie being set and a local cookie with the same key but a different value range: from random import randint from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , Router , get from starlite.datastructures import Cookie from starlite.enums import MediaType class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 100 , 1000 )))], media_type = MediaType . JSON , status_code = HTTP_200_OK , ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( ** Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) . dict ( exclude_none = True , exclude = { \"documentation_only\" , \"description\" } ) ) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], )","title":"Response Cookies"},{"location":"usage/5-responses/5-response-cookies/#response-cookies","text":"Starlite allows you to define response cookies by using the response_cookies kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Starlite , Router , Controller , MediaType , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"controller-cookie\" , value = \"controller value\" , description = \"controller level cookie\" , ) ] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"local-cookie\" , value = \"local value\" , description = \"route handler level cookie\" , ) ], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_cookies = [ Cookie ( key = \"router-cookie\" , value = \"router value\" , description = \"router level cookie\" ) ], ) app = Starlite ( route_handlers = [ router ], response_cookies = [ Cookie ( key = \"app-cookie\" , value = \"app value\" , description = \"app level cookie\" ) ], ) In the above example, the response returned by my_route_handler will have cookies set by each layer of the application. Cookies are set using the Set-Cookie header and with above resulting in: Set-Cookie: local-cookie=local value; Path=/; SameSite=lax Set-Cookie: controller-cookie=controller value; Path=/; SameSite=lax Set-Cookie: router-cookie=router value; Path=/; SameSite=lax Set-Cookie: app-cookie=app value; Path=/; SameSite=lax You can easily override cookies declared in higher levels by re-declaring a cookie with the same key in a lower level, e.g.: from starlite import Controller , MediaType , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"123\" )] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"456\" )], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" Of the two declarations of my-cookie only the route handler one will be used, because its lower level: Set-Cookie: my-cookie=456; Path=/; SameSite=lax","title":"Response Cookies"},{"location":"usage/5-responses/5-response-cookies/#the-cookie-class","text":"Starlite exports the class starlite.datastructures.Cookie . This is a pydantic model that allows you to define a cookie. See the API Reference for full details on the Cookie class and the kwargs it accepts.","title":"The Cookie Class"},{"location":"usage/5-responses/5-response-cookies/#dynamic-cookies","text":"While the above scheme works great for static cookie values, it doesn't allow for dynamic cookies. Because cookies are fundamentally a type of response header, we can utilize the same patterns we use for setting dynamic headers also here.","title":"Dynamic Cookies"},{"location":"usage/5-responses/5-response-cookies/#setting-response-headers-using-annotated-responses","text":"We can simply return a response instance directly from the route handler and set the cookies list manually as you see fit, e.g.: from random import randint from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , get from starlite.datastructures import Cookie from starlite.enums import MediaType class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 )))], media_type = MediaType . JSON , status_code = HTTP_200_OK , ) In the above we use the response_cookies kwarg to pass the key and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True .","title":"Setting Response Headers Using Annotated Responses"},{"location":"usage/5-responses/5-response-cookies/#setting-response-headers-using-the-after-request-hook","text":"An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the cookies on the corresponding layer: from random import randint from pydantic import BaseModel from starlite import Response , Router , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" , ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( ** Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) . dict ( exclude_none = True , exclude = { \"documentation_only\" , \"description\" } ) ) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) In the above we set the cookie using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding cookie specification as required. For example, lets say we have a router level cookie being set and a local cookie with the same key but a different value range: from random import randint from pydantic import BaseModel from starlette.status import HTTP_200_OK from starlite import Response , Router , get from starlite.datastructures import Cookie from starlite.enums import MediaType class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 100 , 1000 )))], media_type = MediaType . JSON , status_code = HTTP_200_OK , ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( ** Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) . dict ( exclude_none = True , exclude = { \"documentation_only\" , \"description\" } ) ) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], )","title":"Setting Response Headers Using the After Request Hook"},{"location":"usage/5-responses/6-redirect-responses/","text":"Redirect Responses Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import get from starlite.datastructures import Redirect @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path The Redirect Class Redirect is a container class used to generate redirect responses and their respective OpenAPI documentation. See the API Reference for full details on the Redirect class and the kwargs it accepts.","title":"Redirect Responses"},{"location":"usage/5-responses/6-redirect-responses/#redirect-responses","text":"Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import get from starlite.datastructures import Redirect @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path","title":"Redirect Responses"},{"location":"usage/5-responses/6-redirect-responses/#the-redirect-class","text":"Redirect is a container class used to generate redirect responses and their respective OpenAPI documentation. See the API Reference for full details on the Redirect class and the kwargs it accepts.","title":"The Redirect Class"},{"location":"usage/5-responses/7-file-responses/","text":"File Responses File responses send a file: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File Class File is a container class used to generate file responses and their respective OpenAPI documentation. See the API Reference for full details on the File class and the kwargs it accepts.","title":"File Responses"},{"location":"usage/5-responses/7-file-responses/#file-responses","text":"File responses send a file: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , )","title":"File Responses"},{"location":"usage/5-responses/7-file-responses/#the-file-class","text":"File is a container class used to generate file responses and their respective OpenAPI documentation. See the API Reference for full details on the File class and the kwargs it accepts.","title":"The File Class"},{"location":"usage/5-responses/8-streaming-responses/","text":"Streaming Responses To return a streaming response use the Stream class. The Stream class receives a single required kwarg - iterator : from typing import AsyncGenerator from asyncio import sleep from starlite import get from starlite.datastructures import Stream from datetime import datetime from orjson import dumps async def my_generator () -> AsyncGenerator [ bytes , None ]: while True : await sleep ( 0.01 ) yield dumps ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_generator ()) Note You can use different kinds of values of the iterator keyword - it can be a callable returning a sync or async generator. The generator itself. A sync or async iterator class, or and instance of this class. The Stream Class Stream is a container class used to generate streaming responses and their respective OpenAPI documentation. See the API Reference for full details on the Stream class and the kwargs it accepts.","title":"Streaming Responses"},{"location":"usage/5-responses/8-streaming-responses/#streaming-responses","text":"To return a streaming response use the Stream class. The Stream class receives a single required kwarg - iterator : from typing import AsyncGenerator from asyncio import sleep from starlite import get from starlite.datastructures import Stream from datetime import datetime from orjson import dumps async def my_generator () -> AsyncGenerator [ bytes , None ]: while True : await sleep ( 0.01 ) yield dumps ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_generator ()) Note You can use different kinds of values of the iterator keyword - it can be a callable returning a sync or async generator. The generator itself. A sync or async iterator class, or and instance of this class.","title":"Streaming Responses"},{"location":"usage/5-responses/8-streaming-responses/#the-stream-class","text":"Stream is a container class used to generate streaming responses and their respective OpenAPI documentation. See the API Reference for full details on the Stream class and the kwargs it accepts.","title":"The Stream Class"},{"location":"usage/5-responses/9-template-responses/","text":"Template Responses Template responses are used to render templates into HTML. To use a template response you must first register a template engine on the application level. Once an engine is in place, you can use a template response like so: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) In the above Template is passed the template name, which is a path like value, and a context dictionary that maps string keys into values that will be rendered in the template. The Template Class Template is a container class used to generate template responses and their respective OpenAPI documentation. See the API Reference for full details on the Template class and the kwargs it accepts.","title":"Template Responses"},{"location":"usage/5-responses/9-template-responses/#template-responses","text":"Template responses are used to render templates into HTML. To use a template response you must first register a template engine on the application level. Once an engine is in place, you can use a template response like so: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) In the above Template is passed the template name, which is a path like value, and a context dictionary that maps string keys into values that will be rendered in the template.","title":"Template Responses"},{"location":"usage/5-responses/9-template-responses/#the-template-class","text":"Template is a container class used to generate template responses and their respective OpenAPI documentation. See the API Reference for full details on the Template class and the kwargs it accepts.","title":"The Template Class"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/","text":"Dependency Injection Starlite has a simple but powerful dependency injection system that allows for declaring dependencies on all layers of the application: from starlite import Controller , Router , Starlite , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) The above example illustrates how dependencies are declared on the different layers of the application. Dependencies are callables - sync or async functions, methods or class instances that implement the __call__ method - that are wrapped inside an instance of the starlite.datastructures.Provide class. Pre-requisites and Scope The pre-requisites for dependency injection are these: dependencies must be callables. dependencies can receive kwargs and a self arg but not positional args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers.","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#dependency-injection","text":"Starlite has a simple but powerful dependency injection system that allows for declaring dependencies on all layers of the application: from starlite import Controller , Router , Starlite , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) The above example illustrates how dependencies are declared on the different layers of the application. Dependencies are callables - sync or async functions, methods or class instances that implement the __call__ method - that are wrapped inside an instance of the starlite.datastructures.Provide class.","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#pre-requisites-and-scope","text":"The pre-requisites for dependency injection are these: dependencies must be callables. dependencies can receive kwargs and a self arg but not positional args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers.","title":"Pre-requisites and Scope"},{"location":"usage/6-dependency-injection/1-dependency-kwargs/","text":"Dependency Kwargs As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers . from starlite import Controller , Provide , patch from starlite.types.partial import Partial from pydantic import BaseModel , UUID4 class User ( BaseModel ): id : UUID4 name : str async def retrieve_db_user ( user_id : UUID4 ) -> User : ... class UserController ( Controller ): path = \"/user\" dependencies = { \"user\" : Provide ( retrieve_db_user )} @patch ( path = \"/{user_id:uuid}\" ) async def update_user ( self , data : Partial [ User ], user : User ) -> User : ... In the above example we have a User model that we are persisting into a db. The model is fetched using the helper method retrieve_db_user which receives a user_id kwarg and retrieves the corresponding User instance. The UserController class maps the retrieve_db_user provider to the key user in its dependencies dictionary. This in turn makes it available as a kwarg in the update_user method.","title":"Dependency Kwargs"},{"location":"usage/6-dependency-injection/1-dependency-kwargs/#dependency-kwargs","text":"As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers . from starlite import Controller , Provide , patch from starlite.types.partial import Partial from pydantic import BaseModel , UUID4 class User ( BaseModel ): id : UUID4 name : str async def retrieve_db_user ( user_id : UUID4 ) -> User : ... class UserController ( Controller ): path = \"/user\" dependencies = { \"user\" : Provide ( retrieve_db_user )} @patch ( path = \"/{user_id:uuid}\" ) async def update_user ( self , data : Partial [ User ], user : User ) -> User : ... In the above example we have a User model that we are persisting into a db. The model is fetched using the helper method retrieve_db_user which receives a user_id kwarg and retrieves the corresponding User instance. The UserController class maps the retrieve_db_user provider to the key user in its dependencies dictionary. This in turn makes it available as a kwarg in the update_user method.","title":"Dependency Kwargs"},{"location":"usage/6-dependency-injection/2-overriding-dependencies/","text":"Overriding Dependencies Because dependencies are declared at each level of the app using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... The lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one.","title":"Overriding Dependencies"},{"location":"usage/6-dependency-injection/2-overriding-dependencies/#overriding-dependencies","text":"Because dependencies are declared at each level of the app using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... The lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one.","title":"Overriding Dependencies"},{"location":"usage/6-dependency-injection/3-the-provide-class/","text":"The Provide Class The class starlite.datastructures.Provide is a wrapper used for dependency injection. To inject a callable you must wrap it in Provide : from starlite import Provide , get from random import randint def my_dependency () -> int : return randint ( 1 , 10 ) @get ( \"/some-path\" , dependencies = { \"my_dep\" : Provide ( my_dependency , ) }, ) def my_handler ( my_dep : int ) -> None : ... See the API Reference for full details on the Provide class and the kwargs it accepts. Important If Provide.use_cache is true, the return value of the function will be memoized the first time it is called and then will be used. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option.","title":"The Provide Class"},{"location":"usage/6-dependency-injection/3-the-provide-class/#the-provide-class","text":"The class starlite.datastructures.Provide is a wrapper used for dependency injection. To inject a callable you must wrap it in Provide : from starlite import Provide , get from random import randint def my_dependency () -> int : return randint ( 1 , 10 ) @get ( \"/some-path\" , dependencies = { \"my_dep\" : Provide ( my_dependency , ) }, ) def my_handler ( my_dep : int ) -> None : ... See the API Reference for full details on the Provide class and the kwargs it accepts. Important If Provide.use_cache is true, the return value of the function will be memoized the first time it is called and then will be used. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option.","title":"The Provide Class"},{"location":"usage/6-dependency-injection/4-dependencies-in-dependencies/","text":"Using Dependencies in Dependencies You can inject dependencies into other dependencies - exactly like you would into regular functions. from starlite import Starlite , Provide , get from random import randint def first_dependency () -> int : return randint ( 1 , 10 ) def second_dependency ( injected_integer : int ) -> bool : return injected_integer % 2 == 0 @get ( \"/true-or-false\" ) def true_or_false_handler ( injected_bool : bool ) -> str : return \"its true!\" if injected_bool else \"nope, its false...\" app = Starlite ( route_handlers = [ true_or_false_handler ], dependencies = { \"injected_integer\" : Provide ( first_dependency ), \"injected_bool\" : Provide ( second_dependency ), }, ) Note The same rules for overriding dependencies apply here as well.","title":"Using Dependencies in Dependencies"},{"location":"usage/6-dependency-injection/4-dependencies-in-dependencies/#using-dependencies-in-dependencies","text":"You can inject dependencies into other dependencies - exactly like you would into regular functions. from starlite import Starlite , Provide , get from random import randint def first_dependency () -> int : return randint ( 1 , 10 ) def second_dependency ( injected_integer : int ) -> bool : return injected_integer % 2 == 0 @get ( \"/true-or-false\" ) def true_or_false_handler ( injected_bool : bool ) -> str : return \"its true!\" if injected_bool else \"nope, its false...\" app = Starlite ( route_handlers = [ true_or_false_handler ], dependencies = { \"injected_integer\" : Provide ( first_dependency ), \"injected_bool\" : Provide ( second_dependency ), }, ) Note The same rules for overriding dependencies apply here as well.","title":"Using Dependencies in Dependencies"},{"location":"usage/6-dependency-injection/5-the-dependency-function/","text":"The Dependency Function Dependency validation By default, injected dependency values are validated by Starlite, for example, this application will raise an internal server error: Dependency validation error from typing import Any from starlite import Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int ) -> dict [ str , Any ]: \"\"\"Handler expects and `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) Dependency validation can be toggled using the Dependency function. Dependency validation error from typing import Any from starlite import Dependency , Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int = Dependency ( skip_validation = True )) -> dict [ str , Any ]: \"\"\"Handler expects an `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) This may be useful for reasons of efficiency, or if pydantic cannot validate a certain type, but use with caution! Dependency function as a marker The Dependency function can also be used as a marker that gives us a bit more detail about your application. Exclude dependencies with default values from OpenAPI docs Depending on your application design, it is possible to have a dependency declared in a handler or Provide function that has a default value. If the dependency isn't provided for the route, the default should be used by the function. Dependency with default value from typing import Any from starlite import Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = 3 ) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, but the parameter shows in the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ]) This doesn't fail, but due to the way the application determines parameter types, this is inferred to be a query parameter: By declaring the parameter to be a dependency, Starlite knows to exclude it from the docs: Dependency with default value from typing import Any from starlite import Dependency , Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = Dependency ( default = 3 )) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, and now the parameter is excluded from the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ]) Early detection if a dependency isn't provided The other side of the same coin is when a dependency isn't provided, and no default is specified. Without the dependency marker, the parameter is assumed to be a query parameter and the route will most likely fail when accessed. If the parameter is marked as a dependency, this allows us to fail early instead: Dependency not provided error from typing import Any from starlite import Dependency , get @get ( \"/\" ) def hello_world ( non_optional_dependency : int = Dependency ()) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is not great, however by explicitly marking dependencies, Starlite won't let the app start. \"\"\" return { \"hello\" : non_optional_dependency } # app = Starlite(route_handlers=[hello_world]) # ImproperlyConfiguredException: 500: Explicit dependency 'non_optional_dependency' for 'hello_world' has no default # value, or provided dependency.","title":"The Dependency Function"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#the-dependency-function","text":"","title":"The Dependency Function"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#dependency-validation","text":"By default, injected dependency values are validated by Starlite, for example, this application will raise an internal server error: Dependency validation error from typing import Any from starlite import Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int ) -> dict [ str , Any ]: \"\"\"Handler expects and `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) Dependency validation can be toggled using the Dependency function. Dependency validation error from typing import Any from starlite import Dependency , Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int = Dependency ( skip_validation = True )) -> dict [ str , Any ]: \"\"\"Handler expects an `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) This may be useful for reasons of efficiency, or if pydantic cannot validate a certain type, but use with caution!","title":"Dependency validation"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#dependency-function-as-a-marker","text":"The Dependency function can also be used as a marker that gives us a bit more detail about your application.","title":"Dependency function as a marker"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#exclude-dependencies-with-default-values-from-openapi-docs","text":"Depending on your application design, it is possible to have a dependency declared in a handler or Provide function that has a default value. If the dependency isn't provided for the route, the default should be used by the function. Dependency with default value from typing import Any from starlite import Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = 3 ) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, but the parameter shows in the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ]) This doesn't fail, but due to the way the application determines parameter types, this is inferred to be a query parameter: By declaring the parameter to be a dependency, Starlite knows to exclude it from the docs: Dependency with default value from typing import Any from starlite import Dependency , Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = Dependency ( default = 3 )) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, and now the parameter is excluded from the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ])","title":"Exclude dependencies with default values from OpenAPI docs"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#early-detection-if-a-dependency-isnt-provided","text":"The other side of the same coin is when a dependency isn't provided, and no default is specified. Without the dependency marker, the parameter is assumed to be a query parameter and the route will most likely fail when accessed. If the parameter is marked as a dependency, this allows us to fail early instead: Dependency not provided error from typing import Any from starlite import Dependency , get @get ( \"/\" ) def hello_world ( non_optional_dependency : int = Dependency ()) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is not great, however by explicitly marking dependencies, Starlite won't let the app start. \"\"\" return { \"hello\" : non_optional_dependency } # app = Starlite(route_handlers=[hello_world]) # ImproperlyConfiguredException: 500: Explicit dependency 'non_optional_dependency' for 'hello_world' has no default # value, or provided dependency.","title":"Early detection if a dependency isn't provided"},{"location":"usage/7-middleware/0-middleware-intro/","text":"Introduction Middlewares in Starlite are ASGI apps that are called \"in the middle\" between the application entrypoint and the route handler function. Starlite ships with several builtin middlewares (some coming from Starlette) that are easy to configure and use. See the documentation regarding these for more details. You can also use the builtin Starlette Middlewares and most 3rd party middlewares created for Starlette or FastAPI. Note 3rd party middlewares for Starlette that rely on the Starlette routing system are incompatible with Starlite. To understand why, read about the Starlite routing system .","title":"Introduction"},{"location":"usage/7-middleware/0-middleware-intro/#introduction","text":"Middlewares in Starlite are ASGI apps that are called \"in the middle\" between the application entrypoint and the route handler function. Starlite ships with several builtin middlewares (some coming from Starlette) that are easy to configure and use. See the documentation regarding these for more details. You can also use the builtin Starlette Middlewares and most 3rd party middlewares created for Starlette or FastAPI. Note 3rd party middlewares for Starlette that rely on the Starlette routing system are incompatible with Starlite. To understand why, read about the Starlite routing system .","title":"Introduction"},{"location":"usage/7-middleware/1-using-middleware/0-using-middleware-intro/","text":"Using Middleware A middleware in Starlite is any callable that receives at least one kwarg called app and returns an ASGIApp . Since these terms are somewhat daunting, lets parse what this means: an ASGIApp is nothing but an async function that receives the ASGI primitives - scope , receive and send - and either calls the next ASGIApp or returns a response / handles the websocket connection. For example, the following function can be used as a middleware because it receives the app kwarg and returns an ASGIApp : from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware We could then use it by passing it to one of the layers of the application. What does this mean? Unlike other frameworks that allow users to define middleware only on the application level, Starlite allows users to user middleware on the different layers of the application. Thus, we could use our middleware on the application layer - like so: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ middleware_factory ]) In the above example, Starlite will call the middleware_factory function and pass to it app . It's important to understand that this kwarg does not designate the Starlite application but rather the next ASGIApp in the stack. It will then insert the returned my_middleware function into the stack of every route in the application - because we declared it on the application level.","title":"Using Middleware"},{"location":"usage/7-middleware/1-using-middleware/0-using-middleware-intro/#using-middleware","text":"A middleware in Starlite is any callable that receives at least one kwarg called app and returns an ASGIApp . Since these terms are somewhat daunting, lets parse what this means: an ASGIApp is nothing but an async function that receives the ASGI primitives - scope , receive and send - and either calls the next ASGIApp or returns a response / handles the websocket connection. For example, the following function can be used as a middleware because it receives the app kwarg and returns an ASGIApp : from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware We could then use it by passing it to one of the layers of the application. What does this mean? Unlike other frameworks that allow users to define middleware only on the application level, Starlite allows users to user middleware on the different layers of the application. Thus, we could use our middleware on the application layer - like so: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ middleware_factory ]) In the above example, Starlite will call the middleware_factory function and pass to it app . It's important to understand that this kwarg does not designate the Starlite application but rather the next ASGIApp in the stack. It will then insert the returned my_middleware function into the stack of every route in the application - because we declared it on the application level.","title":"Using Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/","text":"Layering Middleware While running middleware on the application level is the most common use-case, sometimes middleware needs to run on only a specific subset of routes. Starlite allows doing this by supporting middleware declaration on all layers of the application - the Starlite instance, routers, controllers and individual route handlers. That is, all of these patterns are supported as well: Router Level Middleware By passing middleware on the router, this middleware will be used for all routes on the router: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Router , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... router = Router ( path = \"/router\" , route_handlers = [ handler1 , handler2 ], middleware = [ middleware_factory ] ) app = Starlite ( route_handlers = [ router ]) Controller Level Middleware By passing middleware on the controller, this middleware will be used for all routes on the controller: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Controller , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware class MyController ( Controller ): path = \"/controller\" middleware = [ middleware_factory ] @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ MyController ], middleware = [ middleware_factory ]) Route Handler Level Middleware By passing middleware on the route handler, this middleware will be used only for those route handlers that specify it: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" , middleware = [ middleware_factory ]) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ handler1 , handler2 ])","title":"Layering Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#layering-middleware","text":"While running middleware on the application level is the most common use-case, sometimes middleware needs to run on only a specific subset of routes. Starlite allows doing this by supporting middleware declaration on all layers of the application - the Starlite instance, routers, controllers and individual route handlers. That is, all of these patterns are supported as well:","title":"Layering Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#router-level-middleware","text":"By passing middleware on the router, this middleware will be used for all routes on the router: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Router , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... router = Router ( path = \"/router\" , route_handlers = [ handler1 , handler2 ], middleware = [ middleware_factory ] ) app = Starlite ( route_handlers = [ router ])","title":"Router Level Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#controller-level-middleware","text":"By passing middleware on the controller, this middleware will be used for all routes on the controller: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Controller , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware class MyController ( Controller ): path = \"/controller\" middleware = [ middleware_factory ] @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ MyController ], middleware = [ middleware_factory ])","title":"Controller Level Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#route-handler-level-middleware","text":"By passing middleware on the route handler, this middleware will be used only for those route handlers that specify it: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" , middleware = [ middleware_factory ]) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ handler1 , handler2 ])","title":"Route Handler Level Middleware"},{"location":"usage/7-middleware/1-using-middleware/2-middleware-call-order/","text":"Middleware Call Order The call order of middleware follows a simple rule: middleware is called top to bottom, left to right . That is to say- application level middleware will be called before router level middleware, which will be called before controller level middleware, which will be called before route handler middleware. And also, that middleware defined first the in the middleware list, will be called first. To illustrate this, consider the following test case: from starlite.types import ASGIApp , Receive , Scope , Send from starlite import ( Controller , MiddlewareProtocol , Router , get , ) from starlite.testing import create_test_client def test_middleware_call_order () -> None : \"\"\"Test that middlewares are called in the order they have been passed.\"\"\" results : list [ int ] = [] def create_test_middleware ( middleware_id : int ) -> type [ MiddlewareProtocol ]: class TestMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : results . append ( middleware_id ) await self . app ( scope , receive , send ) return TestMiddleware class MyController ( Controller ): path = \"/controller\" middleware = [ create_test_middleware ( 4 ), create_test_middleware ( 5 )] @get ( \"/handler\" , middleware = [ create_test_middleware ( 6 ), create_test_middleware ( 7 )], ) def my_handler ( self ) -> None : return None router = Router ( path = \"/router\" , route_handlers = [ MyController ], middleware = [ create_test_middleware ( 2 ), create_test_middleware ( 3 )], ) with create_test_client ( route_handlers = [ router ], middleware = [ create_test_middleware ( 0 ), create_test_middleware ( 1 )], ) as client : client . get ( \"/router/controller/handler\" ) assert results == [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]","title":"Middleware Call Order"},{"location":"usage/7-middleware/1-using-middleware/2-middleware-call-order/#middleware-call-order","text":"The call order of middleware follows a simple rule: middleware is called top to bottom, left to right . That is to say- application level middleware will be called before router level middleware, which will be called before controller level middleware, which will be called before route handler middleware. And also, that middleware defined first the in the middleware list, will be called first. To illustrate this, consider the following test case: from starlite.types import ASGIApp , Receive , Scope , Send from starlite import ( Controller , MiddlewareProtocol , Router , get , ) from starlite.testing import create_test_client def test_middleware_call_order () -> None : \"\"\"Test that middlewares are called in the order they have been passed.\"\"\" results : list [ int ] = [] def create_test_middleware ( middleware_id : int ) -> type [ MiddlewareProtocol ]: class TestMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : results . append ( middleware_id ) await self . app ( scope , receive , send ) return TestMiddleware class MyController ( Controller ): path = \"/controller\" middleware = [ create_test_middleware ( 4 ), create_test_middleware ( 5 )] @get ( \"/handler\" , middleware = [ create_test_middleware ( 6 ), create_test_middleware ( 7 )], ) def my_handler ( self ) -> None : return None router = Router ( path = \"/router\" , route_handlers = [ MyController ], middleware = [ create_test_middleware ( 2 ), create_test_middleware ( 3 )], ) with create_test_client ( route_handlers = [ router ], middleware = [ create_test_middleware ( 0 ), create_test_middleware ( 1 )], ) as client : client . get ( \"/router/controller/handler\" ) assert results == [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]","title":"Middleware Call Order"},{"location":"usage/7-middleware/1-using-middleware/3-define-middleware/","text":"Passing Args and Kwargs to Middleware Starlite offers a simple way to pass positional arguments ( *args ) and key-word arguments ( **kwargs ) to middleware using the starlite.middleware.base.DefineMiddleware class. Let's extend the factory function used in the examples above to take some args and kwargs and then use DefineMiddleware to pass these values to our middleware: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , DefineMiddleware def middleware_factory ( my_arg : int , * , app : ASGIApp , my_kwarg : str ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # here we can use my_arg and my_kwarg for some purpose ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ DefineMiddleware ( middleware_factory , 1 , my_kwarg = \"abc\" )], ) The DefineMiddleware is a simple container - it takes a middleware callable as a first parameter, and then any positional arguments, followed by key word arguments. The middleware callable will be called with these values as well as the kwarg app as mentioned above. Note Starlette also includes a middleware container - starlette.middleware.Middleware , and this class is also supported by Starlite - so feel free to use it. You should note though that the Starlette class though does not support positional arguments.","title":"Passing Args and Kwargs to Middleware"},{"location":"usage/7-middleware/1-using-middleware/3-define-middleware/#passing-args-and-kwargs-to-middleware","text":"Starlite offers a simple way to pass positional arguments ( *args ) and key-word arguments ( **kwargs ) to middleware using the starlite.middleware.base.DefineMiddleware class. Let's extend the factory function used in the examples above to take some args and kwargs and then use DefineMiddleware to pass these values to our middleware: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , DefineMiddleware def middleware_factory ( my_arg : int , * , app : ASGIApp , my_kwarg : str ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # here we can use my_arg and my_kwarg for some purpose ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ DefineMiddleware ( middleware_factory , 1 , my_kwarg = \"abc\" )], ) The DefineMiddleware is a simple container - it takes a middleware callable as a first parameter, and then any positional arguments, followed by key word arguments. The middleware callable will be called with these values as well as the kwarg app as mentioned above. Note Starlette also includes a middleware container - starlette.middleware.Middleware , and this class is also supported by Starlite - so feel free to use it. You should note though that the Starlette class though does not support positional arguments.","title":"Passing Args and Kwargs to Middleware"},{"location":"usage/7-middleware/1-using-middleware/4-middleware-and-exceptions/","text":"Middlewares and Exceptions When an exception is raised by a route handler or dependency and is then transformed into a response by an exception handler , middlewares are still applied to it. The one limitation on this though are the two exceptions that can be raised by the ASGI router - 404 Not Found and 405 Method Not Allowed . These exceptions are raised before the middleware stack is called, and are only handled by exceptions handlers defined on the Starlite app instance itself. Thus, if you need to modify the responses generated for these exceptions, you will need to define a custom exception handler on the app instance level.","title":"Middlewares and Exceptions"},{"location":"usage/7-middleware/1-using-middleware/4-middleware-and-exceptions/#middlewares-and-exceptions","text":"When an exception is raised by a route handler or dependency and is then transformed into a response by an exception handler , middlewares are still applied to it. The one limitation on this though are the two exceptions that can be raised by the ASGI router - 404 Not Found and 405 Method Not Allowed . These exceptions are raised before the middleware stack is called, and are only handled by exceptions handlers defined on the Starlite app instance itself. Thus, if you need to modify the responses generated for these exceptions, you will need to define a custom exception handler on the app instance level.","title":"Middlewares and Exceptions"},{"location":"usage/7-middleware/2-creating-middleware/0-creating-middleware-intro/","text":"Creating Middleware As mentioned in the using middleware section, a middleware in Starlite is any callable that takes a kwarg called app , which is the next ASGI handler, i.e. an ASGIApp , and returns an ASGIApp . The example previously given was using a factory function, i.e.: from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware While using functions is a perfectly viable approach, you can also use classes to do the same. See the next sections on two base classes you can use for this purpose - the Starlette BaseHTTPMiddleware or the Starlite MiddlewareProtocol .","title":"Creating Middleware"},{"location":"usage/7-middleware/2-creating-middleware/0-creating-middleware-intro/#creating-middleware","text":"As mentioned in the using middleware section, a middleware in Starlite is any callable that takes a kwarg called app , which is the next ASGI handler, i.e. an ASGIApp , and returns an ASGIApp . The example previously given was using a factory function, i.e.: from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware While using functions is a perfectly viable approach, you can also use classes to do the same. See the next sections on two base classes you can use for this purpose - the Starlette BaseHTTPMiddleware or the Starlite MiddlewareProtocol .","title":"Creating Middleware"},{"location":"usage/7-middleware/2-creating-middleware/1-using-basehttp-middleware/","text":"Using BaseHTTPMiddleware You can create middleware by subclassing the starlette.middleware.base.BaseHTTPMiddleware abstract class: import logging from starlette.middleware.base import BaseHTTPMiddleware , RequestResponseEndpoint from starlette.requests import Request from starlette.responses import Response logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request : Request , call_next : RequestResponseEndpoint ) -> Response : logger . info ( \" %s - %s \" % request . method , request . url ) response = await call_next ( request ) return response This class offers an abstraction on top of ASGI - instead of working directly with the ASGI primitives, it offers a convenient dispatch function that offers access to the Request object and a call_next callback, which is similar to the interface used by other frameworks (most famously expressJS). If you want to add kwargs to your middleware, you can of course customize the __init__ function as well: import logging from starlette.middleware.base import BaseHTTPMiddleware , RequestResponseEndpoint from starlette.requests import Request from starlette.responses import Response from starlite.types import ASGIApp logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app : ASGIApp , my_kwarg : str ) -> None : super () . __init__ ( app = app ) self . my_kwarg = my_kwarg async def dispatch ( self , request : Request , call_next : RequestResponseEndpoint ) -> Response : logger . info ( \" %s - %s - %s \" % self . my_kwarg , request . method , request . url ) response = await call_next ( request ) return response While using BaseHTTPMiddleware as a base is very convenient, it doesn't offer direct access to the ASGI primitives. Furthermore, Middlewares based on this class do not work websockets . Thus, if you want more flexibility and control you should use the Starlite MiddlewareProtocol .","title":"Using BaseHTTPMiddleware"},{"location":"usage/7-middleware/2-creating-middleware/1-using-basehttp-middleware/#using-basehttpmiddleware","text":"You can create middleware by subclassing the starlette.middleware.base.BaseHTTPMiddleware abstract class: import logging from starlette.middleware.base import BaseHTTPMiddleware , RequestResponseEndpoint from starlette.requests import Request from starlette.responses import Response logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request : Request , call_next : RequestResponseEndpoint ) -> Response : logger . info ( \" %s - %s \" % request . method , request . url ) response = await call_next ( request ) return response This class offers an abstraction on top of ASGI - instead of working directly with the ASGI primitives, it offers a convenient dispatch function that offers access to the Request object and a call_next callback, which is similar to the interface used by other frameworks (most famously expressJS). If you want to add kwargs to your middleware, you can of course customize the __init__ function as well: import logging from starlette.middleware.base import BaseHTTPMiddleware , RequestResponseEndpoint from starlette.requests import Request from starlette.responses import Response from starlite.types import ASGIApp logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app : ASGIApp , my_kwarg : str ) -> None : super () . __init__ ( app = app ) self . my_kwarg = my_kwarg async def dispatch ( self , request : Request , call_next : RequestResponseEndpoint ) -> Response : logger . info ( \" %s - %s - %s \" % self . my_kwarg , request . method , request . url ) response = await call_next ( request ) return response While using BaseHTTPMiddleware as a base is very convenient, it doesn't offer direct access to the ASGI primitives. Furthermore, Middlewares based on this class do not work websockets . Thus, if you want more flexibility and control you should use the Starlite MiddlewareProtocol .","title":"Using BaseHTTPMiddleware"},{"location":"usage/7-middleware/2-creating-middleware/2-using-middleware-protocol/","text":"Using MiddlewareProtocol The starlite.middleware.base.MiddlewareProtocol class is a PEP 544 Protocol that specifies the minimal implementation of a middleware as follows: from typing import Protocol , Any from starlite.types import ASGIApp , Scope , Receive , Send class MiddlewareProtocol ( Protocol ): def __init__ ( self , app : ASGIApp , ** kwargs : Any ) -> None : ... async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... The __init__ method receives and sets \"app\". It's important to understand that app is not an instance of Starlite in this case, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. To use this protocol as a basis, simply subclass it - as you would any other class, and implement the two methods it specifies: import logging from starlite.types import ASGIApp , Receive , Scope , Send from starlite import Request from starlite.middleware.base import MiddlewareProtocol logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) Important Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope object, not any ephemeral request objects created as in the above. Responding using the MiddlewareProtocol Once a middleware finishes doing whatever its doing, it should pass scope , receive and send to an ASGI app and await it. This is what's happening in the above example with : await self.app(scope, receive, send) . Let's explore another example - redirecting the request to a different url from a middleware: from starlite.types import ASGIApp , Receive , Scope , Send from starlette.responses import RedirectResponse from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import Request from starlite.middleware.base import MiddlewareProtocol class RedirectMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if Request ( scope ) . session is None : response = RedirectResponse ( url = \"/login\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) await response ( scope , receive , send ) else : await self . app ( scope , receive , send ) As you can see in the above, given some condition (request.session being None) we create a RedirectResponse and then await it. Otherwise, we await self.app Modifying ASGI Requests and Responses using the MiddlewareProtocol Important If you'd like to modify a Response object after it was created for a route handler function but before the actual response message is transmitted, the correct place to do this is using the special life-cycle hook called After Request . The instructions in this section are for how to modify the ASGI response message itself, which is a step further in the response process. Using the MiddlewareProtocol you can intercept and modifying both the incoming and outgoing data in a request / response cycle by \"wrapping\" that respective receive and send ASGI functions. To demonstrate this, lets say we want to append a header with a timestamp to all outgoing responses. We could achieve this by doing the following: import time from starlette.datastructures import MutableHeaders from starlite.types import Message , Receive , Scope , Send from starlite.middleware.base import MiddlewareProtocol from starlite.types import ASGIApp class ProcessTimeHeader ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : start_time = time . time () async def send_wrapper ( message : Message ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time . time () - start_time headers = MutableHeaders ( scope = message ) headers . append ( \"X-Process-Time\" , str ( process_time )) await send ( message ) await self . app ( scope , receive , send_wrapper ) else : await self . app ( scope , receive , send )","title":"Using MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/2-using-middleware-protocol/#using-middlewareprotocol","text":"The starlite.middleware.base.MiddlewareProtocol class is a PEP 544 Protocol that specifies the minimal implementation of a middleware as follows: from typing import Protocol , Any from starlite.types import ASGIApp , Scope , Receive , Send class MiddlewareProtocol ( Protocol ): def __init__ ( self , app : ASGIApp , ** kwargs : Any ) -> None : ... async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... The __init__ method receives and sets \"app\". It's important to understand that app is not an instance of Starlite in this case, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. To use this protocol as a basis, simply subclass it - as you would any other class, and implement the two methods it specifies: import logging from starlite.types import ASGIApp , Receive , Scope , Send from starlite import Request from starlite.middleware.base import MiddlewareProtocol logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) Important Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope object, not any ephemeral request objects created as in the above.","title":"Using MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/2-using-middleware-protocol/#responding-using-the-middlewareprotocol","text":"Once a middleware finishes doing whatever its doing, it should pass scope , receive and send to an ASGI app and await it. This is what's happening in the above example with : await self.app(scope, receive, send) . Let's explore another example - redirecting the request to a different url from a middleware: from starlite.types import ASGIApp , Receive , Scope , Send from starlette.responses import RedirectResponse from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import Request from starlite.middleware.base import MiddlewareProtocol class RedirectMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if Request ( scope ) . session is None : response = RedirectResponse ( url = \"/login\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) await response ( scope , receive , send ) else : await self . app ( scope , receive , send ) As you can see in the above, given some condition (request.session being None) we create a RedirectResponse and then await it. Otherwise, we await self.app","title":"Responding using the MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/2-using-middleware-protocol/#modifying-asgi-requests-and-responses-using-the-middlewareprotocol","text":"Important If you'd like to modify a Response object after it was created for a route handler function but before the actual response message is transmitted, the correct place to do this is using the special life-cycle hook called After Request . The instructions in this section are for how to modify the ASGI response message itself, which is a step further in the response process. Using the MiddlewareProtocol you can intercept and modifying both the incoming and outgoing data in a request / response cycle by \"wrapping\" that respective receive and send ASGI functions. To demonstrate this, lets say we want to append a header with a timestamp to all outgoing responses. We could achieve this by doing the following: import time from starlette.datastructures import MutableHeaders from starlite.types import Message , Receive , Scope , Send from starlite.middleware.base import MiddlewareProtocol from starlite.types import ASGIApp class ProcessTimeHeader ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : start_time = time . time () async def send_wrapper ( message : Message ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time . time () - start_time headers = MutableHeaders ( scope = message ) headers . append ( \"X-Process-Time\" , str ( process_time )) await send ( message ) await self . app ( scope , receive , send_wrapper ) else : await self . app ( scope , receive , send )","title":"Modifying ASGI Requests and Responses using the MiddlewareProtocol"},{"location":"usage/7-middleware/3-builtin-middlewares/0-builtin-middlewares-intro/","text":"Builtin Middlewares Starlite comes with several builtin middlewares that you can easily configure to run in your application.","title":"Builtin Middlewares"},{"location":"usage/7-middleware/3-builtin-middlewares/0-builtin-middlewares-intro/#builtin-middlewares","text":"Starlite comes with several builtin middlewares that you can easily configure to run in your application.","title":"Builtin Middlewares"},{"location":"usage/7-middleware/3-builtin-middlewares/1-cors-middleware/","text":"CORS CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of starlite.config.CORSConfig to the Starlite constructor: from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) See the API Reference for full details on the CORSConfig class and the kwargs it accepts. Note The asterisks symbol in the above kwargs means \"match any\". You can read more about this middleware in the starlette docs .","title":"CORS"},{"location":"usage/7-middleware/3-builtin-middlewares/1-cors-middleware/#cors","text":"CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of starlite.config.CORSConfig to the Starlite constructor: from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) See the API Reference for full details on the CORSConfig class and the kwargs it accepts. Note The asterisks symbol in the above kwargs means \"match any\". You can read more about this middleware in the starlette docs .","title":"CORS"},{"location":"usage/7-middleware/3-builtin-middlewares/2-allowed-hosts-middleware/","text":"Allowed Hosts Another common security mechanism is to require that each incoming request has a \"HOST\" header, and then to restrict hosts to a specific set of domains - what's called \"allowed hosts\". To enable this middleware simply pass a list of trusted hosts to the Starlite constructor: from starlite import Starlite app = Starlite ( request_handlers = [ ... ], allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ) You can use * to match any subdomains, as in the above.","title":"Allowed Hosts"},{"location":"usage/7-middleware/3-builtin-middlewares/2-allowed-hosts-middleware/#allowed-hosts","text":"Another common security mechanism is to require that each incoming request has a \"HOST\" header, and then to restrict hosts to a specific set of domains - what's called \"allowed hosts\". To enable this middleware simply pass a list of trusted hosts to the Starlite constructor: from starlite import Starlite app = Starlite ( request_handlers = [ ... ], allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ) You can use * to match any subdomains, as in the above.","title":"Allowed Hosts"},{"location":"usage/7-middleware/3-builtin-middlewares/3-csrf-middleware/","text":"CSRF CSRF ( Cross-site request forgery ) is a type of attack where unauthorized commands are submitted from a user that the web application trusts. This attack often uses social engineering that tricks the victim into clicking a URL that contains a maliciously crafted, unauthorized request for a particular Web application. The user\u2019s browser then sends this maliciously crafted request to the targeted Web application. If the user is in an active session with the Web application, the application treats this new request as an authorized request submitted by the user. Thus, the attacker can force the user to perform an action the user didn't intend, for example: POST /send-money HTTP/1.1 Host: target.web.app Content-Type: application/x-www-form-urlencoded amount=1000usd&to=attacker@evil.com This middleware prevents CSRF attacks by doing the following: On the first \"safe\" request (e.g GET ) - set a cookie with a special token created by the server On each subsequent \"unsafe\" request (e.g POST ) - make sure the request contains either a form field or an additional header that has this token To enable CSRF protection in a Starlite application simply pass an instance of starlite.config.CSRFConfig to the Starlite constructor: from starlite import Starlite , CSRFConfig csrf_config = CSRFConfig ( secret = \"my-secret\" ) app = Starlite ( route_handlers = [ ... ], csrf_config = csrf_config ) Some routes can be marked as being exempt from the protection offered by this middleware via handler opts from starlite import post @post ( \"/post\" , exclude_from_csrf = True ) def handler () -> None : ... If you need to exempt many routes at once you might want to consider using exclude kwarg which accepts list of path patterns to skip in the middleware. See the API Reference for full details on the CSRFConfig class and the kwargs it accepts.","title":"CSRF"},{"location":"usage/7-middleware/3-builtin-middlewares/3-csrf-middleware/#csrf","text":"CSRF ( Cross-site request forgery ) is a type of attack where unauthorized commands are submitted from a user that the web application trusts. This attack often uses social engineering that tricks the victim into clicking a URL that contains a maliciously crafted, unauthorized request for a particular Web application. The user\u2019s browser then sends this maliciously crafted request to the targeted Web application. If the user is in an active session with the Web application, the application treats this new request as an authorized request submitted by the user. Thus, the attacker can force the user to perform an action the user didn't intend, for example: POST /send-money HTTP/1.1 Host: target.web.app Content-Type: application/x-www-form-urlencoded amount=1000usd&to=attacker@evil.com This middleware prevents CSRF attacks by doing the following: On the first \"safe\" request (e.g GET ) - set a cookie with a special token created by the server On each subsequent \"unsafe\" request (e.g POST ) - make sure the request contains either a form field or an additional header that has this token To enable CSRF protection in a Starlite application simply pass an instance of starlite.config.CSRFConfig to the Starlite constructor: from starlite import Starlite , CSRFConfig csrf_config = CSRFConfig ( secret = \"my-secret\" ) app = Starlite ( route_handlers = [ ... ], csrf_config = csrf_config ) Some routes can be marked as being exempt from the protection offered by this middleware via handler opts from starlite import post @post ( \"/post\" , exclude_from_csrf = True ) def handler () -> None : ... If you need to exempt many routes at once you might want to consider using exclude kwarg which accepts list of path patterns to skip in the middleware. See the API Reference for full details on the CSRFConfig class and the kwargs it accepts.","title":"CSRF"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/","text":"Compression HTML responses can optionally be compressed. Starlite has built in support for gzip and brotli. Gzip support is provided through the built-in Starlette classes, and brotli support can be added by installing the brotli extras. You can enable either backend by passing an instance of starlite.config.CompressionConfig into the compression_config application parameter. GZIP You can enable gzip compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"gzip\" : You can configure the following additional gzip-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. gzip_compress_level : a range between 0-9, see the official python docs . Defaults to 9 , which is the maximum value. from starlite import Starlite , CompressionConfig app = Starlite ( request_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"gzip\" , gzip_compress_level = 9 ), ) Brotli The Brotli package is required to run this middleware. It is available as an extras to starlite with the brotli extra. ( pip install starlite[brotli] ) You can enable brotli compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"brotli\" : You can configure the following additional brotli-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. brotli_quality : Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression. brotli_mode : The compression mode can be MODE_GENERIC (default), MODE_TEXT (for UTF-8 format text input) or MODE_FONT (for WOFF 2.0). brotli_lgwin : Base 2 logarithm of size. Range is 10 to 24. Defaults to 22. brotli_lgblock : Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0. brotli_gzip_fallback : a boolean to indicate if gzip should be used if brotli is not supported. from starlite import Starlite from starlite.config import CompressionConfig app = Starlite ( request_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"brotli\" , brotli_gzip_fallback = True ), )","title":"Compression"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/#compression","text":"HTML responses can optionally be compressed. Starlite has built in support for gzip and brotli. Gzip support is provided through the built-in Starlette classes, and brotli support can be added by installing the brotli extras. You can enable either backend by passing an instance of starlite.config.CompressionConfig into the compression_config application parameter.","title":"Compression"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/#gzip","text":"You can enable gzip compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"gzip\" : You can configure the following additional gzip-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. gzip_compress_level : a range between 0-9, see the official python docs . Defaults to 9 , which is the maximum value. from starlite import Starlite , CompressionConfig app = Starlite ( request_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"gzip\" , gzip_compress_level = 9 ), )","title":"GZIP"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/#brotli","text":"The Brotli package is required to run this middleware. It is available as an extras to starlite with the brotli extra. ( pip install starlite[brotli] ) You can enable brotli compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"brotli\" : You can configure the following additional brotli-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. brotli_quality : Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression. brotli_mode : The compression mode can be MODE_GENERIC (default), MODE_TEXT (for UTF-8 format text input) or MODE_FONT (for WOFF 2.0). brotli_lgwin : Base 2 logarithm of size. Range is 10 to 24. Defaults to 22. brotli_lgblock : Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0. brotli_gzip_fallback : a boolean to indicate if gzip should be used if brotli is not supported. from starlite import Starlite from starlite.config import CompressionConfig app = Starlite ( request_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"brotli\" , brotli_gzip_fallback = True ), )","title":"Brotli"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/","text":"Session Middleware Starlite includes its own implementation of SessionMiddleware , which offers strong AES-CGM encryption security best practices while support cookie splitting. Important The Starlite SessionMiddleware is not based on the Starlette SessionMiddleware , although it is compatible with it, and it can act as a drop-in replacement. The Starlite middleware offers stronger security and is recommended. It does require though the cryptography library, so make sure to install it. To use the SessionMiddleware simply create an instance of SessionCookieConfig and pass the created middleware to any layer of the application: Hello World from os import urandom from starlite import Request , Starlite , delete , get , post from starlite.middleware.session import SessionCookieConfig # we initialize to config with a 16 byte key, i.e. 128 a bit key. # in real world usage we should inject the secret from the environment session_config = SessionCookieConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] @get ( \"/session\" ) def check_session_handler ( request : Request ) -> dict [ str , bool ]: \"\"\"Handler function that accesses request.session.\"\"\" return { \"has_session\" : request . session != {}} @post ( \"/session\" ) def create_session_handler ( request : Request ) -> None : \"\"\"Handler to set the session.\"\"\" if not request . session : # value can be a dictionary or pydantic model request . set_session ({ \"username\" : \"moishezuchmir\" }) @delete ( \"/session\" ) def delete_session_handler ( request : Request ) -> None : \"\"\"Handler to clear the session.\"\"\" if request . session : request . clear_session () app = Starlite ( route_handlers = [ check_session_handler , create_session_handler , delete_session_handler ], middleware = [ session_config . middleware ], ) For additional configuration options please see the configuration references .","title":"Session Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#session-middleware","text":"Starlite includes its own implementation of SessionMiddleware , which offers strong AES-CGM encryption security best practices while support cookie splitting. Important The Starlite SessionMiddleware is not based on the Starlette SessionMiddleware , although it is compatible with it, and it can act as a drop-in replacement. The Starlite middleware offers stronger security and is recommended. It does require though the cryptography library, so make sure to install it. To use the SessionMiddleware simply create an instance of SessionCookieConfig and pass the created middleware to any layer of the application: Hello World from os import urandom from starlite import Request , Starlite , delete , get , post from starlite.middleware.session import SessionCookieConfig # we initialize to config with a 16 byte key, i.e. 128 a bit key. # in real world usage we should inject the secret from the environment session_config = SessionCookieConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] @get ( \"/session\" ) def check_session_handler ( request : Request ) -> dict [ str , bool ]: \"\"\"Handler function that accesses request.session.\"\"\" return { \"has_session\" : request . session != {}} @post ( \"/session\" ) def create_session_handler ( request : Request ) -> None : \"\"\"Handler to set the session.\"\"\" if not request . session : # value can be a dictionary or pydantic model request . set_session ({ \"username\" : \"moishezuchmir\" }) @delete ( \"/session\" ) def delete_session_handler ( request : Request ) -> None : \"\"\"Handler to clear the session.\"\"\" if request . session : request . clear_session () app = Starlite ( route_handlers = [ check_session_handler , create_session_handler , delete_session_handler ], middleware = [ session_config . middleware ], ) For additional configuration options please see the configuration references .","title":"Session Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/6-rate-limit-middleware/","text":"Rate-Limit Middleware Starlite includes an optional RateLimitMiddleware that follows the IETF RateLimit draft specification . To use the rate limit middleware, use the RateLimitConfig : from starlite import Starlite from starlite.middleware import RateLimitConfig RateLimitConfig ( rate_limit = ( \"second\" , 1 ), exclude = [ \"/schema\" ], ) app = Starlite ( route_handlers = [ ... ], middleware = [ RateLimitConfig . middleware ]) The only required configuration kwarg is rate_limit , which expects a tuple containing a time-unit ( second , minute , hour , day ) and a value for the request quota (integer). For the other configuration options, see the additional configuration options in the reference .","title":"Rate-Limit Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/6-rate-limit-middleware/#rate-limit-middleware","text":"Starlite includes an optional RateLimitMiddleware that follows the IETF RateLimit draft specification . To use the rate limit middleware, use the RateLimitConfig : from starlite import Starlite from starlite.middleware import RateLimitConfig RateLimitConfig ( rate_limit = ( \"second\" , 1 ), exclude = [ \"/schema\" ], ) app = Starlite ( route_handlers = [ ... ], middleware = [ RateLimitConfig . middleware ]) The only required configuration kwarg is rate_limit , which expects a tuple containing a time-unit ( second , minute , hour , day ) and a value for the request quota (integer). For the other configuration options, see the additional configuration options in the reference .","title":"Rate-Limit Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/","text":"Logging Middleware Starlite ships with a robust logging middleware that allows logging HTTP request and responses while building on the app level logging configuration : from starlite import Starlite , LoggingConfig , get from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ my_handler ], logging_config = LoggingConfig (), middleware = [ logging_middleware_config . middleware ], ) The logging middleware use the logger configuration defined on the application level, which allows for using both stdlib logging or structlog , depending on the configuration used ( see logging for more details). Obfuscating Logging Output Sometimes certain data, e.g. request or response headers, needs to be obfuscated. This is supported by the middleware configuration: from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig ( request_cookies_to_obfuscate = { \"my-custom-session-key\" }, response_cookies_to_obfuscate = { \"my-custom-session-key\" }, request_headers_to_obfuscate = { \"my-custom-header\" }, response_headers_to_obfuscate = { \"my-custom-header\" }, ) The middleware will obfuscate the headers Authorization and X-API-KEY , and the cookie session by default. You can read more about the configuration options in the api reference","title":"Logging Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/#logging-middleware","text":"Starlite ships with a robust logging middleware that allows logging HTTP request and responses while building on the app level logging configuration : from starlite import Starlite , LoggingConfig , get from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ my_handler ], logging_config = LoggingConfig (), middleware = [ logging_middleware_config . middleware ], ) The logging middleware use the logger configuration defined on the application level, which allows for using both stdlib logging or structlog , depending on the configuration used ( see logging for more details).","title":"Logging Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/#obfuscating-logging-output","text":"Sometimes certain data, e.g. request or response headers, needs to be obfuscated. This is supported by the middleware configuration: from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig ( request_cookies_to_obfuscate = { \"my-custom-session-key\" }, response_cookies_to_obfuscate = { \"my-custom-session-key\" }, request_headers_to_obfuscate = { \"my-custom-header\" }, response_headers_to_obfuscate = { \"my-custom-header\" }, ) The middleware will obfuscate the headers Authorization and X-API-KEY , and the cookie session by default. You can read more about the configuration options in the api reference","title":"Obfuscating Logging Output"},{"location":"usage/8-authentication/0-intro/","text":"Authentication Starlite is agnostic to any authentication mechanism(s) used - you can use JWT, session cookies, OIDC or any other mechanism to authenticate users. Saying that, Starlite does offer an AbstractAuthenticationMiddleware class that is meant to make building authentication simpler. Additionally, there are official authentication libraries .","title":"Authentication"},{"location":"usage/8-authentication/0-intro/#authentication","text":"Starlite is agnostic to any authentication mechanism(s) used - you can use JWT, session cookies, OIDC or any other mechanism to authenticate users. Saying that, Starlite does offer an AbstractAuthenticationMiddleware class that is meant to make building authentication simpler. Additionally, there are official authentication libraries .","title":"Authentication"},{"location":"usage/8-authentication/1-abstract-authentication-middleware/","text":"AbstractAuthenticationMiddleware Starlite exports a class called AbstractAuthenticationMiddleware , which is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app using this class as a basis, subclass it and implement the abstract method authenticate_request : from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , ASGIConnection , ) class MyAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : # do something here. ... As you can see, authenticate_request is an async function that receives a connection instance and is supposed to return an AuthenticationResult instance, which is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively, for HTTP route handlers, and WebSocket.user and WebSocket.auth for websocket route handlers. Example: Implementing a JWTAuthenticationMiddleware Since the above is quite hard to grasp in the abstract, lets see an example. We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say it's a pydantic model: my_app/db/models.py import uuid from sqlalchemy import Column from sqlalchemy.dialects.postgresql import UUID from sqlalchemy.orm import declarative_base Base = declarative_base () class User ( Base ): id : uuid . UUID | None = Column ( UUID ( as_uuid = True ), default = uuid . uuid4 , primary_key = True ) # ... other fields follow, but we only require id for this example We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token: my_app/security/jwt.py from datetime import datetime , timedelta from uuid import UUID from jose import JWTError , jwt from pydantic import BaseModel , UUID4 from starlite.exceptions import NotAuthorizedException from app.config import settings DEFAULT_TIME_DELTA = timedelta ( days = 1 ) ALGORITHM = \"HS256\" class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 def decode_jwt_token ( encoded_token : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = settings . JWT_SECRET , algorithms = [ ALGORITHM ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e def encode_jwt_token ( user_id : UUID , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" token = Token ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( token . dict (), settings . JWT_SECRET , algorithm = ALGORITHM ) We can now create our authentication middleware: my_app/security/authentication_middleware.py from typing import cast , TYPE_CHECKING from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncSession from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException , ASGIConnection , ) from app.db.models import User from app.security.jwt import decode_jwt_token if TYPE_CHECKING : from sqlalchemy.ext.asyncio import AsyncEngine API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : \"\"\" Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB \"\"\" # retrieve the auth header auth_header = connection . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # decode the token, the result is a 'Token' model instance token = decode_jwt_token ( encoded_token = auth_header ) engine = cast ( \"AsyncEngine\" , connection . app . state . postgres_connection ) async with AsyncSession ( engine ) as async_session : async with async_session . begin (): user = await async_session . execute ( select ( User ) . where ( User . id == token . sub ) ) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) app = Starlite ( request_handlers = [ ... ], middleware = [ auth_mw ]) That's it. The JWTAuthenticationMiddleware will now run for every request, and we would be able to access these in a http route handler in the following way: from starlite import Request , get from my_app.db.models import User from my_app.security.jwt import Token @get ( \"/\" ) def my_route_handler ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) Or for a websocket route: from starlite import WebSocket , websocket from my_app.db.models import User from my_app.security.jwt import Token @websocket ( \"/\" ) async def my_route_handler ( socket : WebSocket [ User , Token ]) -> None : user = socket . user # correctly typed as User auth = socket . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) And if you'd like to exclude individual routes outside those configured: import anyio from starlite import Starlite , MediaType , NotFoundException , Response , get from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` # additionally, # you can modify the default exclude key of \"exclude_from_auth\", by overriding the `exclude_from_auth_key` parameter on the Authentication Middleware auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) @get ( path = \"/\" , exclude_from_auth = True ) async def site_index () -> Response : \"\"\"Site index\"\"\" exists = await anyio . Path ( \"index.html\" ) . exists () if exists : async with await anyio . open_file ( anyio . Path ( \"index.html\" )) as file : content = await file . read () return Response ( content = content , status_code = 200 , media_type = MediaType . HTML ) raise NotFoundException ( \"Site index was not found\" ) app = Starlite ( request_handlers = [ site_index ], middleware = [ auth_mw ]) And of course use the same kind of mechanism for dependencies: from typing import Any from starlite import Request , Provide , Router from my_app.db.models import User from my_app.security.jwt import Token async def my_dependency ( request : Request [ User , Token ]) -> Any : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) my_router = Router ( path = \"sub-path/\" , dependencies = { \"some_dependency\" : Provide ( my_dependency )} )","title":"AbstractAuthenticationMiddleware"},{"location":"usage/8-authentication/1-abstract-authentication-middleware/#abstractauthenticationmiddleware","text":"Starlite exports a class called AbstractAuthenticationMiddleware , which is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app using this class as a basis, subclass it and implement the abstract method authenticate_request : from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , ASGIConnection , ) class MyAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : # do something here. ... As you can see, authenticate_request is an async function that receives a connection instance and is supposed to return an AuthenticationResult instance, which is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively, for HTTP route handlers, and WebSocket.user and WebSocket.auth for websocket route handlers.","title":"AbstractAuthenticationMiddleware"},{"location":"usage/8-authentication/1-abstract-authentication-middleware/#example-implementing-a-jwtauthenticationmiddleware","text":"Since the above is quite hard to grasp in the abstract, lets see an example. We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say it's a pydantic model: my_app/db/models.py import uuid from sqlalchemy import Column from sqlalchemy.dialects.postgresql import UUID from sqlalchemy.orm import declarative_base Base = declarative_base () class User ( Base ): id : uuid . UUID | None = Column ( UUID ( as_uuid = True ), default = uuid . uuid4 , primary_key = True ) # ... other fields follow, but we only require id for this example We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token: my_app/security/jwt.py from datetime import datetime , timedelta from uuid import UUID from jose import JWTError , jwt from pydantic import BaseModel , UUID4 from starlite.exceptions import NotAuthorizedException from app.config import settings DEFAULT_TIME_DELTA = timedelta ( days = 1 ) ALGORITHM = \"HS256\" class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 def decode_jwt_token ( encoded_token : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = settings . JWT_SECRET , algorithms = [ ALGORITHM ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e def encode_jwt_token ( user_id : UUID , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" token = Token ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( token . dict (), settings . JWT_SECRET , algorithm = ALGORITHM ) We can now create our authentication middleware: my_app/security/authentication_middleware.py from typing import cast , TYPE_CHECKING from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncSession from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException , ASGIConnection , ) from app.db.models import User from app.security.jwt import decode_jwt_token if TYPE_CHECKING : from sqlalchemy.ext.asyncio import AsyncEngine API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : \"\"\" Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB \"\"\" # retrieve the auth header auth_header = connection . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # decode the token, the result is a 'Token' model instance token = decode_jwt_token ( encoded_token = auth_header ) engine = cast ( \"AsyncEngine\" , connection . app . state . postgres_connection ) async with AsyncSession ( engine ) as async_session : async with async_session . begin (): user = await async_session . execute ( select ( User ) . where ( User . id == token . sub ) ) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) app = Starlite ( request_handlers = [ ... ], middleware = [ auth_mw ]) That's it. The JWTAuthenticationMiddleware will now run for every request, and we would be able to access these in a http route handler in the following way: from starlite import Request , get from my_app.db.models import User from my_app.security.jwt import Token @get ( \"/\" ) def my_route_handler ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) Or for a websocket route: from starlite import WebSocket , websocket from my_app.db.models import User from my_app.security.jwt import Token @websocket ( \"/\" ) async def my_route_handler ( socket : WebSocket [ User , Token ]) -> None : user = socket . user # correctly typed as User auth = socket . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) And if you'd like to exclude individual routes outside those configured: import anyio from starlite import Starlite , MediaType , NotFoundException , Response , get from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` # additionally, # you can modify the default exclude key of \"exclude_from_auth\", by overriding the `exclude_from_auth_key` parameter on the Authentication Middleware auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) @get ( path = \"/\" , exclude_from_auth = True ) async def site_index () -> Response : \"\"\"Site index\"\"\" exists = await anyio . Path ( \"index.html\" ) . exists () if exists : async with await anyio . open_file ( anyio . Path ( \"index.html\" )) as file : content = await file . read () return Response ( content = content , status_code = 200 , media_type = MediaType . HTML ) raise NotFoundException ( \"Site index was not found\" ) app = Starlite ( request_handlers = [ site_index ], middleware = [ auth_mw ]) And of course use the same kind of mechanism for dependencies: from typing import Any from starlite import Request , Provide , Router from my_app.db.models import User from my_app.security.jwt import Token async def my_dependency ( request : Request [ User , Token ]) -> Any : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) my_router = Router ( path = \"sub-path/\" , dependencies = { \"some_dependency\" : Provide ( my_dependency )} )","title":"Example: Implementing a JWTAuthenticationMiddleware"},{"location":"usage/8-authentication/2-official-authentication-libraries/","text":"Official Authentication Libraries The starlite-api GitHub organization develops and maintains several official authentication libraries. This page will be updated as these are developed. Available Starlite-JWT - an JWT authentication library. Starlite-Sessions - a session-cookie based authentication library. Actively developed Starlite-OIDC - an OpenID connect authentication library.","title":"Official Authentication Libraries"},{"location":"usage/8-authentication/2-official-authentication-libraries/#official-authentication-libraries","text":"The starlite-api GitHub organization develops and maintains several official authentication libraries. This page will be updated as these are developed.","title":"Official Authentication Libraries"},{"location":"usage/8-authentication/2-official-authentication-libraries/#available","text":"Starlite-JWT - an JWT authentication library. Starlite-Sessions - a session-cookie based authentication library.","title":"Available"},{"location":"usage/8-authentication/2-official-authentication-libraries/#actively-developed","text":"Starlite-OIDC - an OpenID connect authentication library.","title":"Actively developed"}]}